"use strict";

function _regeneratorRuntime() { "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ _regeneratorRuntime = function _regeneratorRuntime() { return e; }; var t, e = {}, r = Object.prototype, n = r.hasOwnProperty, o = Object.defineProperty || function (t, e, r) { t[e] = r.value; }, i = "function" == typeof Symbol ? Symbol : {}, a = i.iterator || "@@iterator", c = i.asyncIterator || "@@asyncIterator", u = i.toStringTag || "@@toStringTag"; function define(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e]; } try { define({}, ""); } catch (t) { define = function define(t, e, r) { return t[e] = r; }; } function wrap(t, e, r, n) { var i = e && e.prototype instanceof Generator ? e : Generator, a = Object.create(i.prototype), c = new Context(n || []); return o(a, "_invoke", { value: makeInvokeMethod(t, r, c) }), a; } function tryCatch(t, e, r) { try { return { type: "normal", arg: t.call(e, r) }; } catch (t) { return { type: "throw", arg: t }; } } e.wrap = wrap; var h = "suspendedStart", l = "suspendedYield", f = "executing", s = "completed", y = {}; function Generator() {} function GeneratorFunction() {} function GeneratorFunctionPrototype() {} var p = {}; define(p, a, function () { return this; }); var d = Object.getPrototypeOf, v = d && d(d(values([]))); v && v !== r && n.call(v, a) && (p = v); var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p); function defineIteratorMethods(t) { ["next", "throw", "return"].forEach(function (e) { define(t, e, function (t) { return this._invoke(e, t); }); }); } function AsyncIterator(t, e) { function invoke(r, o, i, a) { var c = tryCatch(t[r], t, o); if ("throw" !== c.type) { var u = c.arg, h = u.value; return h && "object" == typeof h && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) { invoke("next", t, i, a); }, function (t) { invoke("throw", t, i, a); }) : e.resolve(h).then(function (t) { u.value = t, i(u); }, function (t) { return invoke("throw", t, i, a); }); } a(c.arg); } var r; o(this, "_invoke", { value: function value(t, n) { function callInvokeWithMethodAndArg() { return new e(function (e, r) { invoke(t, n, e, r); }); } return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg(); } }); } function makeInvokeMethod(e, r, n) { var o = h; return function (i, a) { if (o === f) throw new Error("Generator is already running"); if (o === s) { if ("throw" === i) throw a; return { value: t, done: !0 }; } for (n.method = i, n.arg = a;;) { var c = n.delegate; if (c) { var u = maybeInvokeDelegate(c, n); if (u) { if (u === y) continue; return u; } } if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) { if (o === h) throw o = s, n.arg; n.dispatchException(n.arg); } else "return" === n.method && n.abrupt("return", n.arg); o = f; var p = tryCatch(e, r, n); if ("normal" === p.type) { if (o = n.done ? s : l, p.arg === y) continue; return { value: p.arg, done: n.done }; } "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg); } }; } function maybeInvokeDelegate(e, r) { var n = r.method, o = e.iterator[n]; if (o === t) return r.delegate = null, "throw" === n && e.iterator.return && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y; var i = tryCatch(o, e.iterator, r.arg); if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y; var a = i.arg; return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y); } function pushTryEntry(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e); } function resetTryEntry(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e; } function Context(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(pushTryEntry, this), this.reset(!0); } function values(e) { if (e || "" === e) { var r = e[a]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var o = -1, i = function next() { for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = !1, next; return next.value = t, next.done = !0, next; }; return i.next = i; } } throw new TypeError(typeof e + " is not iterable"); } return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", { value: GeneratorFunctionPrototype, configurable: !0 }), o(GeneratorFunctionPrototype, "constructor", { value: GeneratorFunction, configurable: !0 }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name)); }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t; }, e.awrap = function (t) { return { __await: t }; }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () { return this; }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) { void 0 === i && (i = Promise); var a = new AsyncIterator(wrap(t, r, n, o), i); return e.isGeneratorFunction(r) ? a : a.next().then(function (t) { return t.done ? t.value : a.next(); }); }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () { return this; }), define(g, "toString", function () { return "[object Generator]"; }), e.keys = function (t) { var e = Object(t), r = []; for (var n in e) r.push(n); return r.reverse(), function next() { for (; r.length;) { var t = r.pop(); if (t in e) return next.value = t, next.done = !1, next; } return next.done = !0, next; }; }, e.values = values, Context.prototype = { constructor: Context, reset: function reset(e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t); }, stop: function stop() { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval; }, dispatchException: function dispatchException(e) { if (this.done) throw e; var r = this; function handle(n, o) { return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o; } for (var o = this.tryEntries.length - 1; o >= 0; --o) { var i = this.tryEntries[o], a = i.completion; if ("root" === i.tryLoc) return handle("end"); if (i.tryLoc <= this.prev) { var c = n.call(i, "catchLoc"), u = n.call(i, "finallyLoc"); if (c && u) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } else if (c) { if (this.prev < i.catchLoc) return handle(i.catchLoc, !0); } else { if (!u) throw new Error("try statement without catch or finally"); if (this.prev < i.finallyLoc) return handle(i.finallyLoc); } } } }, abrupt: function abrupt(t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var o = this.tryEntries[r]; if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) { var i = o; break; } } i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null); var a = i ? i.completion : {}; return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a); }, complete: function complete(t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y; }, finish: function finish(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y; } }, catch: function _catch(t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var n = r.completion; if ("throw" === n.type) { var o = n.arg; resetTryEntry(r); } return o; } } throw new Error("illegal catch attempt"); }, delegateYield: function delegateYield(e, r, n) { return this.delegate = { iterator: values(e), resultName: r, nextLoc: n }, "next" === this.method && (this.arg = t), y; } }, e; }
function ownKeys(e, r) { var t = Object.keys(e); if (Object.getOwnPropertySymbols) { var o = Object.getOwnPropertySymbols(e); r && (o = o.filter(function (r) { return Object.getOwnPropertyDescriptor(e, r).enumerable; })), t.push.apply(t, o); } return t; }
function _objectSpread(e) { for (var r = 1; r < arguments.length; r++) { var t = null != arguments[r] ? arguments[r] : {}; r % 2 ? ownKeys(Object(t), !0).forEach(function (r) { _defineProperty(e, r, t[r]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) { Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r)); }); } return e; }
function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get.bind(); } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }
function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it.return != null) it.return(); } finally { if (didErr) throw err; } } }; }
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }
function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }
function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }
function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }
function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _iterableToArrayLimit(r, l) { var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"]; if (null != t) { var e, n, i, u, a = [], f = !0, o = !1; try { if (i = (t = t.call(r)).next, 0 === l) { if (Object(t) !== t) return; f = !1; } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0); } catch (r) { o = !0, n = r; } finally { try { if (!f && null != t.return && (u = t.return(), Object(u) !== u)) return; } finally { if (o) throw n; } } return a; } }
function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }
function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }
function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }
function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }
function _possibleConstructorReturn(self, call) { if (call && (typeof call === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }
function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }
function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }
function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
/******/(function () {
  // webpackBootstrap
  /******/
  var __webpack_modules__ = {
    /***/"./node_modules/lodash/lodash.js":
    /*!***************************************!*\
      !*** ./node_modules/lodash/lodash.js ***!
      \***************************************/
    /***/
    function node_modulesLodashLodashJs(module, exports, __webpack_require__) {
      /* module decorator */module = __webpack_require__.nmd(module);
      var __WEBPACK_AMD_DEFINE_RESULT__; /**
                                         * @license
                                         * Lodash <https://lodash.com/>
                                         * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
                                         * Released under MIT license <https://lodash.com/license>
                                         * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
                                         * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
                                         */
      ;
      (function () {
        /** Used as a safe reference for `undefined` in pre-ES5 environments. */
        var undefined;

        /** Used as the semantic version number. */
        var VERSION = '4.17.21';

        /** Used as the size to enable large array optimizations. */
        var LARGE_ARRAY_SIZE = 200;

        /** Error message constants. */
        var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
          FUNC_ERROR_TEXT = 'Expected a function',
          INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

        /** Used to stand-in for `undefined` hash values. */
        var HASH_UNDEFINED = '__lodash_hash_undefined__';

        /** Used as the maximum memoize cache size. */
        var MAX_MEMOIZE_SIZE = 500;

        /** Used as the internal argument placeholder. */
        var PLACEHOLDER = '__lodash_placeholder__';

        /** Used to compose bitmasks for cloning. */
        var CLONE_DEEP_FLAG = 1,
          CLONE_FLAT_FLAG = 2,
          CLONE_SYMBOLS_FLAG = 4;

        /** Used to compose bitmasks for value comparisons. */
        var COMPARE_PARTIAL_FLAG = 1,
          COMPARE_UNORDERED_FLAG = 2;

        /** Used to compose bitmasks for function metadata. */
        var WRAP_BIND_FLAG = 1,
          WRAP_BIND_KEY_FLAG = 2,
          WRAP_CURRY_BOUND_FLAG = 4,
          WRAP_CURRY_FLAG = 8,
          WRAP_CURRY_RIGHT_FLAG = 16,
          WRAP_PARTIAL_FLAG = 32,
          WRAP_PARTIAL_RIGHT_FLAG = 64,
          WRAP_ARY_FLAG = 128,
          WRAP_REARG_FLAG = 256,
          WRAP_FLIP_FLAG = 512;

        /** Used as default options for `_.truncate`. */
        var DEFAULT_TRUNC_LENGTH = 30,
          DEFAULT_TRUNC_OMISSION = '...';

        /** Used to detect hot functions by number of calls within a span of milliseconds. */
        var HOT_COUNT = 800,
          HOT_SPAN = 16;

        /** Used to indicate the type of lazy iteratees. */
        var LAZY_FILTER_FLAG = 1,
          LAZY_MAP_FLAG = 2,
          LAZY_WHILE_FLAG = 3;

        /** Used as references for various `Number` constants. */
        var INFINITY = 1 / 0,
          MAX_SAFE_INTEGER = 9007199254740991,
          MAX_INTEGER = 1.7976931348623157e+308,
          NAN = 0 / 0;

        /** Used as references for the maximum length and index of an array. */
        var MAX_ARRAY_LENGTH = 4294967295,
          MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
          HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

        /** Used to associate wrap methods with their bit flags. */
        var wrapFlags = [['ary', WRAP_ARY_FLAG], ['bind', WRAP_BIND_FLAG], ['bindKey', WRAP_BIND_KEY_FLAG], ['curry', WRAP_CURRY_FLAG], ['curryRight', WRAP_CURRY_RIGHT_FLAG], ['flip', WRAP_FLIP_FLAG], ['partial', WRAP_PARTIAL_FLAG], ['partialRight', WRAP_PARTIAL_RIGHT_FLAG], ['rearg', WRAP_REARG_FLAG]];

        /** `Object#toString` result references. */
        var argsTag = '[object Arguments]',
          arrayTag = '[object Array]',
          asyncTag = '[object AsyncFunction]',
          boolTag = '[object Boolean]',
          dateTag = '[object Date]',
          domExcTag = '[object DOMException]',
          errorTag = '[object Error]',
          funcTag = '[object Function]',
          genTag = '[object GeneratorFunction]',
          mapTag = '[object Map]',
          numberTag = '[object Number]',
          nullTag = '[object Null]',
          objectTag = '[object Object]',
          promiseTag = '[object Promise]',
          proxyTag = '[object Proxy]',
          regexpTag = '[object RegExp]',
          setTag = '[object Set]',
          stringTag = '[object String]',
          symbolTag = '[object Symbol]',
          undefinedTag = '[object Undefined]',
          weakMapTag = '[object WeakMap]',
          weakSetTag = '[object WeakSet]';
        var arrayBufferTag = '[object ArrayBuffer]',
          dataViewTag = '[object DataView]',
          float32Tag = '[object Float32Array]',
          float64Tag = '[object Float64Array]',
          int8Tag = '[object Int8Array]',
          int16Tag = '[object Int16Array]',
          int32Tag = '[object Int32Array]',
          uint8Tag = '[object Uint8Array]',
          uint8ClampedTag = '[object Uint8ClampedArray]',
          uint16Tag = '[object Uint16Array]',
          uint32Tag = '[object Uint32Array]';

        /** Used to match empty string literals in compiled template source. */
        var reEmptyStringLeading = /\b__p \+= '';/g,
          reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
          reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

        /** Used to match HTML entities and HTML characters. */
        var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
          reUnescapedHtml = /[&<>"']/g,
          reHasEscapedHtml = RegExp(reEscapedHtml.source),
          reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

        /** Used to match template delimiters. */
        var reEscape = /<%-([\s\S]+?)%>/g,
          reEvaluate = /<%([\s\S]+?)%>/g,
          reInterpolate = /<%=([\s\S]+?)%>/g;

        /** Used to match property names within property paths. */
        var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
          reIsPlainProp = /^\w*$/,
          rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

        /**
         * Used to match `RegExp`
         * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
         */
        var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
          reHasRegExpChar = RegExp(reRegExpChar.source);

        /** Used to match leading whitespace. */
        var reTrimStart = /^\s+/;

        /** Used to match a single whitespace character. */
        var reWhitespace = /\s/;

        /** Used to match wrap detail comments. */
        var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
          reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
          reSplitDetails = /,? & /;

        /** Used to match words composed of alphanumeric characters. */
        var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

        /**
         * Used to validate the `validate` option in `_.template` variable.
         *
         * Forbids characters which could potentially change the meaning of the function argument definition:
         * - "()," (modification of function parameters)
         * - "=" (default value)
         * - "[]{}" (destructuring of function parameters)
         * - "/" (beginning of a comment)
         * - whitespace
         */
        var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

        /** Used to match backslashes in property paths. */
        var reEscapeChar = /\\(\\)?/g;

        /**
         * Used to match
         * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
         */
        var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

        /** Used to match `RegExp` flags from their coerced string values. */
        var reFlags = /\w*$/;

        /** Used to detect bad signed hexadecimal string values. */
        var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

        /** Used to detect binary string values. */
        var reIsBinary = /^0b[01]+$/i;

        /** Used to detect host constructors (Safari). */
        var reIsHostCtor = /^\[object .+?Constructor\]$/;

        /** Used to detect octal string values. */
        var reIsOctal = /^0o[0-7]+$/i;

        /** Used to detect unsigned integer values. */
        var reIsUint = /^(?:0|[1-9]\d*)$/;

        /** Used to match Latin Unicode letters (excluding mathematical operators). */
        var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

        /** Used to ensure capturing order of template delimiters. */
        var reNoMatch = /($^)/;

        /** Used to match unescaped characters in compiled string literals. */
        var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

        /** Used to compose unicode character classes. */
        var rsAstralRange = "\\ud800-\\udfff",
          rsComboMarksRange = "\\u0300-\\u036f",
          reComboHalfMarksRange = "\\ufe20-\\ufe2f",
          rsComboSymbolsRange = "\\u20d0-\\u20ff",
          rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
          rsDingbatRange = "\\u2700-\\u27bf",
          rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
          rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
          rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
          rsPunctuationRange = "\\u2000-\\u206f",
          rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
          rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
          rsVarRange = "\\ufe0e\\ufe0f",
          rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

        /** Used to compose unicode capture groups. */
        var rsApos = "['\u2019]",
          rsAstral = '[' + rsAstralRange + ']',
          rsBreak = '[' + rsBreakRange + ']',
          rsCombo = '[' + rsComboRange + ']',
          rsDigits = '\\d+',
          rsDingbat = '[' + rsDingbatRange + ']',
          rsLower = '[' + rsLowerRange + ']',
          rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
          rsFitz = "\\ud83c[\\udffb-\\udfff]",
          rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
          rsNonAstral = '[^' + rsAstralRange + ']',
          rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
          rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
          rsUpper = '[' + rsUpperRange + ']',
          rsZWJ = "\\u200d";

        /** Used to compose unicode regexes. */
        var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
          rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
          rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
          rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
          reOptMod = rsModifier + '?',
          rsOptVar = '[' + rsVarRange + ']?',
          rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
          rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
          rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
          rsSeq = rsOptVar + reOptMod + rsOptJoin,
          rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
          rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

        /** Used to match apostrophes. */
        var reApos = RegExp(rsApos, 'g');

        /**
         * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
         * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
         */
        var reComboMark = RegExp(rsCombo, 'g');

        /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
        var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

        /** Used to match complex or compound words. */
        var reUnicodeWord = RegExp([rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')', rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')', rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower, rsUpper + '+' + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join('|'), 'g');

        /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
        var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + ']');

        /** Used to detect strings that need a more robust regexp to match words. */
        var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

        /** Used to assign default `context` object properties. */
        var contextProps = ['Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array', 'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object', 'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array', 'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap', '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'];

        /** Used to make template sourceURLs easier to identify. */
        var templateCounter = -1;

        /** Used to identify `toStringTag` values of typed arrays. */
        var typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
        typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

        /** Used to identify `toStringTag` values supported by `_.clone`. */
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
        cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;

        /** Used to map Latin Unicode letters to basic Latin letters. */
        var deburredLetters = {
          // Latin-1 Supplement block.
          '\xc0': 'A',
          '\xc1': 'A',
          '\xc2': 'A',
          '\xc3': 'A',
          '\xc4': 'A',
          '\xc5': 'A',
          '\xe0': 'a',
          '\xe1': 'a',
          '\xe2': 'a',
          '\xe3': 'a',
          '\xe4': 'a',
          '\xe5': 'a',
          '\xc7': 'C',
          '\xe7': 'c',
          '\xd0': 'D',
          '\xf0': 'd',
          '\xc8': 'E',
          '\xc9': 'E',
          '\xca': 'E',
          '\xcb': 'E',
          '\xe8': 'e',
          '\xe9': 'e',
          '\xea': 'e',
          '\xeb': 'e',
          '\xcc': 'I',
          '\xcd': 'I',
          '\xce': 'I',
          '\xcf': 'I',
          '\xec': 'i',
          '\xed': 'i',
          '\xee': 'i',
          '\xef': 'i',
          '\xd1': 'N',
          '\xf1': 'n',
          '\xd2': 'O',
          '\xd3': 'O',
          '\xd4': 'O',
          '\xd5': 'O',
          '\xd6': 'O',
          '\xd8': 'O',
          '\xf2': 'o',
          '\xf3': 'o',
          '\xf4': 'o',
          '\xf5': 'o',
          '\xf6': 'o',
          '\xf8': 'o',
          '\xd9': 'U',
          '\xda': 'U',
          '\xdb': 'U',
          '\xdc': 'U',
          '\xf9': 'u',
          '\xfa': 'u',
          '\xfb': 'u',
          '\xfc': 'u',
          '\xdd': 'Y',
          '\xfd': 'y',
          '\xff': 'y',
          '\xc6': 'Ae',
          '\xe6': 'ae',
          '\xde': 'Th',
          '\xfe': 'th',
          '\xdf': 'ss',
          // Latin Extended-A block.
          "\u0100": 'A',
          "\u0102": 'A',
          "\u0104": 'A',
          "\u0101": 'a',
          "\u0103": 'a',
          "\u0105": 'a',
          "\u0106": 'C',
          "\u0108": 'C',
          "\u010A": 'C',
          "\u010C": 'C',
          "\u0107": 'c',
          "\u0109": 'c',
          "\u010B": 'c',
          "\u010D": 'c',
          "\u010E": 'D',
          "\u0110": 'D',
          "\u010F": 'd',
          "\u0111": 'd',
          "\u0112": 'E',
          "\u0114": 'E',
          "\u0116": 'E',
          "\u0118": 'E',
          "\u011A": 'E',
          "\u0113": 'e',
          "\u0115": 'e',
          "\u0117": 'e',
          "\u0119": 'e',
          "\u011B": 'e',
          "\u011C": 'G',
          "\u011E": 'G',
          "\u0120": 'G',
          "\u0122": 'G',
          "\u011D": 'g',
          "\u011F": 'g',
          "\u0121": 'g',
          "\u0123": 'g',
          "\u0124": 'H',
          "\u0126": 'H',
          "\u0125": 'h',
          "\u0127": 'h',
          "\u0128": 'I',
          "\u012A": 'I',
          "\u012C": 'I',
          "\u012E": 'I',
          "\u0130": 'I',
          "\u0129": 'i',
          "\u012B": 'i',
          "\u012D": 'i',
          "\u012F": 'i',
          "\u0131": 'i',
          "\u0134": 'J',
          "\u0135": 'j',
          "\u0136": 'K',
          "\u0137": 'k',
          "\u0138": 'k',
          "\u0139": 'L',
          "\u013B": 'L',
          "\u013D": 'L',
          "\u013F": 'L',
          "\u0141": 'L',
          "\u013A": 'l',
          "\u013C": 'l',
          "\u013E": 'l',
          "\u0140": 'l',
          "\u0142": 'l',
          "\u0143": 'N',
          "\u0145": 'N',
          "\u0147": 'N',
          "\u014A": 'N',
          "\u0144": 'n',
          "\u0146": 'n',
          "\u0148": 'n',
          "\u014B": 'n',
          "\u014C": 'O',
          "\u014E": 'O',
          "\u0150": 'O',
          "\u014D": 'o',
          "\u014F": 'o',
          "\u0151": 'o',
          "\u0154": 'R',
          "\u0156": 'R',
          "\u0158": 'R',
          "\u0155": 'r',
          "\u0157": 'r',
          "\u0159": 'r',
          "\u015A": 'S',
          "\u015C": 'S',
          "\u015E": 'S',
          "\u0160": 'S',
          "\u015B": 's',
          "\u015D": 's',
          "\u015F": 's',
          "\u0161": 's',
          "\u0162": 'T',
          "\u0164": 'T',
          "\u0166": 'T',
          "\u0163": 't',
          "\u0165": 't',
          "\u0167": 't',
          "\u0168": 'U',
          "\u016A": 'U',
          "\u016C": 'U',
          "\u016E": 'U',
          "\u0170": 'U',
          "\u0172": 'U',
          "\u0169": 'u',
          "\u016B": 'u',
          "\u016D": 'u',
          "\u016F": 'u',
          "\u0171": 'u',
          "\u0173": 'u',
          "\u0174": 'W',
          "\u0175": 'w',
          "\u0176": 'Y',
          "\u0177": 'y',
          "\u0178": 'Y',
          "\u0179": 'Z',
          "\u017B": 'Z',
          "\u017D": 'Z',
          "\u017A": 'z',
          "\u017C": 'z',
          "\u017E": 'z',
          "\u0132": 'IJ',
          "\u0133": 'ij',
          "\u0152": 'Oe',
          "\u0153": 'oe',
          "\u0149": "'n",
          "\u017F": 's'
        };

        /** Used to map characters to HTML entities. */
        var htmlEscapes = {
          '&': '&amp;',
          '<': '&lt;',
          '>': '&gt;',
          '"': '&quot;',
          "'": '&#39;'
        };

        /** Used to map HTML entities to characters. */
        var htmlUnescapes = {
          '&amp;': '&',
          '&lt;': '<',
          '&gt;': '>',
          '&quot;': '"',
          '&#39;': "'"
        };

        /** Used to escape characters for inclusion in compiled string literals. */
        var stringEscapes = {
          '\\': '\\',
          "'": "'",
          '\n': 'n',
          '\r': 'r',
          "\u2028": 'u2028',
          "\u2029": 'u2029'
        };

        /** Built-in method references without a dependency on `root`. */
        var freeParseFloat = parseFloat,
          freeParseInt = parseInt;

        /** Detect free variable `global` from Node.js. */
        var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

        /** Detect free variable `self`. */
        var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

        /** Used as a reference to the global object. */
        var root = freeGlobal || freeSelf || Function('return this')();

        /** Detect free variable `exports`. */
        var freeExports = true && exports && !exports.nodeType && exports;

        /** Detect free variable `module`. */
        var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

        /** Detect the popular CommonJS extension `module.exports`. */
        var moduleExports = freeModule && freeModule.exports === freeExports;

        /** Detect free variable `process` from Node.js. */
        var freeProcess = moduleExports && freeGlobal.process;

        /** Used to access faster Node.js helpers. */
        var nodeUtil = function () {
          try {
            // Use `util.types` for Node.js 10+.
            var types = freeModule && freeModule.require && freeModule.require('util').types;
            if (types) {
              return types;
            }

            // Legacy `process.binding('util')` for Node.js < 10.
            return freeProcess && freeProcess.binding && freeProcess.binding('util');
          } catch (e) {}
        }();

        /* Node.js helper references. */
        var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
          nodeIsDate = nodeUtil && nodeUtil.isDate,
          nodeIsMap = nodeUtil && nodeUtil.isMap,
          nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
          nodeIsSet = nodeUtil && nodeUtil.isSet,
          nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

        /*--------------------------------------------------------------------------*/

        /**
         * A faster alternative to `Function#apply`, this function invokes `func`
         * with the `this` binding of `thisArg` and the arguments of `args`.
         *
         * @private
         * @param {Function} func The function to invoke.
         * @param {*} thisArg The `this` binding of `func`.
         * @param {Array} args The arguments to invoke `func` with.
         * @returns {*} Returns the result of `func`.
         */
        function apply(func, thisArg, args) {
          switch (args.length) {
            case 0:
              return func.call(thisArg);
            case 1:
              return func.call(thisArg, args[0]);
            case 2:
              return func.call(thisArg, args[0], args[1]);
            case 3:
              return func.call(thisArg, args[0], args[1], args[2]);
          }
          return func.apply(thisArg, args);
        }

        /**
         * A specialized version of `baseAggregator` for arrays.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} setter The function to set `accumulator` values.
         * @param {Function} iteratee The iteratee to transform keys.
         * @param {Object} accumulator The initial aggregated object.
         * @returns {Function} Returns `accumulator`.
         */
        function arrayAggregator(array, setter, iteratee, accumulator) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            var value = array[index];
            setter(accumulator, value, iteratee(value), array);
          }
          return accumulator;
        }

        /**
         * A specialized version of `_.forEach` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEach(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (iteratee(array[index], index, array) === false) {
              break;
            }
          }
          return array;
        }

        /**
         * A specialized version of `_.forEachRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns `array`.
         */
        function arrayEachRight(array, iteratee) {
          var length = array == null ? 0 : array.length;
          while (length--) {
            if (iteratee(array[length], length, array) === false) {
              break;
            }
          }
          return array;
        }

        /**
         * A specialized version of `_.every` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if all elements pass the predicate check,
         *  else `false`.
         */
        function arrayEvery(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (!predicate(array[index], index, array)) {
              return false;
            }
          }
          return true;
        }

        /**
         * A specialized version of `_.filter` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {Array} Returns the new filtered array.
         */
        function arrayFilter(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result[resIndex++] = value;
            }
          }
          return result;
        }

        /**
         * A specialized version of `_.includes` for arrays without support for
         * specifying an index to search from.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */
        function arrayIncludes(array, value) {
          var length = array == null ? 0 : array.length;
          return !!length && baseIndexOf(array, value, 0) > -1;
        }

        /**
         * This function is like `arrayIncludes` except that it accepts a comparator.
         *
         * @private
         * @param {Array} [array] The array to inspect.
         * @param {*} target The value to search for.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {boolean} Returns `true` if `target` is found, else `false`.
         */
        function arrayIncludesWith(array, value, comparator) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (comparator(value, array[index])) {
              return true;
            }
          }
          return false;
        }

        /**
         * A specialized version of `_.map` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the new mapped array.
         */
        function arrayMap(array, iteratee) {
          var index = -1,
            length = array == null ? 0 : array.length,
            result = Array(length);
          while (++index < length) {
            result[index] = iteratee(array[index], index, array);
          }
          return result;
        }

        /**
         * Appends the elements of `values` to `array`.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {Array} values The values to append.
         * @returns {Array} Returns `array`.
         */
        function arrayPush(array, values) {
          var index = -1,
            length = values.length,
            offset = array.length;
          while (++index < length) {
            array[offset + index] = values[index];
          }
          return array;
        }

        /**
         * A specialized version of `_.reduce` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the first element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduce(array, iteratee, accumulator, initAccum) {
          var index = -1,
            length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[++index];
          }
          while (++index < length) {
            accumulator = iteratee(accumulator, array[index], index, array);
          }
          return accumulator;
        }

        /**
         * A specialized version of `_.reduceRight` for arrays without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} [accumulator] The initial value.
         * @param {boolean} [initAccum] Specify using the last element of `array` as
         *  the initial value.
         * @returns {*} Returns the accumulated value.
         */
        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
          var length = array == null ? 0 : array.length;
          if (initAccum && length) {
            accumulator = array[--length];
          }
          while (length--) {
            accumulator = iteratee(accumulator, array[length], length, array);
          }
          return accumulator;
        }

        /**
         * A specialized version of `_.some` for arrays without support for iteratee
         * shorthands.
         *
         * @private
         * @param {Array} [array] The array to iterate over.
         * @param {Function} predicate The function invoked per iteration.
         * @returns {boolean} Returns `true` if any element passes the predicate check,
         *  else `false`.
         */
        function arraySome(array, predicate) {
          var index = -1,
            length = array == null ? 0 : array.length;
          while (++index < length) {
            if (predicate(array[index], index, array)) {
              return true;
            }
          }
          return false;
        }

        /**
         * Gets the size of an ASCII `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */
        var asciiSize = baseProperty('length');

        /**
         * Converts an ASCII `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function asciiToArray(string) {
          return string.split('');
        }

        /**
         * Splits an ASCII `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */
        function asciiWords(string) {
          return string.match(reAsciiWord) || [];
        }

        /**
         * The base implementation of methods like `_.findKey` and `_.findLastKey`,
         * without support for iteratee shorthands, which iterates over `collection`
         * using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the found element or its key, else `undefined`.
         */
        function baseFindKey(collection, predicate, eachFunc) {
          var result;
          eachFunc(collection, function (value, key, collection) {
            if (predicate(value, key, collection)) {
              result = key;
              return false;
            }
          });
          return result;
        }

        /**
         * The base implementation of `_.findIndex` and `_.findLastIndex` without
         * support for iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {Function} predicate The function invoked per iteration.
         * @param {number} fromIndex The index to search from.
         * @param {boolean} [fromRight] Specify iterating from right to left.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseFindIndex(array, predicate, fromIndex, fromRight) {
          var length = array.length,
            index = fromIndex + (fromRight ? 1 : -1);
          while (fromRight ? index-- : ++index < length) {
            if (predicate(array[index], index, array)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOf(array, value, fromIndex) {
          return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
        }

        /**
         * This function is like `baseIndexOf` except that it accepts a comparator.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @param {Function} comparator The comparator invoked per element.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function baseIndexOfWith(array, value, fromIndex, comparator) {
          var index = fromIndex - 1,
            length = array.length;
          while (++index < length) {
            if (comparator(array[index], value)) {
              return index;
            }
          }
          return -1;
        }

        /**
         * The base implementation of `_.isNaN` without support for number objects.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
         */
        function baseIsNaN(value) {
          return value !== value;
        }

        /**
         * The base implementation of `_.mean` and `_.meanBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the mean.
         */
        function baseMean(array, iteratee) {
          var length = array == null ? 0 : array.length;
          return length ? baseSum(array, iteratee) / length : NAN;
        }

        /**
         * The base implementation of `_.property` without support for deep paths.
         *
         * @private
         * @param {string} key The key of the property to get.
         * @returns {Function} Returns the new accessor function.
         */
        function baseProperty(key) {
          return function (object) {
            return object == null ? undefined : object[key];
          };
        }

        /**
         * The base implementation of `_.propertyOf` without support for deep paths.
         *
         * @private
         * @param {Object} object The object to query.
         * @returns {Function} Returns the new accessor function.
         */
        function basePropertyOf(object) {
          return function (key) {
            return object == null ? undefined : object[key];
          };
        }

        /**
         * The base implementation of `_.reduce` and `_.reduceRight`, without support
         * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
         *
         * @private
         * @param {Array|Object} collection The collection to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @param {*} accumulator The initial value.
         * @param {boolean} initAccum Specify using the first or last element of
         *  `collection` as the initial value.
         * @param {Function} eachFunc The function to iterate over `collection`.
         * @returns {*} Returns the accumulated value.
         */
        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
          eachFunc(collection, function (value, index, collection) {
            accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection);
          });
          return accumulator;
        }

        /**
         * The base implementation of `_.sortBy` which uses `comparer` to define the
         * sort order of `array` and replaces criteria objects with their corresponding
         * values.
         *
         * @private
         * @param {Array} array The array to sort.
         * @param {Function} comparer The function to define sort order.
         * @returns {Array} Returns `array`.
         */
        function baseSortBy(array, comparer) {
          var length = array.length;
          array.sort(comparer);
          while (length--) {
            array[length] = array[length].value;
          }
          return array;
        }

        /**
         * The base implementation of `_.sum` and `_.sumBy` without support for
         * iteratee shorthands.
         *
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {number} Returns the sum.
         */
        function baseSum(array, iteratee) {
          var result,
            index = -1,
            length = array.length;
          while (++index < length) {
            var current = iteratee(array[index]);
            if (current !== undefined) {
              result = result === undefined ? current : result + current;
            }
          }
          return result;
        }

        /**
         * The base implementation of `_.times` without support for iteratee shorthands
         * or max array length checks.
         *
         * @private
         * @param {number} n The number of times to invoke `iteratee`.
         * @param {Function} iteratee The function invoked per iteration.
         * @returns {Array} Returns the array of results.
         */
        function baseTimes(n, iteratee) {
          var index = -1,
            result = Array(n);
          while (++index < n) {
            result[index] = iteratee(index);
          }
          return result;
        }

        /**
         * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
         * of key-value pairs for `object` corresponding to the property names of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the key-value pairs.
         */
        function baseToPairs(object, props) {
          return arrayMap(props, function (key) {
            return [key, object[key]];
          });
        }

        /**
         * The base implementation of `_.trim`.
         *
         * @private
         * @param {string} string The string to trim.
         * @returns {string} Returns the trimmed string.
         */
        function baseTrim(string) {
          return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '') : string;
        }

        /**
         * The base implementation of `_.unary` without support for storing metadata.
         *
         * @private
         * @param {Function} func The function to cap arguments for.
         * @returns {Function} Returns the new capped function.
         */
        function baseUnary(func) {
          return function (value) {
            return func(value);
          };
        }

        /**
         * The base implementation of `_.values` and `_.valuesIn` which creates an
         * array of `object` property values corresponding to the property names
         * of `props`.
         *
         * @private
         * @param {Object} object The object to query.
         * @param {Array} props The property names to get values for.
         * @returns {Object} Returns the array of property values.
         */
        function baseValues(object, props) {
          return arrayMap(props, function (key) {
            return object[key];
          });
        }

        /**
         * Checks if a `cache` value for `key` exists.
         *
         * @private
         * @param {Object} cache The cache to query.
         * @param {string} key The key of the entry to check.
         * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
         */
        function cacheHas(cache, key) {
          return cache.has(key);
        }

        /**
         * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the first unmatched string symbol.
         */
        function charsStartIndex(strSymbols, chrSymbols) {
          var index = -1,
            length = strSymbols.length;
          while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
          return index;
        }

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
         * that is not found in the character symbols.
         *
         * @private
         * @param {Array} strSymbols The string symbols to inspect.
         * @param {Array} chrSymbols The character symbols to find.
         * @returns {number} Returns the index of the last unmatched string symbol.
         */
        function charsEndIndex(strSymbols, chrSymbols) {
          var index = strSymbols.length;
          while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
          return index;
        }

        /**
         * Gets the number of `placeholder` occurrences in `array`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} placeholder The placeholder to search for.
         * @returns {number} Returns the placeholder count.
         */
        function countHolders(array, placeholder) {
          var length = array.length,
            result = 0;
          while (length--) {
            if (array[length] === placeholder) {
              ++result;
            }
          }
          return result;
        }

        /**
         * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
         * letters to basic Latin letters.
         *
         * @private
         * @param {string} letter The matched letter to deburr.
         * @returns {string} Returns the deburred letter.
         */
        var deburrLetter = basePropertyOf(deburredLetters);

        /**
         * Used by `_.escape` to convert characters to HTML entities.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        var escapeHtmlChar = basePropertyOf(htmlEscapes);

        /**
         * Used by `_.template` to escape characters for inclusion in compiled string literals.
         *
         * @private
         * @param {string} chr The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
        function escapeStringChar(chr) {
          return '\\' + stringEscapes[chr];
        }

        /**
         * Gets the value at `key` of `object`.
         *
         * @private
         * @param {Object} [object] The object to query.
         * @param {string} key The key of the property to get.
         * @returns {*} Returns the property value.
         */
        function getValue(object, key) {
          return object == null ? undefined : object[key];
        }

        /**
         * Checks if `string` contains Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a symbol is found, else `false`.
         */
        function hasUnicode(string) {
          return reHasUnicode.test(string);
        }

        /**
         * Checks if `string` contains a word composed of Unicode symbols.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {boolean} Returns `true` if a word is found, else `false`.
         */
        function hasUnicodeWord(string) {
          return reHasUnicodeWord.test(string);
        }

        /**
         * Converts `iterator` to an array.
         *
         * @private
         * @param {Object} iterator The iterator to convert.
         * @returns {Array} Returns the converted array.
         */
        function iteratorToArray(iterator) {
          var data,
            result = [];
          while (!(data = iterator.next()).done) {
            result.push(data.value);
          }
          return result;
        }

        /**
         * Converts `map` to its key-value pairs.
         *
         * @private
         * @param {Object} map The map to convert.
         * @returns {Array} Returns the key-value pairs.
         */
        function mapToArray(map) {
          var index = -1,
            result = Array(map.size);
          map.forEach(function (value, key) {
            result[++index] = [key, value];
          });
          return result;
        }

        /**
         * Creates a unary function that invokes `func` with its argument transformed.
         *
         * @private
         * @param {Function} func The function to wrap.
         * @param {Function} transform The argument transform.
         * @returns {Function} Returns the new function.
         */
        function overArg(func, transform) {
          return function (arg) {
            return func(transform(arg));
          };
        }

        /**
         * Replaces all `placeholder` elements in `array` with an internal placeholder
         * and returns an array of their indexes.
         *
         * @private
         * @param {Array} array The array to modify.
         * @param {*} placeholder The placeholder to replace.
         * @returns {Array} Returns the new array of placeholder indexes.
         */
        function replaceHolders(array, placeholder) {
          var index = -1,
            length = array.length,
            resIndex = 0,
            result = [];
          while (++index < length) {
            var value = array[index];
            if (value === placeholder || value === PLACEHOLDER) {
              array[index] = PLACEHOLDER;
              result[resIndex++] = index;
            }
          }
          return result;
        }

        /**
         * Converts `set` to an array of its values.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the values.
         */
        function setToArray(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = value;
          });
          return result;
        }

        /**
         * Converts `set` to its value-value pairs.
         *
         * @private
         * @param {Object} set The set to convert.
         * @returns {Array} Returns the value-value pairs.
         */
        function setToPairs(set) {
          var index = -1,
            result = Array(set.size);
          set.forEach(function (value) {
            result[++index] = [value, value];
          });
          return result;
        }

        /**
         * A specialized version of `_.indexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function strictIndexOf(array, value, fromIndex) {
          var index = fromIndex - 1,
            length = array.length;
          while (++index < length) {
            if (array[index] === value) {
              return index;
            }
          }
          return -1;
        }

        /**
         * A specialized version of `_.lastIndexOf` which performs strict equality
         * comparisons of values, i.e. `===`.
         *
         * @private
         * @param {Array} array The array to inspect.
         * @param {*} value The value to search for.
         * @param {number} fromIndex The index to search from.
         * @returns {number} Returns the index of the matched value, else `-1`.
         */
        function strictLastIndexOf(array, value, fromIndex) {
          var index = fromIndex + 1;
          while (index--) {
            if (array[index] === value) {
              return index;
            }
          }
          return index;
        }

        /**
         * Gets the number of symbols in `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the string size.
         */
        function stringSize(string) {
          return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
        }

        /**
         * Converts `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function stringToArray(string) {
          return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
        }

        /**
         * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
         * character of `string`.
         *
         * @private
         * @param {string} string The string to inspect.
         * @returns {number} Returns the index of the last non-whitespace character.
         */
        function trimmedEndIndex(string) {
          var index = string.length;
          while (index-- && reWhitespace.test(string.charAt(index))) {}
          return index;
        }

        /**
         * Used by `_.unescape` to convert HTML entities to characters.
         *
         * @private
         * @param {string} chr The matched character to unescape.
         * @returns {string} Returns the unescaped character.
         */
        var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

        /**
         * Gets the size of a Unicode `string`.
         *
         * @private
         * @param {string} string The string inspect.
         * @returns {number} Returns the string size.
         */
        function unicodeSize(string) {
          var result = reUnicode.lastIndex = 0;
          while (reUnicode.test(string)) {
            ++result;
          }
          return result;
        }

        /**
         * Converts a Unicode `string` to an array.
         *
         * @private
         * @param {string} string The string to convert.
         * @returns {Array} Returns the converted array.
         */
        function unicodeToArray(string) {
          return string.match(reUnicode) || [];
        }

        /**
         * Splits a Unicode `string` into an array of its words.
         *
         * @private
         * @param {string} The string to inspect.
         * @returns {Array} Returns the words of `string`.
         */
        function unicodeWords(string) {
          return string.match(reUnicodeWord) || [];
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Create a new pristine `lodash` function using the `context` object.
         *
         * @static
         * @memberOf _
         * @since 1.1.0
         * @category Util
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns a new `lodash` function.
         * @example
         *
         * _.mixin({ 'foo': _.constant('foo') });
         *
         * var lodash = _.runInContext();
         * lodash.mixin({ 'bar': lodash.constant('bar') });
         *
         * _.isFunction(_.foo);
         * // => true
         * _.isFunction(_.bar);
         * // => false
         *
         * lodash.isFunction(lodash.foo);
         * // => false
         * lodash.isFunction(lodash.bar);
         * // => true
         *
         * // Create a suped-up `defer` in Node.js.
         * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
         */
        var runInContext = function runInContext(context) {
          context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

          /** Built-in constructor references. */
          var Array = context.Array,
            Date = context.Date,
            Error = context.Error,
            Function = context.Function,
            Math = context.Math,
            Object = context.Object,
            RegExp = context.RegExp,
            String = context.String,
            TypeError = context.TypeError;

          /** Used for built-in method references. */
          var arrayProto = Array.prototype,
            funcProto = Function.prototype,
            objectProto = Object.prototype;

          /** Used to detect overreaching core-js shims. */
          var coreJsData = context['__core-js_shared__'];

          /** Used to resolve the decompiled source of functions. */
          var funcToString = funcProto.toString;

          /** Used to check objects for own properties. */
          var hasOwnProperty = objectProto.hasOwnProperty;

          /** Used to generate unique IDs. */
          var idCounter = 0;

          /** Used to detect methods masquerading as native. */
          var maskSrcKey = function () {
            var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
            return uid ? 'Symbol(src)_1.' + uid : '';
          }();

          /**
           * Used to resolve the
           * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
           * of values.
           */
          var nativeObjectToString = objectProto.toString;

          /** Used to infer the `Object` constructor. */
          var objectCtorString = funcToString.call(Object);

          /** Used to restore the original `_` reference in `_.noConflict`. */
          var oldDash = root._;

          /** Used to detect if a method is native. */
          var reIsNative = RegExp('^' + funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$');

          /** Built-in value references. */
          var Buffer = moduleExports ? context.Buffer : undefined,
            Symbol = context.Symbol,
            Uint8Array = context.Uint8Array,
            allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
            getPrototype = overArg(Object.getPrototypeOf, Object),
            objectCreate = Object.create,
            propertyIsEnumerable = objectProto.propertyIsEnumerable,
            splice = arrayProto.splice,
            spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
            symIterator = Symbol ? Symbol.iterator : undefined,
            symToStringTag = Symbol ? Symbol.toStringTag : undefined;
          var defineProperty = function () {
            try {
              var func = getNative(Object, 'defineProperty');
              func({}, '', {});
              return func;
            } catch (e) {}
          }();

          /** Mocked built-ins. */
          var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
            ctxNow = Date && Date.now !== root.Date.now && Date.now,
            ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

          /* Built-in method references for those with the same name as other `lodash` methods. */
          var nativeCeil = Math.ceil,
            nativeFloor = Math.floor,
            nativeGetSymbols = Object.getOwnPropertySymbols,
            nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
            nativeIsFinite = context.isFinite,
            nativeJoin = arrayProto.join,
            nativeKeys = overArg(Object.keys, Object),
            nativeMax = Math.max,
            nativeMin = Math.min,
            nativeNow = Date.now,
            nativeParseInt = context.parseInt,
            nativeRandom = Math.random,
            nativeReverse = arrayProto.reverse;

          /* Built-in method references that are verified to be native. */
          var DataView = getNative(context, 'DataView'),
            Map = getNative(context, 'Map'),
            Promise = getNative(context, 'Promise'),
            Set = getNative(context, 'Set'),
            WeakMap = getNative(context, 'WeakMap'),
            nativeCreate = getNative(Object, 'create');

          /** Used to store function metadata. */
          var metaMap = WeakMap && new WeakMap();

          /** Used to lookup unminified function names. */
          var realNames = {};

          /** Used to detect maps, sets, and weakmaps. */
          var dataViewCtorString = toSource(DataView),
            mapCtorString = toSource(Map),
            promiseCtorString = toSource(Promise),
            setCtorString = toSource(Set),
            weakMapCtorString = toSource(WeakMap);

          /** Used to convert symbols to primitives and strings. */
          var symbolProto = Symbol ? Symbol.prototype : undefined,
            symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
            symbolToString = symbolProto ? symbolProto.toString : undefined;

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` object which wraps `value` to enable implicit method
           * chain sequences. Methods that operate on and return arrays, collections,
           * and functions can be chained together. Methods that retrieve a single value
           * or may return a primitive value will automatically end the chain sequence
           * and return the unwrapped value. Otherwise, the value must be unwrapped
           * with `_#value`.
           *
           * Explicit chain sequences, which must be unwrapped with `_#value`, may be
           * enabled using `_.chain`.
           *
           * The execution of chained methods is lazy, that is, it's deferred until
           * `_#value` is implicitly or explicitly called.
           *
           * Lazy evaluation allows several methods to support shortcut fusion.
           * Shortcut fusion is an optimization to merge iteratee calls; this avoids
           * the creation of intermediate arrays and can greatly reduce the number of
           * iteratee executions. Sections of a chain sequence qualify for shortcut
           * fusion if the section is applied to an array and iteratees accept only
           * one argument. The heuristic for whether a section qualifies for shortcut
           * fusion is subject to change.
           *
           * Chaining is supported in custom builds as long as the `_#value` method is
           * directly or indirectly included in the build.
           *
           * In addition to lodash methods, wrappers have `Array` and `String` methods.
           *
           * The wrapper `Array` methods are:
           * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
           *
           * The wrapper `String` methods are:
           * `replace` and `split`
           *
           * The wrapper methods that support shortcut fusion are:
           * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
           * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
           * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
           *
           * The chainable wrapper methods are:
           * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
           * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
           * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
           * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
           * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
           * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
           * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
           * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
           * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
           * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
           * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
           * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
           * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
           * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
           * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
           * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
           * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
           * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
           * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
           * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
           * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
           * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
           * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
           * `zipObject`, `zipObjectDeep`, and `zipWith`
           *
           * The wrapper methods that are **not** chainable by default are:
           * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
           * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
           * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
           * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
           * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
           * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
           * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
           * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
           * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
           * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
           * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
           * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
           * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
           * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
           * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
           * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
           * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
           * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
           * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
           * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
           * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
           * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
           * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
           * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
           * `upperFirst`, `value`, and `words`
           *
           * @name _
           * @constructor
           * @category Seq
           * @param {*} value The value to wrap in a `lodash` instance.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2, 3]);
           *
           * // Returns an unwrapped value.
           * wrapped.reduce(_.add);
           * // => 6
           *
           * // Returns a wrapped value.
           * var squares = wrapped.map(square);
           *
           * _.isArray(squares);
           * // => false
           *
           * _.isArray(squares.value());
           * // => true
           */
          function lodash(value) {
            if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
              if (value instanceof LodashWrapper) {
                return value;
              }
              if (hasOwnProperty.call(value, '__wrapped__')) {
                return wrapperClone(value);
              }
            }
            return new LodashWrapper(value);
          }

          /**
           * The base implementation of `_.create` without support for assigning
           * properties to the created object.
           *
           * @private
           * @param {Object} proto The object to inherit from.
           * @returns {Object} Returns the new object.
           */
          var baseCreate = function () {
            function object() {}
            return function (proto) {
              if (!isObject(proto)) {
                return {};
              }
              if (objectCreate) {
                return objectCreate(proto);
              }
              object.prototype = proto;
              var result = new object();
              object.prototype = undefined;
              return result;
            };
          }();

          /**
           * The function whose prototype chain sequence wrappers inherit from.
           *
           * @private
           */
          function baseLodash() {
            // No operation performed.
          }

          /**
           * The base constructor for creating `lodash` wrapper objects.
           *
           * @private
           * @param {*} value The value to wrap.
           * @param {boolean} [chainAll] Enable explicit method chain sequences.
           */
          function LodashWrapper(value, chainAll) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__chain__ = !!chainAll;
            this.__index__ = 0;
            this.__values__ = undefined;
          }

          /**
           * By default, the template delimiters used by lodash are like those in
           * embedded Ruby (ERB) as well as ES2015 template strings. Change the
           * following template settings to use alternative delimiters.
           *
           * @static
           * @memberOf _
           * @type {Object}
           */
          lodash.templateSettings = {
            /**
             * Used to detect `data` property values to be HTML-escaped.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'escape': reEscape,
            /**
             * Used to detect code to be evaluated.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'evaluate': reEvaluate,
            /**
             * Used to detect `data` property values to inject.
             *
             * @memberOf _.templateSettings
             * @type {RegExp}
             */
            'interpolate': reInterpolate,
            /**
             * Used to reference the data object in the template text.
             *
             * @memberOf _.templateSettings
             * @type {string}
             */
            'variable': '',
            /**
             * Used to import variables into the compiled template.
             *
             * @memberOf _.templateSettings
             * @type {Object}
             */
            'imports': {
              /**
               * A reference to the `lodash` function.
               *
               * @memberOf _.templateSettings.imports
               * @type {Function}
               */
              '_': lodash
            }
          };

          // Ensure wrappers are instances of `baseLodash`.
          lodash.prototype = baseLodash.prototype;
          lodash.prototype.constructor = lodash;
          LodashWrapper.prototype = baseCreate(baseLodash.prototype);
          LodashWrapper.prototype.constructor = LodashWrapper;

          /*------------------------------------------------------------------------*/

          /**
           * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
           *
           * @private
           * @constructor
           * @param {*} value The value to wrap.
           */
          function LazyWrapper(value) {
            this.__wrapped__ = value;
            this.__actions__ = [];
            this.__dir__ = 1;
            this.__filtered__ = false;
            this.__iteratees__ = [];
            this.__takeCount__ = MAX_ARRAY_LENGTH;
            this.__views__ = [];
          }

          /**
           * Creates a clone of the lazy wrapper object.
           *
           * @private
           * @name clone
           * @memberOf LazyWrapper
           * @returns {Object} Returns the cloned `LazyWrapper` object.
           */
          function lazyClone() {
            var result = new LazyWrapper(this.__wrapped__);
            result.__actions__ = copyArray(this.__actions__);
            result.__dir__ = this.__dir__;
            result.__filtered__ = this.__filtered__;
            result.__iteratees__ = copyArray(this.__iteratees__);
            result.__takeCount__ = this.__takeCount__;
            result.__views__ = copyArray(this.__views__);
            return result;
          }

          /**
           * Reverses the direction of lazy iteration.
           *
           * @private
           * @name reverse
           * @memberOf LazyWrapper
           * @returns {Object} Returns the new reversed `LazyWrapper` object.
           */
          function lazyReverse() {
            if (this.__filtered__) {
              var result = new LazyWrapper(this);
              result.__dir__ = -1;
              result.__filtered__ = true;
            } else {
              result = this.clone();
              result.__dir__ *= -1;
            }
            return result;
          }

          /**
           * Extracts the unwrapped value from its lazy wrapper.
           *
           * @private
           * @name value
           * @memberOf LazyWrapper
           * @returns {*} Returns the unwrapped value.
           */
          function lazyValue() {
            var array = this.__wrapped__.value(),
              dir = this.__dir__,
              isArr = isArray(array),
              isRight = dir < 0,
              arrLength = isArr ? array.length : 0,
              view = getView(0, arrLength, this.__views__),
              start = view.start,
              end = view.end,
              length = end - start,
              index = isRight ? end : start - 1,
              iteratees = this.__iteratees__,
              iterLength = iteratees.length,
              resIndex = 0,
              takeCount = nativeMin(length, this.__takeCount__);
            if (!isArr || !isRight && arrLength == length && takeCount == length) {
              return baseWrapperValue(array, this.__actions__);
            }
            var result = [];
            outer: while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1,
                value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex],
                  iteratee = data.iteratee,
                  type = data.type,
                  computed = iteratee(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result[resIndex++] = value;
            }
            return result;
          }

          // Ensure `LazyWrapper` is an instance of `baseLodash`.
          LazyWrapper.prototype = baseCreate(baseLodash.prototype);
          LazyWrapper.prototype.constructor = LazyWrapper;

          /*------------------------------------------------------------------------*/

          /**
           * Creates a hash object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Hash(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the hash.
           *
           * @private
           * @name clear
           * @memberOf Hash
           */
          function hashClear() {
            this.__data__ = nativeCreate ? nativeCreate(null) : {};
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the hash.
           *
           * @private
           * @name delete
           * @memberOf Hash
           * @param {Object} hash The hash to modify.
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function hashDelete(key) {
            var result = this.has(key) && delete this.__data__[key];
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the hash value for `key`.
           *
           * @private
           * @name get
           * @memberOf Hash
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function hashGet(key) {
            var data = this.__data__;
            if (nativeCreate) {
              var result = data[key];
              return result === HASH_UNDEFINED ? undefined : result;
            }
            return hasOwnProperty.call(data, key) ? data[key] : undefined;
          }

          /**
           * Checks if a hash value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Hash
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function hashHas(key) {
            var data = this.__data__;
            return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
          }

          /**
           * Sets the hash `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Hash
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the hash instance.
           */
          function hashSet(key, value) {
            var data = this.__data__;
            this.size += this.has(key) ? 0 : 1;
            data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value;
            return this;
          }

          // Add methods to `Hash`.
          Hash.prototype.clear = hashClear;
          Hash.prototype['delete'] = hashDelete;
          Hash.prototype.get = hashGet;
          Hash.prototype.has = hashHas;
          Hash.prototype.set = hashSet;

          /*------------------------------------------------------------------------*/

          /**
           * Creates an list cache object.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function ListCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the list cache.
           *
           * @private
           * @name clear
           * @memberOf ListCache
           */
          function listCacheClear() {
            this.__data__ = [];
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the list cache.
           *
           * @private
           * @name delete
           * @memberOf ListCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function listCacheDelete(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              return false;
            }
            var lastIndex = data.length - 1;
            if (index == lastIndex) {
              data.pop();
            } else {
              splice.call(data, index, 1);
            }
            --this.size;
            return true;
          }

          /**
           * Gets the list cache value for `key`.
           *
           * @private
           * @name get
           * @memberOf ListCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function listCacheGet(key) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            return index < 0 ? undefined : data[index][1];
          }

          /**
           * Checks if a list cache value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf ListCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function listCacheHas(key) {
            return assocIndexOf(this.__data__, key) > -1;
          }

          /**
           * Sets the list cache `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf ListCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the list cache instance.
           */
          function listCacheSet(key, value) {
            var data = this.__data__,
              index = assocIndexOf(data, key);
            if (index < 0) {
              ++this.size;
              data.push([key, value]);
            } else {
              data[index][1] = value;
            }
            return this;
          }

          // Add methods to `ListCache`.
          ListCache.prototype.clear = listCacheClear;
          ListCache.prototype['delete'] = listCacheDelete;
          ListCache.prototype.get = listCacheGet;
          ListCache.prototype.has = listCacheHas;
          ListCache.prototype.set = listCacheSet;

          /*------------------------------------------------------------------------*/

          /**
           * Creates a map cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function MapCache(entries) {
            var index = -1,
              length = entries == null ? 0 : entries.length;
            this.clear();
            while (++index < length) {
              var entry = entries[index];
              this.set(entry[0], entry[1]);
            }
          }

          /**
           * Removes all key-value entries from the map.
           *
           * @private
           * @name clear
           * @memberOf MapCache
           */
          function mapCacheClear() {
            this.size = 0;
            this.__data__ = {
              'hash': new Hash(),
              'map': new (Map || ListCache)(),
              'string': new Hash()
            };
          }

          /**
           * Removes `key` and its value from the map.
           *
           * @private
           * @name delete
           * @memberOf MapCache
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function mapCacheDelete(key) {
            var result = getMapData(this, key)['delete'](key);
            this.size -= result ? 1 : 0;
            return result;
          }

          /**
           * Gets the map value for `key`.
           *
           * @private
           * @name get
           * @memberOf MapCache
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function mapCacheGet(key) {
            return getMapData(this, key).get(key);
          }

          /**
           * Checks if a map value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf MapCache
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function mapCacheHas(key) {
            return getMapData(this, key).has(key);
          }

          /**
           * Sets the map `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf MapCache
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the map cache instance.
           */
          function mapCacheSet(key, value) {
            var data = getMapData(this, key),
              size = data.size;
            data.set(key, value);
            this.size += data.size == size ? 0 : 1;
            return this;
          }

          // Add methods to `MapCache`.
          MapCache.prototype.clear = mapCacheClear;
          MapCache.prototype['delete'] = mapCacheDelete;
          MapCache.prototype.get = mapCacheGet;
          MapCache.prototype.has = mapCacheHas;
          MapCache.prototype.set = mapCacheSet;

          /*------------------------------------------------------------------------*/

          /**
           *
           * Creates an array cache object to store unique values.
           *
           * @private
           * @constructor
           * @param {Array} [values] The values to cache.
           */
          function SetCache(values) {
            var index = -1,
              length = values == null ? 0 : values.length;
            this.__data__ = new MapCache();
            while (++index < length) {
              this.add(values[index]);
            }
          }

          /**
           * Adds `value` to the array cache.
           *
           * @private
           * @name add
           * @memberOf SetCache
           * @alias push
           * @param {*} value The value to cache.
           * @returns {Object} Returns the cache instance.
           */
          function setCacheAdd(value) {
            this.__data__.set(value, HASH_UNDEFINED);
            return this;
          }

          /**
           * Checks if `value` is in the array cache.
           *
           * @private
           * @name has
           * @memberOf SetCache
           * @param {*} value The value to search for.
           * @returns {number} Returns `true` if `value` is found, else `false`.
           */
          function setCacheHas(value) {
            return this.__data__.has(value);
          }

          // Add methods to `SetCache`.
          SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
          SetCache.prototype.has = setCacheHas;

          /*------------------------------------------------------------------------*/

          /**
           * Creates a stack cache object to store key-value pairs.
           *
           * @private
           * @constructor
           * @param {Array} [entries] The key-value pairs to cache.
           */
          function Stack(entries) {
            var data = this.__data__ = new ListCache(entries);
            this.size = data.size;
          }

          /**
           * Removes all key-value entries from the stack.
           *
           * @private
           * @name clear
           * @memberOf Stack
           */
          function stackClear() {
            this.__data__ = new ListCache();
            this.size = 0;
          }

          /**
           * Removes `key` and its value from the stack.
           *
           * @private
           * @name delete
           * @memberOf Stack
           * @param {string} key The key of the value to remove.
           * @returns {boolean} Returns `true` if the entry was removed, else `false`.
           */
          function stackDelete(key) {
            var data = this.__data__,
              result = data['delete'](key);
            this.size = data.size;
            return result;
          }

          /**
           * Gets the stack value for `key`.
           *
           * @private
           * @name get
           * @memberOf Stack
           * @param {string} key The key of the value to get.
           * @returns {*} Returns the entry value.
           */
          function stackGet(key) {
            return this.__data__.get(key);
          }

          /**
           * Checks if a stack value for `key` exists.
           *
           * @private
           * @name has
           * @memberOf Stack
           * @param {string} key The key of the entry to check.
           * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
           */
          function stackHas(key) {
            return this.__data__.has(key);
          }

          /**
           * Sets the stack `key` to `value`.
           *
           * @private
           * @name set
           * @memberOf Stack
           * @param {string} key The key of the value to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns the stack cache instance.
           */
          function stackSet(key, value) {
            var data = this.__data__;
            if (data instanceof ListCache) {
              var pairs = data.__data__;
              if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) {
                pairs.push([key, value]);
                this.size = ++data.size;
                return this;
              }
              data = this.__data__ = new MapCache(pairs);
            }
            data.set(key, value);
            this.size = data.size;
            return this;
          }

          // Add methods to `Stack`.
          Stack.prototype.clear = stackClear;
          Stack.prototype['delete'] = stackDelete;
          Stack.prototype.get = stackGet;
          Stack.prototype.has = stackHas;
          Stack.prototype.set = stackSet;

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of the enumerable property names of the array-like `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @param {boolean} inherited Specify returning inherited property names.
           * @returns {Array} Returns the array of property names.
           */
          function arrayLikeKeys(value, inherited) {
            var isArr = isArray(value),
              isArg = !isArr && isArguments(value),
              isBuff = !isArr && !isArg && isBuffer(value),
              isType = !isArr && !isArg && !isBuff && isTypedArray(value),
              skipIndexes = isArr || isArg || isBuff || isType,
              result = skipIndexes ? baseTimes(value.length, String) : [],
              length = result.length;
            for (var key in value) {
              if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (
              // Safari 9 has enumerable `arguments.length` in strict mode.
              key == 'length' ||
              // Node.js 0.10 has enumerable non-index properties on buffers.
              isBuff && (key == 'offset' || key == 'parent') ||
              // PhantomJS 2 has enumerable non-index properties on typed arrays.
              isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset') ||
              // Skip index properties.
              isIndex(key, length)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * A specialized version of `_.sample` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @returns {*} Returns the random element.
           */
          function arraySample(array) {
            var length = array.length;
            return length ? array[baseRandom(0, length - 1)] : undefined;
          }

          /**
           * A specialized version of `_.sampleSize` for arrays.
           *
           * @private
           * @param {Array} array The array to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */
          function arraySampleSize(array, n) {
            return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
          }

          /**
           * A specialized version of `_.shuffle` for arrays.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */
          function arrayShuffle(array) {
            return shuffleSelf(copyArray(array));
          }

          /**
           * This function is like `assignValue` except that it doesn't assign
           * `undefined` values.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignMergeValue(object, key, value) {
            if (value !== undefined && !eq(object[key], value) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Assigns `value` to `key` of `object` if the existing value is not equivalent
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function assignValue(object, key, value) {
            var objValue = object[key];
            if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
              baseAssignValue(object, key, value);
            }
          }

          /**
           * Gets the index at which the `key` is found in `array` of key-value pairs.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {*} key The key to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           */
          function assocIndexOf(array, key) {
            var length = array.length;
            while (length--) {
              if (eq(array[length][0], key)) {
                return length;
              }
            }
            return -1;
          }

          /**
           * Aggregates elements of `collection` on `accumulator` with keys transformed
           * by `iteratee` and values set by `setter`.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform keys.
           * @param {Object} accumulator The initial aggregated object.
           * @returns {Function} Returns `accumulator`.
           */
          function baseAggregator(collection, setter, iteratee, accumulator) {
            baseEach(collection, function (value, key, collection) {
              setter(accumulator, value, iteratee(value), collection);
            });
            return accumulator;
          }

          /**
           * The base implementation of `_.assign` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssign(object, source) {
            return object && copyObject(source, keys(source), object);
          }

          /**
           * The base implementation of `_.assignIn` without support for multiple sources
           * or `customizer` functions.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @returns {Object} Returns `object`.
           */
          function baseAssignIn(object, source) {
            return object && copyObject(source, keysIn(source), object);
          }

          /**
           * The base implementation of `assignValue` and `assignMergeValue` without
           * value checks.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {string} key The key of the property to assign.
           * @param {*} value The value to assign.
           */
          function baseAssignValue(object, key, value) {
            if (key == '__proto__' && defineProperty) {
              defineProperty(object, key, {
                'configurable': true,
                'enumerable': true,
                'value': value,
                'writable': true
              });
            } else {
              object[key] = value;
            }
          }

          /**
           * The base implementation of `_.at` without support for individual paths.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {string[]} paths The property paths to pick.
           * @returns {Array} Returns the picked elements.
           */
          function baseAt(object, paths) {
            var index = -1,
              length = paths.length,
              result = Array(length),
              skip = object == null;
            while (++index < length) {
              result[index] = skip ? undefined : get(object, paths[index]);
            }
            return result;
          }

          /**
           * The base implementation of `_.clamp` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           */
          function baseClamp(number, lower, upper) {
            if (number === number) {
              if (upper !== undefined) {
                number = number <= upper ? number : upper;
              }
              if (lower !== undefined) {
                number = number >= lower ? number : lower;
              }
            }
            return number;
          }

          /**
           * The base implementation of `_.clone` and `_.cloneDeep` which tracks
           * traversed objects.
           *
           * @private
           * @param {*} value The value to clone.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Deep clone
           *  2 - Flatten inherited properties
           *  4 - Clone symbols
           * @param {Function} [customizer] The function to customize cloning.
           * @param {string} [key] The key of `value`.
           * @param {Object} [object] The parent object of `value`.
           * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
           * @returns {*} Returns the cloned value.
           */
          function baseClone(value, bitmask, customizer, key, object, stack) {
            var result,
              isDeep = bitmask & CLONE_DEEP_FLAG,
              isFlat = bitmask & CLONE_FLAT_FLAG,
              isFull = bitmask & CLONE_SYMBOLS_FLAG;
            if (customizer) {
              result = object ? customizer(value, key, object, stack) : customizer(value);
            }
            if (result !== undefined) {
              return result;
            }
            if (!isObject(value)) {
              return value;
            }
            var isArr = isArray(value);
            if (isArr) {
              result = initCloneArray(value);
              if (!isDeep) {
                return copyArray(value, result);
              }
            } else {
              var tag = getTag(value),
                isFunc = tag == funcTag || tag == genTag;
              if (isBuffer(value)) {
                return cloneBuffer(value, isDeep);
              }
              if (tag == objectTag || tag == argsTag || isFunc && !object) {
                result = isFlat || isFunc ? {} : initCloneObject(value);
                if (!isDeep) {
                  return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value));
                }
              } else {
                if (!cloneableTags[tag]) {
                  return object ? value : {};
                }
                result = initCloneByTag(value, tag, isDeep);
              }
            }
            // Check for circular references and return its corresponding clone.
            stack || (stack = new Stack());
            var stacked = stack.get(value);
            if (stacked) {
              return stacked;
            }
            stack.set(value, result);
            if (isSet(value)) {
              value.forEach(function (subValue) {
                result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
              });
            } else if (isMap(value)) {
              value.forEach(function (subValue, key) {
                result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
              });
            }
            var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
            var props = isArr ? undefined : keysFunc(value);
            arrayEach(props || value, function (subValue, key) {
              if (props) {
                key = subValue;
                subValue = value[key];
              }
              // Recursively populate clone (susceptible to call stack limits).
              assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
            });
            return result;
          }

          /**
           * The base implementation of `_.conforms` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           */
          function baseConforms(source) {
            var props = keys(source);
            return function (object) {
              return baseConformsTo(object, source, props);
            };
          }

          /**
           * The base implementation of `_.conformsTo` which accepts `props` to check.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           */
          function baseConformsTo(object, source, props) {
            var length = props.length;
            if (object == null) {
              return !length;
            }
            object = Object(object);
            while (length--) {
              var key = props[length],
                predicate = source[key],
                value = object[key];
              if (value === undefined && !(key in object) || !predicate(value)) {
                return false;
              }
            }
            return true;
          }

          /**
           * The base implementation of `_.delay` and `_.defer` which accepts `args`
           * to provide to `func`.
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {Array} args The arguments to provide to `func`.
           * @returns {number|Object} Returns the timer id or timeout object.
           */
          function baseDelay(func, wait, args) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return setTimeout(function () {
              func.apply(undefined, args);
            }, wait);
          }

          /**
           * The base implementation of methods like `_.difference` without support
           * for excluding multiple arrays or iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Array} values The values to exclude.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           */
          function baseDifference(array, values, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              isCommon = true,
              length = array.length,
              result = [],
              valuesLength = values.length;
            if (!length) {
              return result;
            }
            if (iteratee) {
              values = arrayMap(values, baseUnary(iteratee));
            }
            if (comparator) {
              includes = arrayIncludesWith;
              isCommon = false;
            } else if (values.length >= LARGE_ARRAY_SIZE) {
              includes = cacheHas;
              isCommon = false;
              values = new SetCache(values);
            }
            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee == null ? value : iteratee(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result.push(value);
              } else if (!includes(values, computed, comparator)) {
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.forEach` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */
          var baseEach = createBaseEach(baseForOwn);

          /**
           * The base implementation of `_.forEachRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           */
          var baseEachRight = createBaseEach(baseForOwnRight, true);

          /**
           * The base implementation of `_.every` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`
           */
          function baseEvery(collection, predicate) {
            var result = true;
            baseEach(collection, function (value, index, collection) {
              result = !!predicate(value, index, collection);
              return result;
            });
            return result;
          }

          /**
           * The base implementation of methods like `_.max` and `_.min` which accepts a
           * `comparator` to determine the extremum value.
           *
           * @private
           * @param {Array} array The array to iterate over.
           * @param {Function} iteratee The iteratee invoked per iteration.
           * @param {Function} comparator The comparator used to compare values.
           * @returns {*} Returns the extremum value.
           */
          function baseExtremum(array, iteratee, comparator) {
            var index = -1,
              length = array.length;
            while (++index < length) {
              var value = array[index],
                current = iteratee(value);
              if (current != null && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) {
                var computed = current,
                  result = value;
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.fill` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           */
          function baseFill(array, value, start, end) {
            var length = array.length;
            start = toInteger(start);
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end === undefined || end > length ? length : toInteger(end);
            if (end < 0) {
              end += length;
            }
            end = start > end ? 0 : toLength(end);
            while (start < end) {
              array[start++] = value;
            }
            return array;
          }

          /**
           * The base implementation of `_.filter` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           */
          function baseFilter(collection, predicate) {
            var result = [];
            baseEach(collection, function (value, index, collection) {
              if (predicate(value, index, collection)) {
                result.push(value);
              }
            });
            return result;
          }

          /**
           * The base implementation of `_.flatten` with support for restricting flattening.
           *
           * @private
           * @param {Array} array The array to flatten.
           * @param {number} depth The maximum recursion depth.
           * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
           * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
           * @param {Array} [result=[]] The initial result value.
           * @returns {Array} Returns the new flattened array.
           */
          function baseFlatten(array, depth, predicate, isStrict, result) {
            var index = -1,
              length = array.length;
            predicate || (predicate = isFlattenable);
            result || (result = []);
            while (++index < length) {
              var value = array[index];
              if (depth > 0 && predicate(value)) {
                if (depth > 1) {
                  // Recursively flatten arrays (susceptible to call stack limits).
                  baseFlatten(value, depth - 1, predicate, isStrict, result);
                } else {
                  arrayPush(result, value);
                }
              } else if (!isStrict) {
                result[result.length] = value;
              }
            }
            return result;
          }

          /**
           * The base implementation of `baseForOwn` which iterates over `object`
           * properties returned by `keysFunc` and invokes `iteratee` for each property.
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseFor = createBaseFor();

          /**
           * This function is like `baseFor` except that it iterates over properties
           * in the opposite order.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @returns {Object} Returns `object`.
           */
          var baseForRight = createBaseFor(true);

          /**
           * The base implementation of `_.forOwn` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwn(object, iteratee) {
            return object && baseFor(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Object} Returns `object`.
           */
          function baseForOwnRight(object, iteratee) {
            return object && baseForRight(object, iteratee, keys);
          }

          /**
           * The base implementation of `_.functions` which creates an array of
           * `object` function property names filtered from `props`.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Array} props The property names to filter.
           * @returns {Array} Returns the function names.
           */
          function baseFunctions(object, props) {
            return arrayFilter(props, function (key) {
              return isFunction(object[key]);
            });
          }

          /**
           * The base implementation of `_.get` without support for default values.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @returns {*} Returns the resolved value.
           */
          function baseGet(object, path) {
            path = castPath(path, object);
            var index = 0,
              length = path.length;
            while (object != null && index < length) {
              object = object[toKey(path[index++])];
            }
            return index && index == length ? object : undefined;
          }

          /**
           * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
           * `keysFunc` and `symbolsFunc` to get the enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Function} keysFunc The function to get the keys of `object`.
           * @param {Function} symbolsFunc The function to get the symbols of `object`.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function baseGetAllKeys(object, keysFunc, symbolsFunc) {
            var result = keysFunc(object);
            return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
          }

          /**
           * The base implementation of `getTag` without fallbacks for buggy environments.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          function baseGetTag(value) {
            if (value == null) {
              return value === undefined ? undefinedTag : nullTag;
            }
            return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
          }

          /**
           * The base implementation of `_.gt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           */
          function baseGt(value, other) {
            return value > other;
          }

          /**
           * The base implementation of `_.has` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */
          function baseHas(object, key) {
            return object != null && hasOwnProperty.call(object, key);
          }

          /**
           * The base implementation of `_.hasIn` without support for deep paths.
           *
           * @private
           * @param {Object} [object] The object to query.
           * @param {Array|string} key The key to check.
           * @returns {boolean} Returns `true` if `key` exists, else `false`.
           */
          function baseHasIn(object, key) {
            return object != null && key in Object(object);
          }

          /**
           * The base implementation of `_.inRange` which doesn't coerce arguments.
           *
           * @private
           * @param {number} number The number to check.
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           */
          function baseInRange(number, start, end) {
            return number >= nativeMin(start, end) && number < nativeMax(start, end);
          }

          /**
           * The base implementation of methods like `_.intersection`, without support
           * for iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of shared values.
           */
          function baseIntersection(arrays, iteratee, comparator) {
            var includes = comparator ? arrayIncludesWith : arrayIncludes,
              length = arrays[0].length,
              othLength = arrays.length,
              othIndex = othLength,
              caches = Array(othLength),
              maxLength = Infinity,
              result = [];
            while (othIndex--) {
              var array = arrays[othIndex];
              if (othIndex && iteratee) {
                array = arrayMap(array, baseUnary(iteratee));
              }
              maxLength = nativeMin(array.length, maxLength);
              caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined;
            }
            array = arrays[0];
            var index = -1,
              seen = caches[0];
            outer: while (++index < length && result.length < maxLength) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.invert` and `_.invertBy` which inverts
           * `object` with values transformed by `iteratee` and set by `setter`.
           *
           * @private
           * @param {Object} object The object to iterate over.
           * @param {Function} setter The function to set `accumulator` values.
           * @param {Function} iteratee The iteratee to transform values.
           * @param {Object} accumulator The initial inverted object.
           * @returns {Function} Returns `accumulator`.
           */
          function baseInverter(object, setter, iteratee, accumulator) {
            baseForOwn(object, function (value, key, object) {
              setter(accumulator, iteratee(value), key, object);
            });
            return accumulator;
          }

          /**
           * The base implementation of `_.invoke` without support for individual
           * method arguments.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {Array} args The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           */
          function baseInvoke(object, path, args) {
            path = castPath(path, object);
            object = parent(object, path);
            var func = object == null ? object : object[toKey(last(path))];
            return func == null ? undefined : apply(func, object, args);
          }

          /**
           * The base implementation of `_.isArguments`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           */
          function baseIsArguments(value) {
            return isObjectLike(value) && baseGetTag(value) == argsTag;
          }

          /**
           * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           */
          function baseIsArrayBuffer(value) {
            return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
          }

          /**
           * The base implementation of `_.isDate` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           */
          function baseIsDate(value) {
            return isObjectLike(value) && baseGetTag(value) == dateTag;
          }

          /**
           * The base implementation of `_.isEqual` which supports partial comparisons
           * and tracks traversed objects.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {boolean} bitmask The bitmask flags.
           *  1 - Unordered comparison
           *  2 - Partial comparison
           * @param {Function} [customizer] The function to customize comparisons.
           * @param {Object} [stack] Tracks traversed `value` and `other` objects.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           */
          function baseIsEqual(value, other, bitmask, customizer, stack) {
            if (value === other) {
              return true;
            }
            if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
              return value !== value && other !== other;
            }
            return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
          }

          /**
           * A specialized version of `baseIsEqual` for arrays and objects which performs
           * deep comparisons and tracks traversed objects enabling objects with circular
           * references to be compared.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} [stack] Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
            var objIsArr = isArray(object),
              othIsArr = isArray(other),
              objTag = objIsArr ? arrayTag : getTag(object),
              othTag = othIsArr ? arrayTag : getTag(other);
            objTag = objTag == argsTag ? objectTag : objTag;
            othTag = othTag == argsTag ? objectTag : othTag;
            var objIsObj = objTag == objectTag,
              othIsObj = othTag == objectTag,
              isSameTag = objTag == othTag;
            if (isSameTag && isBuffer(object)) {
              if (!isBuffer(other)) {
                return false;
              }
              objIsArr = true;
              objIsObj = false;
            }
            if (isSameTag && !objIsObj) {
              stack || (stack = new Stack());
              return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
            }
            if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
              var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
                othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');
              if (objIsWrapped || othIsWrapped) {
                var objUnwrapped = objIsWrapped ? object.value() : object,
                  othUnwrapped = othIsWrapped ? other.value() : other;
                stack || (stack = new Stack());
                return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
              }
            }
            if (!isSameTag) {
              return false;
            }
            stack || (stack = new Stack());
            return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
          }

          /**
           * The base implementation of `_.isMap` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           */
          function baseIsMap(value) {
            return isObjectLike(value) && getTag(value) == mapTag;
          }

          /**
           * The base implementation of `_.isMatch` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Array} matchData The property names, values, and compare flags to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           */
          function baseIsMatch(object, source, matchData, customizer) {
            var index = matchData.length,
              length = index,
              noCustomizer = !customizer;
            if (object == null) {
              return !length;
            }
            object = Object(object);
            while (index--) {
              var data = matchData[index];
              if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
                return false;
              }
            }
            while (++index < length) {
              data = matchData[index];
              var key = data[0],
                objValue = object[key],
                srcValue = data[1];
              if (noCustomizer && data[2]) {
                if (objValue === undefined && !(key in object)) {
                  return false;
                }
              } else {
                var stack = new Stack();
                if (customizer) {
                  var result = customizer(objValue, srcValue, key, object, source, stack);
                }
                if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) {
                  return false;
                }
              }
            }
            return true;
          }

          /**
           * The base implementation of `_.isNative` without bad shim checks.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           */
          function baseIsNative(value) {
            if (!isObject(value) || isMasked(value)) {
              return false;
            }
            var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
            return pattern.test(toSource(value));
          }

          /**
           * The base implementation of `_.isRegExp` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           */
          function baseIsRegExp(value) {
            return isObjectLike(value) && baseGetTag(value) == regexpTag;
          }

          /**
           * The base implementation of `_.isSet` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           */
          function baseIsSet(value) {
            return isObjectLike(value) && getTag(value) == setTag;
          }

          /**
           * The base implementation of `_.isTypedArray` without Node.js optimizations.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           */
          function baseIsTypedArray(value) {
            return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
          }

          /**
           * The base implementation of `_.iteratee`.
           *
           * @private
           * @param {*} [value=_.identity] The value to convert to an iteratee.
           * @returns {Function} Returns the iteratee.
           */
          function baseIteratee(value) {
            // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
            // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
            if (typeof value == 'function') {
              return value;
            }
            if (value == null) {
              return identity;
            }
            if (typeof value == 'object') {
              return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
            }
            return property(value);
          }

          /**
           * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeys(object) {
            if (!isPrototype(object)) {
              return nativeKeys(object);
            }
            var result = [];
            for (var key in Object(object)) {
              if (hasOwnProperty.call(object, key) && key != 'constructor') {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function baseKeysIn(object) {
            if (!isObject(object)) {
              return nativeKeysIn(object);
            }
            var isProto = isPrototype(object),
              result = [];
            for (var key in object) {
              if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.lt` which doesn't coerce arguments.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           */
          function baseLt(value, other) {
            return value < other;
          }

          /**
           * The base implementation of `_.map` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} iteratee The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           */
          function baseMap(collection, iteratee) {
            var index = -1,
              result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value, key, collection) {
              result[++index] = iteratee(value, key, collection);
            });
            return result;
          }

          /**
           * The base implementation of `_.matches` which doesn't clone `source`.
           *
           * @private
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           */
          function baseMatches(source) {
            var matchData = getMatchData(source);
            if (matchData.length == 1 && matchData[0][2]) {
              return matchesStrictComparable(matchData[0][0], matchData[0][1]);
            }
            return function (object) {
              return object === source || baseIsMatch(object, source, matchData);
            };
          }

          /**
           * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
           *
           * @private
           * @param {string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */
          function baseMatchesProperty(path, srcValue) {
            if (isKey(path) && isStrictComparable(srcValue)) {
              return matchesStrictComparable(toKey(path), srcValue);
            }
            return function (object) {
              var objValue = get(object, path);
              return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
            };
          }

          /**
           * The base implementation of `_.merge` without support for multiple sources.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} [customizer] The function to customize merged values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMerge(object, source, srcIndex, customizer, stack) {
            if (object === source) {
              return;
            }
            baseFor(source, function (srcValue, key) {
              stack || (stack = new Stack());
              if (isObject(srcValue)) {
                baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
              } else {
                var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + '', object, source, stack) : undefined;
                if (newValue === undefined) {
                  newValue = srcValue;
                }
                assignMergeValue(object, key, newValue);
              }
            }, keysIn);
          }

          /**
           * A specialized version of `baseMerge` for arrays and objects which performs
           * deep merges and tracks traversed objects enabling objects with circular
           * references to be merged.
           *
           * @private
           * @param {Object} object The destination object.
           * @param {Object} source The source object.
           * @param {string} key The key of the value to merge.
           * @param {number} srcIndex The index of `source`.
           * @param {Function} mergeFunc The function to merge values.
           * @param {Function} [customizer] The function to customize assigned values.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           */
          function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
            var objValue = safeGet(object, key),
              srcValue = safeGet(source, key),
              stacked = stack.get(srcValue);
            if (stacked) {
              assignMergeValue(object, key, stacked);
              return;
            }
            var newValue = customizer ? customizer(objValue, srcValue, key + '', object, source, stack) : undefined;
            var isCommon = newValue === undefined;
            if (isCommon) {
              var isArr = isArray(srcValue),
                isBuff = !isArr && isBuffer(srcValue),
                isTyped = !isArr && !isBuff && isTypedArray(srcValue);
              newValue = srcValue;
              if (isArr || isBuff || isTyped) {
                if (isArray(objValue)) {
                  newValue = objValue;
                } else if (isArrayLikeObject(objValue)) {
                  newValue = copyArray(objValue);
                } else if (isBuff) {
                  isCommon = false;
                  newValue = cloneBuffer(srcValue, true);
                } else if (isTyped) {
                  isCommon = false;
                  newValue = cloneTypedArray(srcValue, true);
                } else {
                  newValue = [];
                }
              } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
                newValue = objValue;
                if (isArguments(objValue)) {
                  newValue = toPlainObject(objValue);
                } else if (!isObject(objValue) || isFunction(objValue)) {
                  newValue = initCloneObject(srcValue);
                }
              } else {
                isCommon = false;
              }
            }
            if (isCommon) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, newValue);
              mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
              stack['delete'](srcValue);
            }
            assignMergeValue(object, key, newValue);
          }

          /**
           * The base implementation of `_.nth` which doesn't coerce arguments.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {number} n The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           */
          function baseNth(array, n) {
            var length = array.length;
            if (!length) {
              return;
            }
            n += n < 0 ? length : 0;
            return isIndex(n, length) ? array[n] : undefined;
          }

          /**
           * The base implementation of `_.orderBy` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
           * @param {string[]} orders The sort orders of `iteratees`.
           * @returns {Array} Returns the new sorted array.
           */
          function baseOrderBy(collection, iteratees, orders) {
            if (iteratees.length) {
              iteratees = arrayMap(iteratees, function (iteratee) {
                if (isArray(iteratee)) {
                  return function (value) {
                    return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
                  };
                }
                return iteratee;
              });
            } else {
              iteratees = [identity];
            }
            var index = -1;
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            var result = baseMap(collection, function (value, key, collection) {
              var criteria = arrayMap(iteratees, function (iteratee) {
                return iteratee(value);
              });
              return {
                'criteria': criteria,
                'index': ++index,
                'value': value
              };
            });
            return baseSortBy(result, function (object, other) {
              return compareMultiple(object, other, orders);
            });
          }

          /**
           * The base implementation of `_.pick` without support for individual
           * property identifiers.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @returns {Object} Returns the new object.
           */
          function basePick(object, paths) {
            return basePickBy(object, paths, function (value, path) {
              return hasIn(object, path);
            });
          }

          /**
           * The base implementation of  `_.pickBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Object} object The source object.
           * @param {string[]} paths The property paths to pick.
           * @param {Function} predicate The function invoked per property.
           * @returns {Object} Returns the new object.
           */
          function basePickBy(object, paths, predicate) {
            var index = -1,
              length = paths.length,
              result = {};
            while (++index < length) {
              var path = paths[index],
                value = baseGet(object, path);
              if (predicate(value, path)) {
                baseSet(result, castPath(path, object), value);
              }
            }
            return result;
          }

          /**
           * A specialized version of `baseProperty` which supports deep paths.
           *
           * @private
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           */
          function basePropertyDeep(path) {
            return function (object) {
              return baseGet(object, path);
            };
          }

          /**
           * The base implementation of `_.pullAllBy` without support for iteratee
           * shorthands.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           */
          function basePullAll(array, values, iteratee, comparator) {
            var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
              index = -1,
              length = values.length,
              seen = array;
            if (array === values) {
              values = copyArray(values);
            }
            if (iteratee) {
              seen = arrayMap(array, baseUnary(iteratee));
            }
            while (++index < length) {
              var fromIndex = 0,
                value = values[index],
                computed = iteratee ? iteratee(value) : value;
              while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
                if (seen !== array) {
                  splice.call(seen, fromIndex, 1);
                }
                splice.call(array, fromIndex, 1);
              }
            }
            return array;
          }

          /**
           * The base implementation of `_.pullAt` without support for individual
           * indexes or capturing the removed elements.
           *
           * @private
           * @param {Array} array The array to modify.
           * @param {number[]} indexes The indexes of elements to remove.
           * @returns {Array} Returns `array`.
           */
          function basePullAt(array, indexes) {
            var length = array ? indexes.length : 0,
              lastIndex = length - 1;
            while (length--) {
              var index = indexes[length];
              if (length == lastIndex || index !== previous) {
                var previous = index;
                if (isIndex(index)) {
                  splice.call(array, index, 1);
                } else {
                  baseUnset(array, index);
                }
              }
            }
            return array;
          }

          /**
           * The base implementation of `_.random` without support for returning
           * floating-point numbers.
           *
           * @private
           * @param {number} lower The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the random number.
           */
          function baseRandom(lower, upper) {
            return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
          }

          /**
           * The base implementation of `_.range` and `_.rangeRight` which doesn't
           * coerce arguments.
           *
           * @private
           * @param {number} start The start of the range.
           * @param {number} end The end of the range.
           * @param {number} step The value to increment or decrement by.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the range of numbers.
           */
          function baseRange(start, end, step, fromRight) {
            var index = -1,
              length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
              result = Array(length);
            while (length--) {
              result[fromRight ? length : ++index] = start;
              start += step;
            }
            return result;
          }

          /**
           * The base implementation of `_.repeat` which doesn't coerce arguments.
           *
           * @private
           * @param {string} string The string to repeat.
           * @param {number} n The number of times to repeat the string.
           * @returns {string} Returns the repeated string.
           */
          function baseRepeat(string, n) {
            var result = '';
            if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
              return result;
            }
            // Leverage the exponentiation by squaring algorithm for a faster repeat.
            // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
            do {
              if (n % 2) {
                result += string;
              }
              n = nativeFloor(n / 2);
              if (n) {
                string += string;
              }
            } while (n);
            return result;
          }

          /**
           * The base implementation of `_.rest` which doesn't validate or coerce arguments.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           */
          function baseRest(func, start) {
            return setToString(overRest(func, start, identity), func + '');
          }

          /**
           * The base implementation of `_.sample`.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           */
          function baseSample(collection) {
            return arraySample(values(collection));
          }

          /**
           * The base implementation of `_.sampleSize` without param guards.
           *
           * @private
           * @param {Array|Object} collection The collection to sample.
           * @param {number} n The number of elements to sample.
           * @returns {Array} Returns the random elements.
           */
          function baseSampleSize(collection, n) {
            var array = values(collection);
            return shuffleSelf(array, baseClamp(n, 0, array.length));
          }

          /**
           * The base implementation of `_.set`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */
          function baseSet(object, path, value, customizer) {
            if (!isObject(object)) {
              return object;
            }
            path = castPath(path, object);
            var index = -1,
              length = path.length,
              lastIndex = length - 1,
              nested = object;
            while (nested != null && ++index < length) {
              var key = toKey(path[index]),
                newValue = value;
              if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
                return object;
              }
              if (index != lastIndex) {
                var objValue = nested[key];
                newValue = customizer ? customizer(objValue, key, nested) : undefined;
                if (newValue === undefined) {
                  newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
                }
              }
              assignValue(nested, key, newValue);
              nested = nested[key];
            }
            return object;
          }

          /**
           * The base implementation of `setData` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var baseSetData = !metaMap ? identity : function (func, data) {
            metaMap.set(func, data);
            return func;
          };

          /**
           * The base implementation of `setToString` without support for hot loop shorting.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var baseSetToString = !defineProperty ? identity : function (func, string) {
            return defineProperty(func, 'toString', {
              'configurable': true,
              'enumerable': false,
              'value': constant(string),
              'writable': true
            });
          };

          /**
           * The base implementation of `_.shuffle`.
           *
           * @private
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           */
          function baseShuffle(collection) {
            return shuffleSelf(values(collection));
          }

          /**
           * The base implementation of `_.slice` without an iteratee call guard.
           *
           * @private
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseSlice(array, start, end) {
            var index = -1,
              length = array.length;
            if (start < 0) {
              start = -start > length ? 0 : length + start;
            }
            end = end > length ? length : end;
            if (end < 0) {
              end += length;
            }
            length = start > end ? 0 : end - start >>> 0;
            start >>>= 0;
            var result = Array(length);
            while (++index < length) {
              result[index] = array[index + start];
            }
            return result;
          }

          /**
           * The base implementation of `_.some` without support for iteratee shorthands.
           *
           * @private
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} predicate The function invoked per iteration.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           */
          function baseSome(collection, predicate) {
            var result;
            baseEach(collection, function (value, index, collection) {
              result = predicate(value, index, collection);
              return !result;
            });
            return !!result;
          }

          /**
           * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
           * performs a binary search of `array` to determine the index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function baseSortedIndex(array, value, retHighest) {
            var low = 0,
              high = array == null ? low : array.length;
            if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
              while (low < high) {
                var mid = low + high >>> 1,
                  computed = array[mid];
                if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                  low = mid + 1;
                } else {
                  high = mid;
                }
              }
              return high;
            }
            return baseSortedIndexBy(array, value, identity, retHighest);
          }

          /**
           * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
           * which invokes `iteratee` for `value` and each element of `array` to compute
           * their sort ranking. The iteratee is invoked with one argument; (value).
           *
           * @private
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} iteratee The iteratee invoked per element.
           * @param {boolean} [retHighest] Specify returning the highest qualified index.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           */
          function baseSortedIndexBy(array, value, iteratee, retHighest) {
            var low = 0,
              high = array == null ? 0 : array.length;
            if (high === 0) {
              return 0;
            }
            value = iteratee(value);
            var valIsNaN = value !== value,
              valIsNull = value === null,
              valIsSymbol = isSymbol(value),
              valIsUndefined = value === undefined;
            while (low < high) {
              var mid = nativeFloor((low + high) / 2),
                computed = iteratee(array[mid]),
                othIsDefined = computed !== undefined,
                othIsNull = computed === null,
                othIsReflexive = computed === computed,
                othIsSymbol = isSymbol(computed);
              if (valIsNaN) {
                var setLow = retHighest || othIsReflexive;
              } else if (valIsUndefined) {
                setLow = othIsReflexive && (retHighest || othIsDefined);
              } else if (valIsNull) {
                setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
              } else if (valIsSymbol) {
                setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
              } else if (othIsNull || othIsSymbol) {
                setLow = false;
              } else {
                setLow = retHighest ? computed <= value : computed < value;
              }
              if (setLow) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return nativeMin(high, MAX_ARRAY_INDEX);
          }

          /**
           * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
           * support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */
          function baseSortedUniq(array, iteratee) {
            var index = -1,
              length = array.length,
              resIndex = 0,
              result = [];
            while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              if (!index || !eq(computed, seen)) {
                var seen = computed;
                result[resIndex++] = value === 0 ? 0 : value;
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.toNumber` which doesn't ensure correct
           * conversions of binary, hexadecimal, or octal string values.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           */
          function baseToNumber(value) {
            if (typeof value == 'number') {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            return +value;
          }

          /**
           * The base implementation of `_.toString` which doesn't convert nullish
           * values to empty strings.
           *
           * @private
           * @param {*} value The value to process.
           * @returns {string} Returns the string.
           */
          function baseToString(value) {
            // Exit early for strings to avoid a performance hit in some environments.
            if (typeof value == 'string') {
              return value;
            }
            if (isArray(value)) {
              // Recursively convert values (susceptible to call stack limits).
              return arrayMap(value, baseToString) + '';
            }
            if (isSymbol(value)) {
              return symbolToString ? symbolToString.call(value) : '';
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }

          /**
           * The base implementation of `_.uniqBy` without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           */
          function baseUniq(array, iteratee, comparator) {
            var index = -1,
              includes = arrayIncludes,
              length = array.length,
              isCommon = true,
              result = [],
              seen = result;
            if (comparator) {
              isCommon = false;
              includes = arrayIncludesWith;
            } else if (length >= LARGE_ARRAY_SIZE) {
              var set = iteratee ? null : createSet(array);
              if (set) {
                return setToArray(set);
              }
              isCommon = false;
              includes = cacheHas;
              seen = new SetCache();
            } else {
              seen = iteratee ? [] : result;
            }
            outer: while (++index < length) {
              var value = array[index],
                computed = iteratee ? iteratee(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee) {
                  seen.push(computed);
                }
                result.push(value);
              } else if (!includes(seen, computed, comparator)) {
                if (seen !== result) {
                  seen.push(computed);
                }
                result.push(value);
              }
            }
            return result;
          }

          /**
           * The base implementation of `_.unset`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The property path to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           */
          function baseUnset(object, path) {
            path = castPath(path, object);
            object = parent(object, path);
            return object == null || delete object[toKey(last(path))];
          }

          /**
           * The base implementation of `_.update`.
           *
           * @private
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to update.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize path creation.
           * @returns {Object} Returns `object`.
           */
          function baseUpdate(object, path, updater, customizer) {
            return baseSet(object, path, updater(baseGet(object, path)), customizer);
          }

          /**
           * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
           * without support for iteratee shorthands.
           *
           * @private
           * @param {Array} array The array to query.
           * @param {Function} predicate The function invoked per iteration.
           * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Array} Returns the slice of `array`.
           */
          function baseWhile(array, predicate, isDrop, fromRight) {
            var length = array.length,
              index = fromRight ? length : -1;
            while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {}
            return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
          }

          /**
           * The base implementation of `wrapperValue` which returns the result of
           * performing a sequence of actions on the unwrapped `value`, where each
           * successive action is supplied the return value of the previous.
           *
           * @private
           * @param {*} value The unwrapped value.
           * @param {Array} actions Actions to perform to resolve the unwrapped value.
           * @returns {*} Returns the resolved value.
           */
          function baseWrapperValue(value, actions) {
            var result = value;
            if (result instanceof LazyWrapper) {
              result = result.value();
            }
            return arrayReduce(actions, function (result, action) {
              return action.func.apply(action.thisArg, arrayPush([result], action.args));
            }, result);
          }

          /**
           * The base implementation of methods like `_.xor`, without support for
           * iteratee shorthands, that accepts an array of arrays to inspect.
           *
           * @private
           * @param {Array} arrays The arrays to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of values.
           */
          function baseXor(arrays, iteratee, comparator) {
            var length = arrays.length;
            if (length < 2) {
              return length ? baseUniq(arrays[0]) : [];
            }
            var index = -1,
              result = Array(length);
            while (++index < length) {
              var array = arrays[index],
                othIndex = -1;
              while (++othIndex < length) {
                if (othIndex != index) {
                  result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
                }
              }
            }
            return baseUniq(baseFlatten(result, 1), iteratee, comparator);
          }

          /**
           * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
           *
           * @private
           * @param {Array} props The property identifiers.
           * @param {Array} values The property values.
           * @param {Function} assignFunc The function to assign values.
           * @returns {Object} Returns the new object.
           */
          function baseZipObject(props, values, assignFunc) {
            var index = -1,
              length = props.length,
              valsLength = values.length,
              result = {};
            while (++index < length) {
              var value = index < valsLength ? values[index] : undefined;
              assignFunc(result, props[index], value);
            }
            return result;
          }

          /**
           * Casts `value` to an empty array if it's not an array like object.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Array|Object} Returns the cast array-like object.
           */
          function castArrayLikeObject(value) {
            return isArrayLikeObject(value) ? value : [];
          }

          /**
           * Casts `value` to `identity` if it's not a function.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {Function} Returns cast function.
           */
          function castFunction(value) {
            return typeof value == 'function' ? value : identity;
          }

          /**
           * Casts `value` to a path array if it's not one.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {Object} [object] The object to query keys on.
           * @returns {Array} Returns the cast property path array.
           */
          function castPath(value, object) {
            if (isArray(value)) {
              return value;
            }
            return isKey(value, object) ? [value] : stringToPath(toString(value));
          }

          /**
           * A `baseRest` alias which can be replaced with `identity` by module
           * replacement plugins.
           *
           * @private
           * @type {Function}
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */
          var castRest = baseRest;

          /**
           * Casts `array` to a slice if it's needed.
           *
           * @private
           * @param {Array} array The array to inspect.
           * @param {number} start The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the cast slice.
           */
          function castSlice(array, start, end) {
            var length = array.length;
            end = end === undefined ? length : end;
            return !start && end >= length ? array : baseSlice(array, start, end);
          }

          /**
           * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
           *
           * @private
           * @param {number|Object} id The timer id or timeout object of the timer to clear.
           */
          var clearTimeout = ctxClearTimeout || function (id) {
            return root.clearTimeout(id);
          };

          /**
           * Creates a clone of  `buffer`.
           *
           * @private
           * @param {Buffer} buffer The buffer to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Buffer} Returns the cloned buffer.
           */
          function cloneBuffer(buffer, isDeep) {
            if (isDeep) {
              return buffer.slice();
            }
            var length = buffer.length,
              result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
            buffer.copy(result);
            return result;
          }

          /**
           * Creates a clone of `arrayBuffer`.
           *
           * @private
           * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
           * @returns {ArrayBuffer} Returns the cloned array buffer.
           */
          function cloneArrayBuffer(arrayBuffer) {
            var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
            new Uint8Array(result).set(new Uint8Array(arrayBuffer));
            return result;
          }

          /**
           * Creates a clone of `dataView`.
           *
           * @private
           * @param {Object} dataView The data view to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned data view.
           */
          function cloneDataView(dataView, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
            return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
          }

          /**
           * Creates a clone of `regexp`.
           *
           * @private
           * @param {Object} regexp The regexp to clone.
           * @returns {Object} Returns the cloned regexp.
           */
          function cloneRegExp(regexp) {
            var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
            result.lastIndex = regexp.lastIndex;
            return result;
          }

          /**
           * Creates a clone of the `symbol` object.
           *
           * @private
           * @param {Object} symbol The symbol object to clone.
           * @returns {Object} Returns the cloned symbol object.
           */
          function cloneSymbol(symbol) {
            return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
          }

          /**
           * Creates a clone of `typedArray`.
           *
           * @private
           * @param {Object} typedArray The typed array to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the cloned typed array.
           */
          function cloneTypedArray(typedArray, isDeep) {
            var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
            return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
          }

          /**
           * Compares values to sort them in ascending order.
           *
           * @private
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {number} Returns the sort order indicator for `value`.
           */
          function compareAscending(value, other) {
            if (value !== other) {
              var valIsDefined = value !== undefined,
                valIsNull = value === null,
                valIsReflexive = value === value,
                valIsSymbol = isSymbol(value);
              var othIsDefined = other !== undefined,
                othIsNull = other === null,
                othIsReflexive = other === other,
                othIsSymbol = isSymbol(other);
              if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
                return 1;
              }
              if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
                return -1;
              }
            }
            return 0;
          }

          /**
           * Used by `_.orderBy` to compare multiple properties of a value to another
           * and stable sort them.
           *
           * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
           * specify an order of "desc" for descending or "asc" for ascending sort order
           * of corresponding values.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {boolean[]|string[]} orders The order to sort by for each property.
           * @returns {number} Returns the sort order indicator for `object`.
           */
          function compareMultiple(object, other, orders) {
            var index = -1,
              objCriteria = object.criteria,
              othCriteria = other.criteria,
              length = objCriteria.length,
              ordersLength = orders.length;
            while (++index < length) {
              var result = compareAscending(objCriteria[index], othCriteria[index]);
              if (result) {
                if (index >= ordersLength) {
                  return result;
                }
                var order = orders[index];
                return result * (order == 'desc' ? -1 : 1);
              }
            }
            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to provide the same value for
            // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
            // for more details.
            //
            // This also ensures a stable sort in V8 and other engines.
            // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
            return object.index - other.index;
          }

          /**
           * Creates an array that is the composition of partially applied arguments,
           * placeholders, and provided arguments into a single array of arguments.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to prepend to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgs(args, partials, holders, isCurried) {
            var argsIndex = -1,
              argsLength = args.length,
              holdersLength = holders.length,
              leftIndex = -1,
              leftLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(leftLength + rangeLength),
              isUncurried = !isCurried;
            while (++leftIndex < leftLength) {
              result[leftIndex] = partials[leftIndex];
            }
            while (++argsIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[holders[argsIndex]] = args[argsIndex];
              }
            }
            while (rangeLength--) {
              result[leftIndex++] = args[argsIndex++];
            }
            return result;
          }

          /**
           * This function is like `composeArgs` except that the arguments composition
           * is tailored for `_.partialRight`.
           *
           * @private
           * @param {Array} args The provided arguments.
           * @param {Array} partials The arguments to append to those provided.
           * @param {Array} holders The `partials` placeholder indexes.
           * @params {boolean} [isCurried] Specify composing for a curried function.
           * @returns {Array} Returns the new array of composed arguments.
           */
          function composeArgsRight(args, partials, holders, isCurried) {
            var argsIndex = -1,
              argsLength = args.length,
              holdersIndex = -1,
              holdersLength = holders.length,
              rightIndex = -1,
              rightLength = partials.length,
              rangeLength = nativeMax(argsLength - holdersLength, 0),
              result = Array(rangeLength + rightLength),
              isUncurried = !isCurried;
            while (++argsIndex < rangeLength) {
              result[argsIndex] = args[argsIndex];
            }
            var offset = argsIndex;
            while (++rightIndex < rightLength) {
              result[offset + rightIndex] = partials[rightIndex];
            }
            while (++holdersIndex < holdersLength) {
              if (isUncurried || argsIndex < argsLength) {
                result[offset + holders[holdersIndex]] = args[argsIndex++];
              }
            }
            return result;
          }

          /**
           * Copies the values of `source` to `array`.
           *
           * @private
           * @param {Array} source The array to copy values from.
           * @param {Array} [array=[]] The array to copy values to.
           * @returns {Array} Returns `array`.
           */
          function copyArray(source, array) {
            var index = -1,
              length = source.length;
            array || (array = Array(length));
            while (++index < length) {
              array[index] = source[index];
            }
            return array;
          }

          /**
           * Copies properties of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy properties from.
           * @param {Array} props The property identifiers to copy.
           * @param {Object} [object={}] The object to copy properties to.
           * @param {Function} [customizer] The function to customize copied values.
           * @returns {Object} Returns `object`.
           */
          function copyObject(source, props, object, customizer) {
            var isNew = !object;
            object || (object = {});
            var index = -1,
              length = props.length;
            while (++index < length) {
              var key = props[index];
              var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
              if (newValue === undefined) {
                newValue = source[key];
              }
              if (isNew) {
                baseAssignValue(object, key, newValue);
              } else {
                assignValue(object, key, newValue);
              }
            }
            return object;
          }

          /**
           * Copies own symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */
          function copySymbols(source, object) {
            return copyObject(source, getSymbols(source), object);
          }

          /**
           * Copies own and inherited symbols of `source` to `object`.
           *
           * @private
           * @param {Object} source The object to copy symbols from.
           * @param {Object} [object={}] The object to copy symbols to.
           * @returns {Object} Returns `object`.
           */
          function copySymbolsIn(source, object) {
            return copyObject(source, getSymbolsIn(source), object);
          }

          /**
           * Creates a function like `_.groupBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} [initializer] The accumulator object initializer.
           * @returns {Function} Returns the new aggregator function.
           */
          function createAggregator(setter, initializer) {
            return function (collection, iteratee) {
              var func = isArray(collection) ? arrayAggregator : baseAggregator,
                accumulator = initializer ? initializer() : {};
              return func(collection, setter, getIteratee(iteratee, 2), accumulator);
            };
          }

          /**
           * Creates a function like `_.assign`.
           *
           * @private
           * @param {Function} assigner The function to assign values.
           * @returns {Function} Returns the new assigner function.
           */
          function createAssigner(assigner) {
            return baseRest(function (object, sources) {
              var index = -1,
                length = sources.length,
                customizer = length > 1 ? sources[length - 1] : undefined,
                guard = length > 2 ? sources[2] : undefined;
              customizer = assigner.length > 3 && typeof customizer == 'function' ? (length--, customizer) : undefined;
              if (guard && isIterateeCall(sources[0], sources[1], guard)) {
                customizer = length < 3 ? undefined : customizer;
                length = 1;
              }
              object = Object(object);
              while (++index < length) {
                var source = sources[index];
                if (source) {
                  assigner(object, source, index, customizer);
                }
              }
              return object;
            });
          }

          /**
           * Creates a `baseEach` or `baseEachRight` function.
           *
           * @private
           * @param {Function} eachFunc The function to iterate over a collection.
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseEach(eachFunc, fromRight) {
            return function (collection, iteratee) {
              if (collection == null) {
                return collection;
              }
              if (!isArrayLike(collection)) {
                return eachFunc(collection, iteratee);
              }
              var length = collection.length,
                index = fromRight ? length : -1,
                iterable = Object(collection);
              while (fromRight ? index-- : ++index < length) {
                if (iteratee(iterable[index], index, iterable) === false) {
                  break;
                }
              }
              return collection;
            };
          }

          /**
           * Creates a base function for methods like `_.forIn` and `_.forOwn`.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new base function.
           */
          function createBaseFor(fromRight) {
            return function (object, iteratee, keysFunc) {
              var index = -1,
                iterable = Object(object),
                props = keysFunc(object),
                length = props.length;
              while (length--) {
                var key = props[fromRight ? length : ++index];
                if (iteratee(iterable[key], key, iterable) === false) {
                  break;
                }
              }
              return object;
            };
          }

          /**
           * Creates a function that wraps `func` to invoke it with the optional `this`
           * binding of `thisArg`.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createBind(func, bitmask, thisArg) {
            var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);
            function wrapper() {
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return fn.apply(isBind ? thisArg : this, arguments);
            }
            return wrapper;
          }

          /**
           * Creates a function like `_.lowerFirst`.
           *
           * @private
           * @param {string} methodName The name of the `String` case method to use.
           * @returns {Function} Returns the new case function.
           */
          function createCaseFirst(methodName) {
            return function (string) {
              string = toString(string);
              var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined;
              var chr = strSymbols ? strSymbols[0] : string.charAt(0);
              var trailing = strSymbols ? castSlice(strSymbols, 1).join('') : string.slice(1);
              return chr[methodName]() + trailing;
            };
          }

          /**
           * Creates a function like `_.camelCase`.
           *
           * @private
           * @param {Function} callback The function to combine each word.
           * @returns {Function} Returns the new compounder function.
           */
          function createCompounder(callback) {
            return function (string) {
              return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
            };
          }

          /**
           * Creates a function that produces an instance of `Ctor` regardless of
           * whether it was invoked as part of a `new` expression or by `call` or `apply`.
           *
           * @private
           * @param {Function} Ctor The constructor to wrap.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCtor(Ctor) {
            return function () {
              // Use a `switch` statement to work with class constructors. See
              // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
              // for more details.
              var args = arguments;
              switch (args.length) {
                case 0:
                  return new Ctor();
                case 1:
                  return new Ctor(args[0]);
                case 2:
                  return new Ctor(args[0], args[1]);
                case 3:
                  return new Ctor(args[0], args[1], args[2]);
                case 4:
                  return new Ctor(args[0], args[1], args[2], args[3]);
                case 5:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                case 6:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                case 7:
                  return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
              }
              var thisBinding = baseCreate(Ctor.prototype),
                result = Ctor.apply(thisBinding, args);

              // Mimic the constructor's `return` behavior.
              // See https://es5.github.io/#x13.2.2 for more details.
              return isObject(result) ? result : thisBinding;
            };
          }

          /**
           * Creates a function that wraps `func` to enable currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {number} arity The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createCurry(func, bitmask, arity) {
            var Ctor = createCtor(func);
            function wrapper() {
              var length = arguments.length,
                args = Array(length),
                index = length,
                placeholder = getHolder(wrapper);
              while (index--) {
                args[index] = arguments[index];
              }
              var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
              length -= holders.length;
              if (length < arity) {
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
              }
              var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              return apply(fn, this, args);
            }
            return wrapper;
          }

          /**
           * Creates a `_.find` or `_.findLast` function.
           *
           * @private
           * @param {Function} findIndexFunc The function to find the collection index.
           * @returns {Function} Returns the new find function.
           */
          function createFind(findIndexFunc) {
            return function (collection, predicate, fromIndex) {
              var iterable = Object(collection);
              if (!isArrayLike(collection)) {
                var iteratee = getIteratee(predicate, 3);
                collection = keys(collection);
                predicate = function predicate(key) {
                  return iteratee(iterable[key], key, iterable);
                };
              }
              var index = findIndexFunc(collection, predicate, fromIndex);
              return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
            };
          }

          /**
           * Creates a `_.flow` or `_.flowRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new flow function.
           */
          function createFlow(fromRight) {
            return flatRest(function (funcs) {
              var length = funcs.length,
                index = length,
                prereq = LodashWrapper.prototype.thru;
              if (fromRight) {
                funcs.reverse();
              }
              while (index--) {
                var func = funcs[index];
                if (typeof func != 'function') {
                  throw new TypeError(FUNC_ERROR_TEXT);
                }
                if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
                  var wrapper = new LodashWrapper([], true);
                }
              }
              index = wrapper ? index : length;
              while (++index < length) {
                func = funcs[index];
                var funcName = getFuncName(func),
                  data = funcName == 'wrapper' ? getData(func) : undefined;
                if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                  wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
                } else {
                  wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
                }
              }
              return function () {
                var args = arguments,
                  value = args[0];
                if (wrapper && args.length == 1 && isArray(value)) {
                  return wrapper.plant(value).value();
                }
                var index = 0,
                  result = length ? funcs[index].apply(this, args) : value;
                while (++index < length) {
                  result = funcs[index].call(this, result);
                }
                return result;
              };
            });
          }

          /**
           * Creates a function that wraps `func` to invoke it with optional `this`
           * binding of `thisArg`, partial application, and currying.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [partialsRight] The arguments to append to those provided
           *  to the new function.
           * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
            var isAry = bitmask & WRAP_ARY_FLAG,
              isBind = bitmask & WRAP_BIND_FLAG,
              isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
              isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
              isFlip = bitmask & WRAP_FLIP_FLAG,
              Ctor = isBindKey ? undefined : createCtor(func);
            function wrapper() {
              var length = arguments.length,
                args = Array(length),
                index = length;
              while (index--) {
                args[index] = arguments[index];
              }
              if (isCurried) {
                var placeholder = getHolder(wrapper),
                  holdersCount = countHolders(args, placeholder);
              }
              if (partials) {
                args = composeArgs(args, partials, holders, isCurried);
              }
              if (partialsRight) {
                args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
              }
              length -= holdersCount;
              if (isCurried && length < arity) {
                var newHolders = replaceHolders(args, placeholder);
                return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length);
              }
              var thisBinding = isBind ? thisArg : this,
                fn = isBindKey ? thisBinding[func] : func;
              length = args.length;
              if (argPos) {
                args = reorder(args, argPos);
              } else if (isFlip && length > 1) {
                args.reverse();
              }
              if (isAry && ary < length) {
                args.length = ary;
              }
              if (this && this !== root && this instanceof wrapper) {
                fn = Ctor || createCtor(fn);
              }
              return fn.apply(thisBinding, args);
            }
            return wrapper;
          }

          /**
           * Creates a function like `_.invertBy`.
           *
           * @private
           * @param {Function} setter The function to set accumulator values.
           * @param {Function} toIteratee The function to resolve iteratees.
           * @returns {Function} Returns the new inverter function.
           */
          function createInverter(setter, toIteratee) {
            return function (object, iteratee) {
              return baseInverter(object, setter, toIteratee(iteratee), {});
            };
          }

          /**
           * Creates a function that performs a mathematical operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @param {number} [defaultValue] The value used for `undefined` arguments.
           * @returns {Function} Returns the new mathematical operation function.
           */
          function createMathOperation(operator, defaultValue) {
            return function (value, other) {
              var result;
              if (value === undefined && other === undefined) {
                return defaultValue;
              }
              if (value !== undefined) {
                result = value;
              }
              if (other !== undefined) {
                if (result === undefined) {
                  return other;
                }
                if (typeof value == 'string' || typeof other == 'string') {
                  value = baseToString(value);
                  other = baseToString(other);
                } else {
                  value = baseToNumber(value);
                  other = baseToNumber(other);
                }
                result = operator(value, other);
              }
              return result;
            };
          }

          /**
           * Creates a function like `_.over`.
           *
           * @private
           * @param {Function} arrayFunc The function to iterate over iteratees.
           * @returns {Function} Returns the new over function.
           */
          function createOver(arrayFunc) {
            return flatRest(function (iteratees) {
              iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
              return baseRest(function (args) {
                var thisArg = this;
                return arrayFunc(iteratees, function (iteratee) {
                  return apply(iteratee, thisArg, args);
                });
              });
            });
          }

          /**
           * Creates the padding for `string` based on `length`. The `chars` string
           * is truncated if the number of characters exceeds `length`.
           *
           * @private
           * @param {number} length The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padding for `string`.
           */
          function createPadding(length, chars) {
            chars = chars === undefined ? ' ' : baseToString(chars);
            var charsLength = chars.length;
            if (charsLength < 2) {
              return charsLength ? baseRepeat(chars, length) : chars;
            }
            var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
            return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join('') : result.slice(0, length);
          }

          /**
           * Creates a function that wraps `func` to invoke it with the `this` binding
           * of `thisArg` and `partials` prepended to the arguments it receives.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {Array} partials The arguments to prepend to those provided to
           *  the new function.
           * @returns {Function} Returns the new wrapped function.
           */
          function createPartial(func, bitmask, thisArg, partials) {
            var isBind = bitmask & WRAP_BIND_FLAG,
              Ctor = createCtor(func);
            function wrapper() {
              var argsIndex = -1,
                argsLength = arguments.length,
                leftIndex = -1,
                leftLength = partials.length,
                args = Array(leftLength + argsLength),
                fn = this && this !== root && this instanceof wrapper ? Ctor : func;
              while (++leftIndex < leftLength) {
                args[leftIndex] = partials[leftIndex];
              }
              while (argsLength--) {
                args[leftIndex++] = arguments[++argsIndex];
              }
              return apply(fn, isBind ? thisArg : this, args);
            }
            return wrapper;
          }

          /**
           * Creates a `_.range` or `_.rangeRight` function.
           *
           * @private
           * @param {boolean} [fromRight] Specify iterating from right to left.
           * @returns {Function} Returns the new range function.
           */
          function createRange(fromRight) {
            return function (start, end, step) {
              if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
                end = step = undefined;
              }
              // Ensure the sign of `-0` is preserved.
              start = toFinite(start);
              if (end === undefined) {
                end = start;
                start = 0;
              } else {
                end = toFinite(end);
              }
              step = step === undefined ? start < end ? 1 : -1 : toFinite(step);
              return baseRange(start, end, step, fromRight);
            };
          }

          /**
           * Creates a function that performs a relational operation on two values.
           *
           * @private
           * @param {Function} operator The function to perform the operation.
           * @returns {Function} Returns the new relational operation function.
           */
          function createRelationalOperation(operator) {
            return function (value, other) {
              if (!(typeof value == 'string' && typeof other == 'string')) {
                value = toNumber(value);
                other = toNumber(other);
              }
              return operator(value, other);
            };
          }

          /**
           * Creates a function that wraps `func` to continue currying.
           *
           * @private
           * @param {Function} func The function to wrap.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @param {Function} wrapFunc The function to create the `func` wrapper.
           * @param {*} placeholder The placeholder value.
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to prepend to those provided to
           *  the new function.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
            var isCurry = bitmask & WRAP_CURRY_FLAG,
              newHolders = isCurry ? holders : undefined,
              newHoldersRight = isCurry ? undefined : holders,
              newPartials = isCurry ? partials : undefined,
              newPartialsRight = isCurry ? undefined : partials;
            bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
            bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
            if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
              bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
            }
            var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity];
            var result = wrapFunc.apply(undefined, newData);
            if (isLaziable(func)) {
              setData(result, newData);
            }
            result.placeholder = placeholder;
            return setWrapToString(result, func, bitmask);
          }

          /**
           * Creates a function like `_.round`.
           *
           * @private
           * @param {string} methodName The name of the `Math` method to use when rounding.
           * @returns {Function} Returns the new round function.
           */
          function createRound(methodName) {
            var func = Math[methodName];
            return function (number, precision) {
              number = toNumber(number);
              precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
              if (precision && nativeIsFinite(number)) {
                // Shift with exponential notation to avoid floating-point issues.
                // See [MDN](https://mdn.io/round#Examples) for more details.
                var pair = (toString(number) + 'e').split('e'),
                  value = func(pair[0] + 'e' + (+pair[1] + precision));
                pair = (toString(value) + 'e').split('e');
                return +(pair[0] + 'e' + (+pair[1] - precision));
              }
              return func(number);
            };
          }

          /**
           * Creates a set object of `values`.
           *
           * @private
           * @param {Array} values The values to add to the set.
           * @returns {Object} Returns the new set.
           */
          var createSet = !(Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY) ? noop : function (values) {
            return new Set(values);
          };

          /**
           * Creates a `_.toPairs` or `_.toPairsIn` function.
           *
           * @private
           * @param {Function} keysFunc The function to get the keys of a given object.
           * @returns {Function} Returns the new pairs function.
           */
          function createToPairs(keysFunc) {
            return function (object) {
              var tag = getTag(object);
              if (tag == mapTag) {
                return mapToArray(object);
              }
              if (tag == setTag) {
                return setToPairs(object);
              }
              return baseToPairs(object, keysFunc(object));
            };
          }

          /**
           * Creates a function that either curries or invokes `func` with optional
           * `this` binding and partially applied arguments.
           *
           * @private
           * @param {Function|string} func The function or method name to wrap.
           * @param {number} bitmask The bitmask flags.
           *    1 - `_.bind`
           *    2 - `_.bindKey`
           *    4 - `_.curry` or `_.curryRight` of a bound function
           *    8 - `_.curry`
           *   16 - `_.curryRight`
           *   32 - `_.partial`
           *   64 - `_.partialRight`
           *  128 - `_.rearg`
           *  256 - `_.ary`
           *  512 - `_.flip`
           * @param {*} [thisArg] The `this` binding of `func`.
           * @param {Array} [partials] The arguments to be partially applied.
           * @param {Array} [holders] The `partials` placeholder indexes.
           * @param {Array} [argPos] The argument positions of the new function.
           * @param {number} [ary] The arity cap of `func`.
           * @param {number} [arity] The arity of `func`.
           * @returns {Function} Returns the new wrapped function.
           */
          function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
            var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
            if (!isBindKey && typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var length = partials ? partials.length : 0;
            if (!length) {
              bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
              partials = holders = undefined;
            }
            ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
            arity = arity === undefined ? arity : toInteger(arity);
            length -= holders ? holders.length : 0;
            if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
              var partialsRight = partials,
                holdersRight = holders;
              partials = holders = undefined;
            }
            var data = isBindKey ? undefined : getData(func);
            var newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
            if (data) {
              mergeData(newData, data);
            }
            func = newData[0];
            bitmask = newData[1];
            thisArg = newData[2];
            partials = newData[3];
            holders = newData[4];
            arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
            if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
              bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
            }
            if (!bitmask || bitmask == WRAP_BIND_FLAG) {
              var result = createBind(func, bitmask, thisArg);
            } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
              result = createCurry(func, bitmask, arity);
            } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
              result = createPartial(func, bitmask, thisArg, partials);
            } else {
              result = createHybrid.apply(undefined, newData);
            }
            var setter = data ? baseSetData : setData;
            return setWrapToString(setter(result, newData), func, bitmask);
          }

          /**
           * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
           * of source objects to the destination object for all destination properties
           * that resolve to `undefined`.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to assign.
           * @param {Object} object The parent object of `objValue`.
           * @returns {*} Returns the value to assign.
           */
          function customDefaultsAssignIn(objValue, srcValue, key, object) {
            if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
              return srcValue;
            }
            return objValue;
          }

          /**
           * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
           * objects into destination objects that are passed thru.
           *
           * @private
           * @param {*} objValue The destination value.
           * @param {*} srcValue The source value.
           * @param {string} key The key of the property to merge.
           * @param {Object} object The parent object of `objValue`.
           * @param {Object} source The parent object of `srcValue`.
           * @param {Object} [stack] Tracks traversed source values and their merged
           *  counterparts.
           * @returns {*} Returns the value to assign.
           */
          function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
            if (isObject(objValue) && isObject(srcValue)) {
              // Recursively merge objects and arrays (susceptible to call stack limits).
              stack.set(srcValue, objValue);
              baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
              stack['delete'](srcValue);
            }
            return objValue;
          }

          /**
           * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
           * objects.
           *
           * @private
           * @param {*} value The value to inspect.
           * @param {string} key The key of the property to inspect.
           * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
           */
          function customOmitClone(value) {
            return isPlainObject(value) ? undefined : value;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for arrays with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Array} array The array to compare.
           * @param {Array} other The other array to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `array` and `other` objects.
           * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
           */
          function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              arrLength = array.length,
              othLength = other.length;
            if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
              return false;
            }
            // Check that cyclic values are equal.
            var arrStacked = stack.get(array);
            var othStacked = stack.get(other);
            if (arrStacked && othStacked) {
              return arrStacked == other && othStacked == array;
            }
            var index = -1,
              result = true,
              seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined;
            stack.set(array, other);
            stack.set(other, array);

            // Ignore non-index properties.
            while (++index < arrLength) {
              var arrValue = array[index],
                othValue = other[index];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
              }
              if (compared !== undefined) {
                if (compared) {
                  continue;
                }
                result = false;
                break;
              }
              // Recursively compare arrays (susceptible to call stack limits).
              if (seen) {
                if (!arraySome(other, function (othValue, othIndex) {
                  if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                    return seen.push(othIndex);
                  }
                })) {
                  result = false;
                  break;
                }
              } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                result = false;
                break;
              }
            }
            stack['delete'](array);
            stack['delete'](other);
            return result;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for comparing objects of
           * the same `toStringTag`.
           *
           * **Note:** This function only supports comparing values with tags of
           * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {string} tag The `toStringTag` of the objects to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
            switch (tag) {
              case dataViewTag:
                if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                  return false;
                }
                object = object.buffer;
                other = other.buffer;
              case arrayBufferTag:
                if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
                  return false;
                }
                return true;
              case boolTag:
              case dateTag:
              case numberTag:
                // Coerce booleans to `1` or `0` and dates to milliseconds.
                // Invalid dates are coerced to `NaN`.
                return eq(+object, +other);
              case errorTag:
                return object.name == other.name && object.message == other.message;
              case regexpTag:
              case stringTag:
                // Coerce regexes to strings and treat strings, primitives and objects,
                // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
                // for more details.
                return object == other + '';
              case mapTag:
                var convert = mapToArray;
              case setTag:
                var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                convert || (convert = setToArray);
                if (object.size != other.size && !isPartial) {
                  return false;
                }
                // Assume cyclic values are equal.
                var stacked = stack.get(object);
                if (stacked) {
                  return stacked == other;
                }
                bitmask |= COMPARE_UNORDERED_FLAG;

                // Recursively compare objects (susceptible to call stack limits).
                stack.set(object, other);
                var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                stack['delete'](object);
                return result;
              case symbolTag:
                if (symbolValueOf) {
                  return symbolValueOf.call(object) == symbolValueOf.call(other);
                }
            }
            return false;
          }

          /**
           * A specialized version of `baseIsEqualDeep` for objects with support for
           * partial deep comparisons.
           *
           * @private
           * @param {Object} object The object to compare.
           * @param {Object} other The other object to compare.
           * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
           * @param {Function} customizer The function to customize comparisons.
           * @param {Function} equalFunc The function to determine equivalents of values.
           * @param {Object} stack Tracks traversed `object` and `other` objects.
           * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
           */
          function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
            var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
              objProps = getAllKeys(object),
              objLength = objProps.length,
              othProps = getAllKeys(other),
              othLength = othProps.length;
            if (objLength != othLength && !isPartial) {
              return false;
            }
            var index = objLength;
            while (index--) {
              var key = objProps[index];
              if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
                return false;
              }
            }
            // Check that cyclic values are equal.
            var objStacked = stack.get(object);
            var othStacked = stack.get(other);
            if (objStacked && othStacked) {
              return objStacked == other && othStacked == object;
            }
            var result = true;
            stack.set(object, other);
            stack.set(other, object);
            var skipCtor = isPartial;
            while (++index < objLength) {
              key = objProps[index];
              var objValue = object[key],
                othValue = other[key];
              if (customizer) {
                var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
              }
              // Recursively compare objects (susceptible to call stack limits).
              if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                result = false;
                break;
              }
              skipCtor || (skipCtor = key == 'constructor');
            }
            if (result && !skipCtor) {
              var objCtor = object.constructor,
                othCtor = other.constructor;

              // Non `Object` object instances with different constructors are not equal.
              if (objCtor != othCtor && 'constructor' in object && 'constructor' in other && !(typeof objCtor == 'function' && objCtor instanceof objCtor && typeof othCtor == 'function' && othCtor instanceof othCtor)) {
                result = false;
              }
            }
            stack['delete'](object);
            stack['delete'](other);
            return result;
          }

          /**
           * A specialized version of `baseRest` which flattens the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @returns {Function} Returns the new function.
           */
          function flatRest(func) {
            return setToString(overRest(func, undefined, flatten), func + '');
          }

          /**
           * Creates an array of own enumerable property names and symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function getAllKeys(object) {
            return baseGetAllKeys(object, keys, getSymbols);
          }

          /**
           * Creates an array of own and inherited enumerable property names and
           * symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names and symbols.
           */
          function getAllKeysIn(object) {
            return baseGetAllKeys(object, keysIn, getSymbolsIn);
          }

          /**
           * Gets metadata for `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {*} Returns the metadata for `func`.
           */
          var getData = !metaMap ? noop : function (func) {
            return metaMap.get(func);
          };

          /**
           * Gets the name of `func`.
           *
           * @private
           * @param {Function} func The function to query.
           * @returns {string} Returns the function name.
           */
          function getFuncName(func) {
            var result = func.name + '',
              array = realNames[result],
              length = hasOwnProperty.call(realNames, result) ? array.length : 0;
            while (length--) {
              var data = array[length],
                otherFunc = data.func;
              if (otherFunc == null || otherFunc == func) {
                return data.name;
              }
            }
            return result;
          }

          /**
           * Gets the argument placeholder value for `func`.
           *
           * @private
           * @param {Function} func The function to inspect.
           * @returns {*} Returns the placeholder value.
           */
          function getHolder(func) {
            var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
            return object.placeholder;
          }

          /**
           * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
           * this function returns the custom method, otherwise it returns `baseIteratee`.
           * If arguments are provided, the chosen function is invoked with them and
           * its result is returned.
           *
           * @private
           * @param {*} [value] The value to convert to an iteratee.
           * @param {number} [arity] The arity of the created iteratee.
           * @returns {Function} Returns the chosen function or its result.
           */
          function getIteratee() {
            var result = lodash.iteratee || iteratee;
            result = result === iteratee ? baseIteratee : result;
            return arguments.length ? result(arguments[0], arguments[1]) : result;
          }

          /**
           * Gets the data for `map`.
           *
           * @private
           * @param {Object} map The map to query.
           * @param {string} key The reference key.
           * @returns {*} Returns the map data.
           */
          function getMapData(map, key) {
            var data = map.__data__;
            return isKeyable(key) ? data[typeof key == 'string' ? 'string' : 'hash'] : data.map;
          }

          /**
           * Gets the property names, values, and compare flags of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the match data of `object`.
           */
          function getMatchData(object) {
            var result = keys(object),
              length = result.length;
            while (length--) {
              var key = result[length],
                value = object[key];
              result[length] = [key, value, isStrictComparable(value)];
            }
            return result;
          }

          /**
           * Gets the native function at `key` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the method to get.
           * @returns {*} Returns the function if it's native, else `undefined`.
           */
          function getNative(object, key) {
            var value = getValue(object, key);
            return baseIsNative(value) ? value : undefined;
          }

          /**
           * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the raw `toStringTag`.
           */
          function getRawTag(value) {
            var isOwn = hasOwnProperty.call(value, symToStringTag),
              tag = value[symToStringTag];
            try {
              value[symToStringTag] = undefined;
              var unmasked = true;
            } catch (e) {}
            var result = nativeObjectToString.call(value);
            if (unmasked) {
              if (isOwn) {
                value[symToStringTag] = tag;
              } else {
                delete value[symToStringTag];
              }
            }
            return result;
          }

          /**
           * Creates an array of the own enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbols = !nativeGetSymbols ? stubArray : function (object) {
            if (object == null) {
              return [];
            }
            object = Object(object);
            return arrayFilter(nativeGetSymbols(object), function (symbol) {
              return propertyIsEnumerable.call(object, symbol);
            });
          };

          /**
           * Creates an array of the own and inherited enumerable symbols of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of symbols.
           */
          var getSymbolsIn = !nativeGetSymbols ? stubArray : function (object) {
            var result = [];
            while (object) {
              arrayPush(result, getSymbols(object));
              object = getPrototype(object);
            }
            return result;
          };

          /**
           * Gets the `toStringTag` of `value`.
           *
           * @private
           * @param {*} value The value to query.
           * @returns {string} Returns the `toStringTag`.
           */
          var getTag = baseGetTag;

          // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
          if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map()) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set()) != setTag || WeakMap && getTag(new WeakMap()) != weakMapTag) {
            getTag = function getTag(value) {
              var result = baseGetTag(value),
                Ctor = result == objectTag ? value.constructor : undefined,
                ctorString = Ctor ? toSource(Ctor) : '';
              if (ctorString) {
                switch (ctorString) {
                  case dataViewCtorString:
                    return dataViewTag;
                  case mapCtorString:
                    return mapTag;
                  case promiseCtorString:
                    return promiseTag;
                  case setCtorString:
                    return setTag;
                  case weakMapCtorString:
                    return weakMapTag;
                }
              }
              return result;
            };
          }

          /**
           * Gets the view, applying any `transforms` to the `start` and `end` positions.
           *
           * @private
           * @param {number} start The start of the view.
           * @param {number} end The end of the view.
           * @param {Array} transforms The transformations to apply to the view.
           * @returns {Object} Returns an object containing the `start` and `end`
           *  positions of the view.
           */
          function getView(start, end, transforms) {
            var index = -1,
              length = transforms.length;
            while (++index < length) {
              var data = transforms[index],
                size = data.size;
              switch (data.type) {
                case 'drop':
                  start += size;
                  break;
                case 'dropRight':
                  end -= size;
                  break;
                case 'take':
                  end = nativeMin(end, start + size);
                  break;
                case 'takeRight':
                  start = nativeMax(start, end - size);
                  break;
              }
            }
            return {
              'start': start,
              'end': end
            };
          }

          /**
           * Extracts wrapper details from the `source` body comment.
           *
           * @private
           * @param {string} source The source to inspect.
           * @returns {Array} Returns the wrapper details.
           */
          function getWrapDetails(source) {
            var match = source.match(reWrapDetails);
            return match ? match[1].split(reSplitDetails) : [];
          }

          /**
           * Checks if `path` exists on `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @param {Function} hasFunc The function to check properties.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           */
          function hasPath(object, path, hasFunc) {
            path = castPath(path, object);
            var index = -1,
              length = path.length,
              result = false;
            while (++index < length) {
              var key = toKey(path[index]);
              if (!(result = object != null && hasFunc(object, key))) {
                break;
              }
              object = object[key];
            }
            if (result || ++index != length) {
              return result;
            }
            length = object == null ? 0 : object.length;
            return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
          }

          /**
           * Initializes an array clone.
           *
           * @private
           * @param {Array} array The array to clone.
           * @returns {Array} Returns the initialized clone.
           */
          function initCloneArray(array) {
            var length = array.length,
              result = new array.constructor(length);

            // Add properties assigned by `RegExp#exec`.
            if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
              result.index = array.index;
              result.input = array.input;
            }
            return result;
          }

          /**
           * Initializes an object clone.
           *
           * @private
           * @param {Object} object The object to clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneObject(object) {
            return typeof object.constructor == 'function' && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
          }

          /**
           * Initializes an object clone based on its `toStringTag`.
           *
           * **Note:** This function only supports cloning values with tags of
           * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
           *
           * @private
           * @param {Object} object The object to clone.
           * @param {string} tag The `toStringTag` of the object to clone.
           * @param {boolean} [isDeep] Specify a deep clone.
           * @returns {Object} Returns the initialized clone.
           */
          function initCloneByTag(object, tag, isDeep) {
            var Ctor = object.constructor;
            switch (tag) {
              case arrayBufferTag:
                return cloneArrayBuffer(object);
              case boolTag:
              case dateTag:
                return new Ctor(+object);
              case dataViewTag:
                return cloneDataView(object, isDeep);
              case float32Tag:
              case float64Tag:
              case int8Tag:
              case int16Tag:
              case int32Tag:
              case uint8Tag:
              case uint8ClampedTag:
              case uint16Tag:
              case uint32Tag:
                return cloneTypedArray(object, isDeep);
              case mapTag:
                return new Ctor();
              case numberTag:
              case stringTag:
                return new Ctor(object);
              case regexpTag:
                return cloneRegExp(object);
              case setTag:
                return new Ctor();
              case symbolTag:
                return cloneSymbol(object);
            }
          }

          /**
           * Inserts wrapper `details` in a comment at the top of the `source` body.
           *
           * @private
           * @param {string} source The source to modify.
           * @returns {Array} details The details to insert.
           * @returns {string} Returns the modified source.
           */
          function insertWrapDetails(source, details) {
            var length = details.length;
            if (!length) {
              return source;
            }
            var lastIndex = length - 1;
            details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
            details = details.join(length > 2 ? ', ' : ' ');
            return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
          }

          /**
           * Checks if `value` is a flattenable `arguments` object or array.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
           */
          function isFlattenable(value) {
            return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
          }

          /**
           * Checks if `value` is a valid array-like index.
           *
           * @private
           * @param {*} value The value to check.
           * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
           * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
           */
          function isIndex(value, length) {
            var type = typeof value;
            length = length == null ? MAX_SAFE_INTEGER : length;
            return !!length && (type == 'number' || type != 'symbol' && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
          }

          /**
           * Checks if the given arguments are from an iteratee call.
           *
           * @private
           * @param {*} value The potential iteratee value argument.
           * @param {*} index The potential iteratee index or key argument.
           * @param {*} object The potential iteratee object argument.
           * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
           *  else `false`.
           */
          function isIterateeCall(value, index, object) {
            if (!isObject(object)) {
              return false;
            }
            var type = typeof index;
            if (type == 'number' ? isArrayLike(object) && isIndex(index, object.length) : type == 'string' && index in object) {
              return eq(object[index], value);
            }
            return false;
          }

          /**
           * Checks if `value` is a property name and not a property path.
           *
           * @private
           * @param {*} value The value to check.
           * @param {Object} [object] The object to query keys on.
           * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
           */
          function isKey(value, object) {
            if (isArray(value)) {
              return false;
            }
            var type = typeof value;
            if (type == 'number' || type == 'symbol' || type == 'boolean' || value == null || isSymbol(value)) {
              return true;
            }
            return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
          }

          /**
           * Checks if `value` is suitable for use as unique object key.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
           */
          function isKeyable(value) {
            var type = typeof value;
            return type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean' ? value !== '__proto__' : value === null;
          }

          /**
           * Checks if `func` has a lazy counterpart.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
           *  else `false`.
           */
          function isLaziable(func) {
            var funcName = getFuncName(func),
              other = lodash[funcName];
            if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
              return false;
            }
            if (func === other) {
              return true;
            }
            var data = getData(other);
            return !!data && func === data[0];
          }

          /**
           * Checks if `func` has its source masked.
           *
           * @private
           * @param {Function} func The function to check.
           * @returns {boolean} Returns `true` if `func` is masked, else `false`.
           */
          function isMasked(func) {
            return !!maskSrcKey && maskSrcKey in func;
          }

          /**
           * Checks if `func` is capable of being masked.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
           */
          var isMaskable = coreJsData ? isFunction : stubFalse;

          /**
           * Checks if `value` is likely a prototype object.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
           */
          function isPrototype(value) {
            var Ctor = value && value.constructor,
              proto = typeof Ctor == 'function' && Ctor.prototype || objectProto;
            return value === proto;
          }

          /**
           * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` if suitable for strict
           *  equality comparisons, else `false`.
           */
          function isStrictComparable(value) {
            return value === value && !isObject(value);
          }

          /**
           * A specialized version of `matchesProperty` for source values suitable
           * for strict equality comparisons, i.e. `===`.
           *
           * @private
           * @param {string} key The key of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           */
          function matchesStrictComparable(key, srcValue) {
            return function (object) {
              if (object == null) {
                return false;
              }
              return object[key] === srcValue && (srcValue !== undefined || key in Object(object));
            };
          }

          /**
           * A specialized version of `_.memoize` which clears the memoized function's
           * cache when it exceeds `MAX_MEMOIZE_SIZE`.
           *
           * @private
           * @param {Function} func The function to have its output memoized.
           * @returns {Function} Returns the new memoized function.
           */
          function memoizeCapped(func) {
            var result = memoize(func, function (key) {
              if (cache.size === MAX_MEMOIZE_SIZE) {
                cache.clear();
              }
              return key;
            });
            var cache = result.cache;
            return result;
          }

          /**
           * Merges the function metadata of `source` into `data`.
           *
           * Merging metadata reduces the number of wrappers used to invoke a function.
           * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
           * may be applied regardless of execution order. Methods like `_.ary` and
           * `_.rearg` modify function arguments, making the order in which they are
           * executed important, preventing the merging of metadata. However, we make
           * an exception for a safe combined case where curried functions have `_.ary`
           * and or `_.rearg` applied.
           *
           * @private
           * @param {Array} data The destination metadata.
           * @param {Array} source The source metadata.
           * @returns {Array} Returns `data`.
           */
          function mergeData(data, source) {
            var bitmask = data[1],
              srcBitmask = source[1],
              newBitmask = bitmask | srcBitmask,
              isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
            var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;

            // Exit early if metadata can't be merged.
            if (!(isCommon || isCombo)) {
              return data;
            }
            // Use source `thisArg` if available.
            if (srcBitmask & WRAP_BIND_FLAG) {
              data[2] = source[2];
              // Set when currying a bound function.
              newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
            }
            // Compose partial arguments.
            var value = source[3];
            if (value) {
              var partials = data[3];
              data[3] = partials ? composeArgs(partials, value, source[4]) : value;
              data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
            }
            // Compose partial right arguments.
            value = source[5];
            if (value) {
              partials = data[5];
              data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
              data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
            }
            // Use source `argPos` if available.
            value = source[7];
            if (value) {
              data[7] = value;
            }
            // Use source `ary` if it's smaller.
            if (srcBitmask & WRAP_ARY_FLAG) {
              data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
            }
            // Use source `arity` if one is not provided.
            if (data[9] == null) {
              data[9] = source[9];
            }
            // Use source `func` and merge bitmasks.
            data[0] = source[0];
            data[1] = newBitmask;
            return data;
          }

          /**
           * This function is like
           * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * except that it includes inherited enumerable properties.
           *
           * @private
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           */
          function nativeKeysIn(object) {
            var result = [];
            if (object != null) {
              for (var key in Object(object)) {
                result.push(key);
              }
            }
            return result;
          }

          /**
           * Converts `value` to a string using `Object.prototype.toString`.
           *
           * @private
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           */
          function objectToString(value) {
            return nativeObjectToString.call(value);
          }

          /**
           * A specialized version of `baseRest` which transforms the rest array.
           *
           * @private
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @param {Function} transform The rest array transform.
           * @returns {Function} Returns the new function.
           */
          function overRest(func, start, transform) {
            start = nativeMax(start === undefined ? func.length - 1 : start, 0);
            return function () {
              var args = arguments,
                index = -1,
                length = nativeMax(args.length - start, 0),
                array = Array(length);
              while (++index < length) {
                array[index] = args[start + index];
              }
              index = -1;
              var otherArgs = Array(start + 1);
              while (++index < start) {
                otherArgs[index] = args[index];
              }
              otherArgs[start] = transform(array);
              return apply(func, this, otherArgs);
            };
          }

          /**
           * Gets the parent value at `path` of `object`.
           *
           * @private
           * @param {Object} object The object to query.
           * @param {Array} path The path to get the parent value of.
           * @returns {*} Returns the parent value.
           */
          function parent(object, path) {
            return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
          }

          /**
           * Reorder `array` according to the specified indexes where the element at
           * the first index is assigned as the first element, the element at
           * the second index is assigned as the second element, and so on.
           *
           * @private
           * @param {Array} array The array to reorder.
           * @param {Array} indexes The arranged array indexes.
           * @returns {Array} Returns `array`.
           */
          function reorder(array, indexes) {
            var arrLength = array.length,
              length = nativeMin(indexes.length, arrLength),
              oldArray = copyArray(array);
            while (length--) {
              var index = indexes[length];
              array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
            }
            return array;
          }

          /**
           * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
           *
           * @private
           * @param {Object} object The object to query.
           * @param {string} key The key of the property to get.
           * @returns {*} Returns the property value.
           */
          function safeGet(object, key) {
            if (key === 'constructor' && typeof object[key] === 'function') {
              return;
            }
            if (key == '__proto__') {
              return;
            }
            return object[key];
          }

          /**
           * Sets metadata for `func`.
           *
           * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
           * period of time, it will trip its breaker and transition to an identity
           * function to avoid garbage collection pauses in V8. See
           * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
           * for more details.
           *
           * @private
           * @param {Function} func The function to associate metadata with.
           * @param {*} data The metadata.
           * @returns {Function} Returns `func`.
           */
          var setData = shortOut(baseSetData);

          /**
           * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
           *
           * @private
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @returns {number|Object} Returns the timer id or timeout object.
           */
          var setTimeout = ctxSetTimeout || function (func, wait) {
            return root.setTimeout(func, wait);
          };

          /**
           * Sets the `toString` method of `func` to return `string`.
           *
           * @private
           * @param {Function} func The function to modify.
           * @param {Function} string The `toString` result.
           * @returns {Function} Returns `func`.
           */
          var setToString = shortOut(baseSetToString);

          /**
           * Sets the `toString` method of `wrapper` to mimic the source of `reference`
           * with wrapper details in a comment at the top of the source body.
           *
           * @private
           * @param {Function} wrapper The function to modify.
           * @param {Function} reference The reference function.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Function} Returns `wrapper`.
           */
          function setWrapToString(wrapper, reference, bitmask) {
            var source = reference + '';
            return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
          }

          /**
           * Creates a function that'll short out and invoke `identity` instead
           * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
           * milliseconds.
           *
           * @private
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new shortable function.
           */
          function shortOut(func) {
            var count = 0,
              lastCalled = 0;
            return function () {
              var stamp = nativeNow(),
                remaining = HOT_SPAN - (stamp - lastCalled);
              lastCalled = stamp;
              if (remaining > 0) {
                if (++count >= HOT_COUNT) {
                  return arguments[0];
                }
              } else {
                count = 0;
              }
              return func.apply(undefined, arguments);
            };
          }

          /**
           * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
           *
           * @private
           * @param {Array} array The array to shuffle.
           * @param {number} [size=array.length] The size of `array`.
           * @returns {Array} Returns `array`.
           */
          function shuffleSelf(array, size) {
            var index = -1,
              length = array.length,
              lastIndex = length - 1;
            size = size === undefined ? length : size;
            while (++index < size) {
              var rand = baseRandom(index, lastIndex),
                value = array[rand];
              array[rand] = array[index];
              array[index] = value;
            }
            array.length = size;
            return array;
          }

          /**
           * Converts `string` to a property path array.
           *
           * @private
           * @param {string} string The string to convert.
           * @returns {Array} Returns the property path array.
           */
          var stringToPath = memoizeCapped(function (string) {
            var result = [];
            if (string.charCodeAt(0) === 46 /* . */) {
              result.push('');
            }
            string.replace(rePropName, function (match, number, quote, subString) {
              result.push(quote ? subString.replace(reEscapeChar, '$1') : number || match);
            });
            return result;
          });

          /**
           * Converts `value` to a string key if it's not a string or symbol.
           *
           * @private
           * @param {*} value The value to inspect.
           * @returns {string|symbol} Returns the key.
           */
          function toKey(value) {
            if (typeof value == 'string' || isSymbol(value)) {
              return value;
            }
            var result = value + '';
            return result == '0' && 1 / value == -INFINITY ? '-0' : result;
          }

          /**
           * Converts `func` to its source code.
           *
           * @private
           * @param {Function} func The function to convert.
           * @returns {string} Returns the source code.
           */
          function toSource(func) {
            if (func != null) {
              try {
                return funcToString.call(func);
              } catch (e) {}
              try {
                return func + '';
              } catch (e) {}
            }
            return '';
          }

          /**
           * Updates wrapper `details` based on `bitmask` flags.
           *
           * @private
           * @returns {Array} details The details to modify.
           * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
           * @returns {Array} Returns `details`.
           */
          function updateWrapDetails(details, bitmask) {
            arrayEach(wrapFlags, function (pair) {
              var value = '_.' + pair[0];
              if (bitmask & pair[1] && !arrayIncludes(details, value)) {
                details.push(value);
              }
            });
            return details.sort();
          }

          /**
           * Creates a clone of `wrapper`.
           *
           * @private
           * @param {Object} wrapper The wrapper to clone.
           * @returns {Object} Returns the cloned wrapper.
           */
          function wrapperClone(wrapper) {
            if (wrapper instanceof LazyWrapper) {
              return wrapper.clone();
            }
            var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
            result.__actions__ = copyArray(wrapper.__actions__);
            result.__index__ = wrapper.__index__;
            result.__values__ = wrapper.__values__;
            return result;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an array of elements split into groups the length of `size`.
           * If `array` can't be split evenly, the final chunk will be the remaining
           * elements.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to process.
           * @param {number} [size=1] The length of each chunk
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the new array of chunks.
           * @example
           *
           * _.chunk(['a', 'b', 'c', 'd'], 2);
           * // => [['a', 'b'], ['c', 'd']]
           *
           * _.chunk(['a', 'b', 'c', 'd'], 3);
           * // => [['a', 'b', 'c'], ['d']]
           */
          function chunk(array, size, guard) {
            if (guard ? isIterateeCall(array, size, guard) : size === undefined) {
              size = 1;
            } else {
              size = nativeMax(toInteger(size), 0);
            }
            var length = array == null ? 0 : array.length;
            if (!length || size < 1) {
              return [];
            }
            var index = 0,
              resIndex = 0,
              result = Array(nativeCeil(length / size));
            while (index < length) {
              result[resIndex++] = baseSlice(array, index, index += size);
            }
            return result;
          }

          /**
           * Creates an array with all falsey values removed. The values `false`, `null`,
           * `0`, `""`, `undefined`, and `NaN` are falsey.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to compact.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.compact([0, 1, false, 2, '', 3]);
           * // => [1, 2, 3]
           */
          function compact(array) {
            var index = -1,
              length = array == null ? 0 : array.length,
              resIndex = 0,
              result = [];
            while (++index < length) {
              var value = array[index];
              if (value) {
                result[resIndex++] = value;
              }
            }
            return result;
          }

          /**
           * Creates a new array concatenating `array` with any additional arrays
           * and/or values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to concatenate.
           * @param {...*} [values] The values to concatenate.
           * @returns {Array} Returns the new concatenated array.
           * @example
           *
           * var array = [1];
           * var other = _.concat(array, 2, [3], [[4]]);
           *
           * console.log(other);
           * // => [1, 2, 3, [4]]
           *
           * console.log(array);
           * // => [1]
           */
          function concat() {
            var length = arguments.length;
            if (!length) {
              return [];
            }
            var args = Array(length - 1),
              array = arguments[0],
              index = length;
            while (index--) {
              args[index - 1] = arguments[index];
            }
            return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
          }

          /**
           * Creates an array of `array` values not included in the other given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * **Note:** Unlike `_.pullAll`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.without, _.xor
           * @example
           *
           * _.difference([2, 1], [2, 3]);
           * // => [1]
           */
          var difference = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true)) : [];
          });

          /**
           * This method is like `_.difference` except that it accepts `iteratee` which
           * is invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */
          var differenceBy = baseRest(function (array, values) {
            var iteratee = last(values);
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2)) : [];
          });

          /**
           * This method is like `_.difference` except that it accepts `comparator`
           * which is invoked to compare elements of `array` to `values`. The order and
           * references of result values are determined by the first array. The comparator
           * is invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...Array} [values] The values to exclude.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           *
           * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }]
           */
          var differenceWith = baseRest(function (array, values) {
            var comparator = last(values);
            if (isArrayLikeObject(comparator)) {
              comparator = undefined;
            }
            return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator) : [];
          });

          /**
           * Creates a slice of `array` with `n` elements dropped from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.drop([1, 2, 3]);
           * // => [2, 3]
           *
           * _.drop([1, 2, 3], 2);
           * // => [3]
           *
           * _.drop([1, 2, 3], 5);
           * // => []
           *
           * _.drop([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function drop(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, n < 0 ? 0 : n, length);
          }

          /**
           * Creates a slice of `array` with `n` elements dropped from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to drop.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.dropRight([1, 2, 3]);
           * // => [1, 2]
           *
           * _.dropRight([1, 2, 3], 2);
           * // => [1]
           *
           * _.dropRight([1, 2, 3], 5);
           * // => []
           *
           * _.dropRight([1, 2, 3], 0);
           * // => [1, 2, 3]
           */
          function dropRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the end.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.dropRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropRightWhile(users, ['active', false]);
           * // => objects for ['barney']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropRightWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */
          function dropRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
          }

          /**
           * Creates a slice of `array` excluding elements dropped from the beginning.
           * Elements are dropped until `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.dropWhile(users, function(o) { return !o.active; });
           * // => objects for ['pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.dropWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.dropWhile(users, ['active', false]);
           * // => objects for ['pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.dropWhile(users, 'active');
           * // => objects for ['barney', 'fred', 'pebbles']
           */
          function dropWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
          }

          /**
           * Fills elements of `array` with `value` from `start` up to, but not
           * including, `end`.
           *
           * **Note:** This method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Array
           * @param {Array} array The array to fill.
           * @param {*} value The value to fill `array` with.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.fill(array, 'a');
           * console.log(array);
           * // => ['a', 'a', 'a']
           *
           * _.fill(Array(3), 2);
           * // => [2, 2, 2]
           *
           * _.fill([4, 6, 8, 10], '*', 1, 3);
           * // => [4, '*', '*', 10]
           */
          function fill(array, value, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
              start = 0;
              end = length;
            }
            return baseFill(array, value, start, end);
          }

          /**
           * This method is like `_.find` except that it returns the index of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.findIndex(users, function(o) { return o.user == 'barney'; });
           * // => 0
           *
           * // The `_.matches` iteratee shorthand.
           * _.findIndex(users, { 'user': 'fred', 'active': false });
           * // => 1
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findIndex(users, ['active', false]);
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.findIndex(users, 'active');
           * // => 2
           */
          function findIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index);
          }

          /**
           * This method is like `_.findIndex` except that it iterates over elements
           * of `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the found element, else `-1`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
           * // => 2
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastIndex(users, { 'user': 'barney', 'active': true });
           * // => 0
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastIndex(users, ['active', false]);
           * // => 2
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastIndex(users, 'active');
           * // => 0
           */
          function findLastIndex(array, predicate, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length - 1;
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return baseFindIndex(array, getIteratee(predicate, 3), index, true);
          }

          /**
           * Flattens `array` a single level deep.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flatten([1, [2, [3, [4]], 5]]);
           * // => [1, 2, [3, [4]], 5]
           */
          function flatten(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, 1) : [];
          }

          /**
           * Recursively flattens `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * _.flattenDeep([1, [2, [3, [4]], 5]]);
           * // => [1, 2, 3, 4, 5]
           */
          function flattenDeep(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseFlatten(array, INFINITY) : [];
          }

          /**
           * Recursively flatten `array` up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Array
           * @param {Array} array The array to flatten.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * var array = [1, [2, [3, [4]], 5]];
           *
           * _.flattenDepth(array, 1);
           * // => [1, 2, [3, [4]], 5]
           *
           * _.flattenDepth(array, 2);
           * // => [1, 2, 3, [4], 5]
           */
          function flattenDepth(array, depth) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(array, depth);
          }

          /**
           * The inverse of `_.toPairs`; this method returns an object composed
           * from key-value `pairs`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} pairs The key-value pairs.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.fromPairs([['a', 1], ['b', 2]]);
           * // => { 'a': 1, 'b': 2 }
           */
          function fromPairs(pairs) {
            var index = -1,
              length = pairs == null ? 0 : pairs.length,
              result = {};
            while (++index < length) {
              var pair = pairs[index];
              result[pair[0]] = pair[1];
            }
            return result;
          }

          /**
           * Gets the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias first
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the first element of `array`.
           * @example
           *
           * _.head([1, 2, 3]);
           * // => 1
           *
           * _.head([]);
           * // => undefined
           */
          function head(array) {
            return array && array.length ? array[0] : undefined;
          }

          /**
           * Gets the index at which the first occurrence of `value` is found in `array`
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. If `fromIndex` is negative, it's used as the
           * offset from the end of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.indexOf([1, 2, 1, 2], 2);
           * // => 1
           *
           * // Search from the `fromIndex`.
           * _.indexOf([1, 2, 1, 2], 2, 2);
           * // => 3
           */
          function indexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = fromIndex == null ? 0 : toInteger(fromIndex);
            if (index < 0) {
              index = nativeMax(length + index, 0);
            }
            return baseIndexOf(array, value, index);
          }

          /**
           * Gets all but the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.initial([1, 2, 3]);
           * // => [1, 2]
           */
          function initial(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 0, -1) : [];
          }

          /**
           * Creates an array of unique values that are included in all given arrays
           * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons. The order and references of result values are
           * determined by the first array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersection([2, 1], [2, 3]);
           * // => [2]
           */
          var intersection = baseRest(function (arrays) {
            var mapped = arrayMap(arrays, castArrayLikeObject);
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
          });

          /**
           * This method is like `_.intersection` except that it accepts `iteratee`
           * which is invoked for each element of each `arrays` to generate the criterion
           * by which they're compared. The order and references of result values are
           * determined by the first array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [2.1]
           *
           * // The `_.property` iteratee shorthand.
           * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }]
           */
          var intersectionBy = baseRest(function (arrays) {
            var iteratee = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);
            if (iteratee === last(mapped)) {
              iteratee = undefined;
            } else {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : [];
          });

          /**
           * This method is like `_.intersection` except that it accepts `comparator`
           * which is invoked to compare elements of `arrays`. The order and references
           * of result values are determined by the first array. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of intersecting values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.intersectionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }]
           */
          var intersectionWith = baseRest(function (arrays) {
            var comparator = last(arrays),
              mapped = arrayMap(arrays, castArrayLikeObject);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            if (comparator) {
              mapped.pop();
            }
            return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : [];
          });

          /**
           * Converts all elements in `array` into a string separated by `separator`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to convert.
           * @param {string} [separator=','] The element separator.
           * @returns {string} Returns the joined string.
           * @example
           *
           * _.join(['a', 'b', 'c'], '~');
           * // => 'a~b~c'
           */
          function join(array, separator) {
            return array == null ? '' : nativeJoin.call(array, separator);
          }

          /**
           * Gets the last element of `array`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {*} Returns the last element of `array`.
           * @example
           *
           * _.last([1, 2, 3]);
           * // => 3
           */
          function last(array) {
            var length = array == null ? 0 : array.length;
            return length ? array[length - 1] : undefined;
          }

          /**
           * This method is like `_.indexOf` except that it iterates over elements of
           * `array` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=array.length-1] The index to search from.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.lastIndexOf([1, 2, 1, 2], 2);
           * // => 3
           *
           * // Search from the `fromIndex`.
           * _.lastIndexOf([1, 2, 1, 2], 2, 2);
           * // => 1
           */
          function lastIndexOf(array, value, fromIndex) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return -1;
            }
            var index = length;
            if (fromIndex !== undefined) {
              index = toInteger(fromIndex);
              index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
            }
            return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
          }

          /**
           * Gets the element at index `n` of `array`. If `n` is negative, the nth
           * element from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.11.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=0] The index of the element to return.
           * @returns {*} Returns the nth element of `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           *
           * _.nth(array, 1);
           * // => 'b'
           *
           * _.nth(array, -2);
           * // => 'c';
           */
          function nth(array, n) {
            return array && array.length ? baseNth(array, toInteger(n)) : undefined;
          }

          /**
           * Removes all given values from `array` using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
           * to remove elements from an array by predicate.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...*} [values] The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pull(array, 'a', 'c');
           * console.log(array);
           * // => ['b', 'b']
           */
          var pull = baseRest(pullAll);

          /**
           * This method is like `_.pull` except that it accepts an array of values to remove.
           *
           * **Note:** Unlike `_.difference`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
           *
           * _.pullAll(array, ['a', 'c']);
           * console.log(array);
           * // => ['b', 'b']
           */
          function pullAll(array, values) {
            return array && array.length && values && values.length ? basePullAll(array, values) : array;
          }

          /**
           * This method is like `_.pullAll` except that it accepts `iteratee` which is
           * invoked for each element of `array` and `values` to generate the criterion
           * by which they're compared. The iteratee is invoked with one argument: (value).
           *
           * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
           *
           * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
           * console.log(array);
           * // => [{ 'x': 2 }]
           */
          function pullAllBy(array, values, iteratee) {
            return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array;
          }

          /**
           * This method is like `_.pullAll` except that it accepts `comparator` which
           * is invoked to compare elements of `array` to `values`. The comparator is
           * invoked with two arguments: (arrVal, othVal).
           *
           * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Array} values The values to remove.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
           *
           * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
           * console.log(array);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
           */
          function pullAllWith(array, values, comparator) {
            return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array;
          }

          /**
           * Removes elements from `array` corresponding to `indexes` and returns an
           * array of removed elements.
           *
           * **Note:** Unlike `_.at`, this method mutates `array`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {...(number|number[])} [indexes] The indexes of elements to remove.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = ['a', 'b', 'c', 'd'];
           * var pulled = _.pullAt(array, [1, 3]);
           *
           * console.log(array);
           * // => ['a', 'c']
           *
           * console.log(pulled);
           * // => ['b', 'd']
           */
          var pullAt = flatRest(function (array, indexes) {
            var length = array == null ? 0 : array.length,
              result = baseAt(array, indexes);
            basePullAt(array, arrayMap(indexes, function (index) {
              return isIndex(index, length) ? +index : index;
            }).sort(compareAscending));
            return result;
          });

          /**
           * Removes all elements from `array` that `predicate` returns truthy for
           * and returns an array of the removed elements. The predicate is invoked
           * with three arguments: (value, index, array).
           *
           * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
           * to pull elements from an array by value.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new array of removed elements.
           * @example
           *
           * var array = [1, 2, 3, 4];
           * var evens = _.remove(array, function(n) {
           *   return n % 2 == 0;
           * });
           *
           * console.log(array);
           * // => [1, 3]
           *
           * console.log(evens);
           * // => [2, 4]
           */
          function remove(array, predicate) {
            var result = [];
            if (!(array && array.length)) {
              return result;
            }
            var index = -1,
              indexes = [],
              length = array.length;
            predicate = getIteratee(predicate, 3);
            while (++index < length) {
              var value = array[index];
              if (predicate(value, index, array)) {
                result.push(value);
                indexes.push(index);
              }
            }
            basePullAt(array, indexes);
            return result;
          }

          /**
           * Reverses `array` so that the first element becomes the last, the second
           * element becomes the second to last, and so on.
           *
           * **Note:** This method mutates `array` and is based on
           * [`Array#reverse`](https://mdn.io/Array/reverse).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to modify.
           * @returns {Array} Returns `array`.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _.reverse(array);
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function reverse(array) {
            return array == null ? array : nativeReverse.call(array);
          }

          /**
           * Creates a slice of `array` from `start` up to, but not including, `end`.
           *
           * **Note:** This method is used instead of
           * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
           * returned.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to slice.
           * @param {number} [start=0] The start position.
           * @param {number} [end=array.length] The end position.
           * @returns {Array} Returns the slice of `array`.
           */
          function slice(array, start, end) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
              start = 0;
              end = length;
            } else {
              start = start == null ? 0 : toInteger(start);
              end = end === undefined ? length : toInteger(end);
            }
            return baseSlice(array, start, end);
          }

          /**
           * Uses a binary search to determine the lowest index at which `value`
           * should be inserted into `array` in order to maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedIndex([30, 50], 40);
           * // => 1
           */
          function sortedIndex(array, value) {
            return baseSortedIndex(array, value);
          }

          /**
           * This method is like `_.sortedIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 0
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
           * // => 0
           */
          function sortedIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
          }

          /**
           * This method is like `_.indexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
           * // => 1
           */
          function sortedIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value);
              if (index < length && eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }

          /**
           * This method is like `_.sortedIndex` except that it returns the highest
           * index at which `value` should be inserted into `array` in order to
           * maintain its sort order.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
           * // => 4
           */
          function sortedLastIndex(array, value) {
            return baseSortedIndex(array, value, true);
          }

          /**
           * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
           * which is invoked for `value` and each element of `array` to compute their
           * sort ranking. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The sorted array to inspect.
           * @param {*} value The value to evaluate.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the index at which `value` should be inserted
           *  into `array`.
           * @example
           *
           * var objects = [{ 'x': 4 }, { 'x': 5 }];
           *
           * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
           * // => 1
           *
           * // The `_.property` iteratee shorthand.
           * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
           * // => 1
           */
          function sortedLastIndexBy(array, value, iteratee) {
            return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
          }

          /**
           * This method is like `_.lastIndexOf` except that it performs a binary
           * search on a sorted `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {*} value The value to search for.
           * @returns {number} Returns the index of the matched value, else `-1`.
           * @example
           *
           * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
           * // => 3
           */
          function sortedLastIndexOf(array, value) {
            var length = array == null ? 0 : array.length;
            if (length) {
              var index = baseSortedIndex(array, value, true) - 1;
              if (eq(array[index], value)) {
                return index;
              }
            }
            return -1;
          }

          /**
           * This method is like `_.uniq` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniq([1, 1, 2]);
           * // => [1, 2]
           */
          function sortedUniq(array) {
            return array && array.length ? baseSortedUniq(array) : [];
          }

          /**
           * This method is like `_.uniqBy` except that it's designed and optimized
           * for sorted arrays.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
           * // => [1.1, 2.3]
           */
          function sortedUniqBy(array, iteratee) {
            return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : [];
          }

          /**
           * Gets all but the first element of `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.tail([1, 2, 3]);
           * // => [2, 3]
           */
          function tail(array) {
            var length = array == null ? 0 : array.length;
            return length ? baseSlice(array, 1, length) : [];
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the beginning.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.take([1, 2, 3]);
           * // => [1]
           *
           * _.take([1, 2, 3], 2);
           * // => [1, 2]
           *
           * _.take([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.take([1, 2, 3], 0);
           * // => []
           */
          function take(array, n, guard) {
            if (!(array && array.length)) {
              return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            return baseSlice(array, 0, n < 0 ? 0 : n);
          }

          /**
           * Creates a slice of `array` with `n` elements taken from the end.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {number} [n=1] The number of elements to take.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * _.takeRight([1, 2, 3]);
           * // => [3]
           *
           * _.takeRight([1, 2, 3], 2);
           * // => [2, 3]
           *
           * _.takeRight([1, 2, 3], 5);
           * // => [1, 2, 3]
           *
           * _.takeRight([1, 2, 3], 0);
           * // => []
           */
          function takeRight(array, n, guard) {
            var length = array == null ? 0 : array.length;
            if (!length) {
              return [];
            }
            n = guard || n === undefined ? 1 : toInteger(n);
            n = length - n;
            return baseSlice(array, n < 0 ? 0 : n, length);
          }

          /**
           * Creates a slice of `array` with elements taken from the end. Elements are
           * taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': true },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': false }
           * ];
           *
           * _.takeRightWhile(users, function(o) { return !o.active; });
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
           * // => objects for ['pebbles']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeRightWhile(users, ['active', false]);
           * // => objects for ['fred', 'pebbles']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeRightWhile(users, 'active');
           * // => []
           */
          function takeRightWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
          }

          /**
           * Creates a slice of `array` with elements taken from the beginning. Elements
           * are taken until `predicate` returns falsey. The predicate is invoked with
           * three arguments: (value, index, array).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Array
           * @param {Array} array The array to query.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the slice of `array`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'active': false },
           *   { 'user': 'fred',    'active': false },
           *   { 'user': 'pebbles', 'active': true }
           * ];
           *
           * _.takeWhile(users, function(o) { return !o.active; });
           * // => objects for ['barney', 'fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.takeWhile(users, { 'user': 'barney', 'active': false });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.takeWhile(users, ['active', false]);
           * // => objects for ['barney', 'fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.takeWhile(users, 'active');
           * // => []
           */
          function takeWhile(array, predicate) {
            return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
          }

          /**
           * Creates an array of unique values, in order, from all given arrays using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.union([2], [1, 2]);
           * // => [2, 1]
           */
          var union = baseRest(function (arrays) {
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
          });

          /**
           * This method is like `_.union` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which uniqueness is computed. Result values are chosen from the first
           * array in which the value occurs. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * _.unionBy([2.1], [1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          var unionBy = baseRest(function (arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
          });

          /**
           * This method is like `_.union` except that it accepts `comparator` which
           * is invoked to compare elements of `arrays`. Result values are chosen from
           * the first array in which the value occurs. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of combined values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.unionWith(objects, others, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */
          var unionWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
          });

          /**
           * Creates a duplicate-free version of an array, using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons, in which only the first occurrence of each element
           * is kept. The order of result values is determined by the order they occur
           * in the array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniq([2, 1, 2]);
           * // => [2, 1]
           */
          function uniq(array) {
            return array && array.length ? baseUniq(array) : [];
          }

          /**
           * This method is like `_.uniq` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * uniqueness is computed. The order of result values is determined by the
           * order they occur in the array. The iteratee is invoked with one argument:
           * (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
           * // => [2.1, 1.2]
           *
           * // The `_.property` iteratee shorthand.
           * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 1 }, { 'x': 2 }]
           */
          function uniqBy(array, iteratee) {
            return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : [];
          }

          /**
           * This method is like `_.uniq` except that it accepts `comparator` which
           * is invoked to compare elements of `array`. The order of result values is
           * determined by the order they occur in the array.The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new duplicate free array.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.uniqWith(objects, _.isEqual);
           * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
           */
          function uniqWith(array, comparator) {
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return array && array.length ? baseUniq(array, undefined, comparator) : [];
          }

          /**
           * This method is like `_.zip` except that it accepts an array of grouped
           * elements and creates an array regrouping the elements to their pre-zip
           * configuration.
           *
           * @static
           * @memberOf _
           * @since 1.2.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           *
           * _.unzip(zipped);
           * // => [['a', 'b'], [1, 2], [true, false]]
           */
          function unzip(array) {
            if (!(array && array.length)) {
              return [];
            }
            var length = 0;
            array = arrayFilter(array, function (group) {
              if (isArrayLikeObject(group)) {
                length = nativeMax(group.length, length);
                return true;
              }
            });
            return baseTimes(length, function (index) {
              return arrayMap(array, baseProperty(index));
            });
          }

          /**
           * This method is like `_.unzip` except that it accepts `iteratee` to specify
           * how regrouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {Array} array The array of grouped elements to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  regrouped values.
           * @returns {Array} Returns the new array of regrouped elements.
           * @example
           *
           * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
           * // => [[1, 10, 100], [2, 20, 200]]
           *
           * _.unzipWith(zipped, _.add);
           * // => [3, 30, 300]
           */
          function unzipWith(array, iteratee) {
            if (!(array && array.length)) {
              return [];
            }
            var result = unzip(array);
            if (iteratee == null) {
              return result;
            }
            return arrayMap(result, function (group) {
              return apply(iteratee, undefined, group);
            });
          }

          /**
           * Creates an array excluding all given values using
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * for equality comparisons.
           *
           * **Note:** Unlike `_.pull`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {Array} array The array to inspect.
           * @param {...*} [values] The values to exclude.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.xor
           * @example
           *
           * _.without([2, 1, 2, 3], 1, 2);
           * // => [3]
           */
          var without = baseRest(function (array, values) {
            return isArrayLikeObject(array) ? baseDifference(array, values) : [];
          });

          /**
           * Creates an array of unique values that is the
           * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
           * of the given arrays. The order of result values is determined by the order
           * they occur in the arrays.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @returns {Array} Returns the new array of filtered values.
           * @see _.difference, _.without
           * @example
           *
           * _.xor([2, 1], [2, 3]);
           * // => [1, 3]
           */
          var xor = baseRest(function (arrays) {
            return baseXor(arrayFilter(arrays, isArrayLikeObject));
          });

          /**
           * This method is like `_.xor` except that it accepts `iteratee` which is
           * invoked for each element of each `arrays` to generate the criterion by
           * which by which they're compared. The order of result values is determined
           * by the order they occur in the arrays. The iteratee is invoked with one
           * argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
           * // => [1.2, 3.4]
           *
           * // The `_.property` iteratee shorthand.
           * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
           * // => [{ 'x': 2 }]
           */
          var xorBy = baseRest(function (arrays) {
            var iteratee = last(arrays);
            if (isArrayLikeObject(iteratee)) {
              iteratee = undefined;
            }
            return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
          });

          /**
           * This method is like `_.xor` except that it accepts `comparator` which is
           * invoked to compare elements of `arrays`. The order of result values is
           * determined by the order they occur in the arrays. The comparator is invoked
           * with two arguments: (arrVal, othVal).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Array
           * @param {...Array} [arrays] The arrays to inspect.
           * @param {Function} [comparator] The comparator invoked per element.
           * @returns {Array} Returns the new array of filtered values.
           * @example
           *
           * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
           * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
           *
           * _.xorWith(objects, others, _.isEqual);
           * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
           */
          var xorWith = baseRest(function (arrays) {
            var comparator = last(arrays);
            comparator = typeof comparator == 'function' ? comparator : undefined;
            return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
          });

          /**
           * Creates an array of grouped elements, the first of which contains the
           * first elements of the given arrays, the second of which contains the
           * second elements of the given arrays, and so on.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zip(['a', 'b'], [1, 2], [true, false]);
           * // => [['a', 1, true], ['b', 2, false]]
           */
          var zip = baseRest(unzip);

          /**
           * This method is like `_.fromPairs` except that it accepts two arrays,
           * one of property identifiers and one of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 0.4.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObject(['a', 'b'], [1, 2]);
           * // => { 'a': 1, 'b': 2 }
           */
          function zipObject(props, values) {
            return baseZipObject(props || [], values || [], assignValue);
          }

          /**
           * This method is like `_.zipObject` except that it supports property paths.
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Array
           * @param {Array} [props=[]] The property identifiers.
           * @param {Array} [values=[]] The property values.
           * @returns {Object} Returns the new object.
           * @example
           *
           * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
           * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
           */
          function zipObjectDeep(props, values) {
            return baseZipObject(props || [], values || [], baseSet);
          }

          /**
           * This method is like `_.zip` except that it accepts `iteratee` to specify
           * how grouped values should be combined. The iteratee is invoked with the
           * elements of each group: (...group).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Array
           * @param {...Array} [arrays] The arrays to process.
           * @param {Function} [iteratee=_.identity] The function to combine
           *  grouped values.
           * @returns {Array} Returns the new array of grouped elements.
           * @example
           *
           * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
           *   return a + b + c;
           * });
           * // => [111, 222]
           */
          var zipWith = baseRest(function (arrays) {
            var length = arrays.length,
              iteratee = length > 1 ? arrays[length - 1] : undefined;
            iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
            return unzipWith(arrays, iteratee);
          });

          /*------------------------------------------------------------------------*/

          /**
           * Creates a `lodash` wrapper instance that wraps `value` with explicit method
           * chain sequences enabled. The result of such sequences must be unwrapped
           * with `_#value`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Seq
           * @param {*} value The value to wrap.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36 },
           *   { 'user': 'fred',    'age': 40 },
           *   { 'user': 'pebbles', 'age': 1 }
           * ];
           *
           * var youngest = _
           *   .chain(users)
           *   .sortBy('age')
           *   .map(function(o) {
           *     return o.user + ' is ' + o.age;
           *   })
           *   .head()
           *   .value();
           * // => 'pebbles is 1'
           */
          function chain(value) {
            var result = lodash(value);
            result.__chain__ = true;
            return result;
          }

          /**
           * This method invokes `interceptor` and returns `value`. The interceptor
           * is invoked with one argument; (value). The purpose of this method is to
           * "tap into" a method chain sequence in order to modify intermediate results.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns `value`.
           * @example
           *
           * _([1, 2, 3])
           *  .tap(function(array) {
           *    // Mutate input array.
           *    array.pop();
           *  })
           *  .reverse()
           *  .value();
           * // => [2, 1]
           */
          function tap(value, interceptor) {
            interceptor(value);
            return value;
          }

          /**
           * This method is like `_.tap` except that it returns the result of `interceptor`.
           * The purpose of this method is to "pass thru" values replacing intermediate
           * results in a method chain sequence.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Seq
           * @param {*} value The value to provide to `interceptor`.
           * @param {Function} interceptor The function to invoke.
           * @returns {*} Returns the result of `interceptor`.
           * @example
           *
           * _('  abc  ')
           *  .chain()
           *  .trim()
           *  .thru(function(value) {
           *    return [value];
           *  })
           *  .value();
           * // => ['abc']
           */
          function thru(value, interceptor) {
            return interceptor(value);
          }

          /**
           * This method is the wrapper version of `_.at`.
           *
           * @name at
           * @memberOf _
           * @since 1.0.0
           * @category Seq
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _(object).at(['a[0].b.c', 'a[1]']).value();
           * // => [3, 4]
           */
          var wrapperAt = flatRest(function (paths) {
            var length = paths.length,
              start = length ? paths[0] : 0,
              value = this.__wrapped__,
              interceptor = function interceptor(object) {
                return baseAt(object, paths);
              };
            if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
              return this.thru(interceptor);
            }
            value = value.slice(start, +start + (length ? 1 : 0));
            value.__actions__.push({
              'func': thru,
              'args': [interceptor],
              'thisArg': undefined
            });
            return new LodashWrapper(value, this.__chain__).thru(function (array) {
              if (length && !array.length) {
                array.push(undefined);
              }
              return array;
            });
          });

          /**
           * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
           *
           * @name chain
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 40 }
           * ];
           *
           * // A sequence without explicit chaining.
           * _(users).head();
           * // => { 'user': 'barney', 'age': 36 }
           *
           * // A sequence with explicit chaining.
           * _(users)
           *   .chain()
           *   .head()
           *   .pick('user')
           *   .value();
           * // => { 'user': 'barney' }
           */
          function wrapperChain() {
            return chain(this);
          }

          /**
           * Executes the chain sequence and returns the wrapped result.
           *
           * @name commit
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2];
           * var wrapped = _(array).push(3);
           *
           * console.log(array);
           * // => [1, 2]
           *
           * wrapped = wrapped.commit();
           * console.log(array);
           * // => [1, 2, 3]
           *
           * wrapped.last();
           * // => 3
           *
           * console.log(array);
           * // => [1, 2, 3]
           */
          function wrapperCommit() {
            return new LodashWrapper(this.value(), this.__chain__);
          }

          /**
           * Gets the next value on a wrapped object following the
           * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
           *
           * @name next
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the next iterator value.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 1 }
           *
           * wrapped.next();
           * // => { 'done': false, 'value': 2 }
           *
           * wrapped.next();
           * // => { 'done': true, 'value': undefined }
           */
          function wrapperNext() {
            if (this.__values__ === undefined) {
              this.__values__ = toArray(this.value());
            }
            var done = this.__index__ >= this.__values__.length,
              value = done ? undefined : this.__values__[this.__index__++];
            return {
              'done': done,
              'value': value
            };
          }

          /**
           * Enables the wrapper to be iterable.
           *
           * @name Symbol.iterator
           * @memberOf _
           * @since 4.0.0
           * @category Seq
           * @returns {Object} Returns the wrapper object.
           * @example
           *
           * var wrapped = _([1, 2]);
           *
           * wrapped[Symbol.iterator]() === wrapped;
           * // => true
           *
           * Array.from(wrapped);
           * // => [1, 2]
           */
          function wrapperToIterator() {
            return this;
          }

          /**
           * Creates a clone of the chain sequence planting `value` as the wrapped value.
           *
           * @name plant
           * @memberOf _
           * @since 3.2.0
           * @category Seq
           * @param {*} value The value to plant.
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var wrapped = _([1, 2]).map(square);
           * var other = wrapped.plant([3, 4]);
           *
           * other.value();
           * // => [9, 16]
           *
           * wrapped.value();
           * // => [1, 4]
           */
          function wrapperPlant(value) {
            var result,
              parent = this;
            while (parent instanceof baseLodash) {
              var clone = wrapperClone(parent);
              clone.__index__ = 0;
              clone.__values__ = undefined;
              if (result) {
                previous.__wrapped__ = clone;
              } else {
                result = clone;
              }
              var previous = clone;
              parent = parent.__wrapped__;
            }
            previous.__wrapped__ = value;
            return result;
          }

          /**
           * This method is the wrapper version of `_.reverse`.
           *
           * **Note:** This method mutates the wrapped array.
           *
           * @name reverse
           * @memberOf _
           * @since 0.1.0
           * @category Seq
           * @returns {Object} Returns the new `lodash` wrapper instance.
           * @example
           *
           * var array = [1, 2, 3];
           *
           * _(array).reverse().value()
           * // => [3, 2, 1]
           *
           * console.log(array);
           * // => [3, 2, 1]
           */
          function wrapperReverse() {
            var value = this.__wrapped__;
            if (value instanceof LazyWrapper) {
              var wrapped = value;
              if (this.__actions__.length) {
                wrapped = new LazyWrapper(this);
              }
              wrapped = wrapped.reverse();
              wrapped.__actions__.push({
                'func': thru,
                'args': [reverse],
                'thisArg': undefined
              });
              return new LodashWrapper(wrapped, this.__chain__);
            }
            return this.thru(reverse);
          }

          /**
           * Executes the chain sequence to resolve the unwrapped value.
           *
           * @name value
           * @memberOf _
           * @since 0.1.0
           * @alias toJSON, valueOf
           * @category Seq
           * @returns {*} Returns the resolved unwrapped value.
           * @example
           *
           * _([1, 2, 3]).value();
           * // => [1, 2, 3]
           */
          function wrapperValue() {
            return baseWrapperValue(this.__wrapped__, this.__actions__);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the number of times the key was returned by `iteratee`. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.countBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': 1, '6': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.countBy(['one', 'two', 'three'], 'length');
           * // => { '3': 2, '5': 1 }
           */
          var countBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              ++result[key];
            } else {
              baseAssignValue(result, key, 1);
            }
          });

          /**
           * Checks if `predicate` returns truthy for **all** elements of `collection`.
           * Iteration is stopped once `predicate` returns falsey. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * **Note:** This method returns `true` for
           * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
           * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
           * elements of empty collections.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if all elements pass the predicate check,
           *  else `false`.
           * @example
           *
           * _.every([true, 1, null, 'yes'], Boolean);
           * // => false
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.every(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.every(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.every(users, 'active');
           * // => false
           */
          function every(collection, predicate, guard) {
            var func = isArray(collection) ? arrayEvery : baseEvery;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
          }

          /**
           * Iterates over elements of `collection`, returning an array of all elements
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * **Note:** Unlike `_.remove`, this method returns a new array.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.reject
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * _.filter(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, { 'age': 36, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.filter(users, 'active');
           * // => objects for ['barney']
           *
           * // Combining several predicates using `_.overEvery` or `_.overSome`.
           * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
           * // => objects for ['fred', 'barney']
           */
          function filter(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, getIteratee(predicate, 3));
          }

          /**
           * Iterates over elements of `collection`, returning the first element
           * `predicate` returns truthy for. The predicate is invoked with three
           * arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=0] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': true },
           *   { 'user': 'fred',    'age': 40, 'active': false },
           *   { 'user': 'pebbles', 'age': 1,  'active': true }
           * ];
           *
           * _.find(users, function(o) { return o.age < 40; });
           * // => object for 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.find(users, { 'age': 1, 'active': true });
           * // => object for 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.find(users, ['active', false]);
           * // => object for 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.find(users, 'active');
           * // => object for 'barney'
           */
          var find = createFind(findIndex);

          /**
           * This method is like `_.find` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param {number} [fromIndex=collection.length-1] The index to search from.
           * @returns {*} Returns the matched element, else `undefined`.
           * @example
           *
           * _.findLast([1, 2, 3, 4], function(n) {
           *   return n % 2 == 1;
           * });
           * // => 3
           */
          var findLast = createFind(findLastIndex);

          /**
           * Creates a flattened array of values by running each element in `collection`
           * thru `iteratee` and flattening the mapped results. The iteratee is invoked
           * with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [n, n];
           * }
           *
           * _.flatMap([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */
          function flatMap(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), 1);
          }

          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDeep([1, 2], duplicate);
           * // => [1, 1, 2, 2]
           */
          function flatMapDeep(collection, iteratee) {
            return baseFlatten(map(collection, iteratee), INFINITY);
          }

          /**
           * This method is like `_.flatMap` except that it recursively flattens the
           * mapped results up to `depth` times.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {number} [depth=1] The maximum recursion depth.
           * @returns {Array} Returns the new flattened array.
           * @example
           *
           * function duplicate(n) {
           *   return [[[n, n]]];
           * }
           *
           * _.flatMapDepth([1, 2], duplicate, 2);
           * // => [[1, 1], [2, 2]]
           */
          function flatMapDepth(collection, iteratee, depth) {
            depth = depth === undefined ? 1 : toInteger(depth);
            return baseFlatten(map(collection, iteratee), depth);
          }

          /**
           * Iterates over elements of `collection` and invokes `iteratee` for each element.
           * The iteratee is invoked with three arguments: (value, index|key, collection).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * **Note:** As with other "Collections" methods, objects with a "length"
           * property are iterated like arrays. To avoid this behavior use `_.forIn`
           * or `_.forOwn` for object iteration.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @alias each
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEachRight
           * @example
           *
           * _.forEach([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `1` then `2`.
           *
           * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */
          function forEach(collection, iteratee) {
            var func = isArray(collection) ? arrayEach : baseEach;
            return func(collection, getIteratee(iteratee, 3));
          }

          /**
           * This method is like `_.forEach` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @alias eachRight
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array|Object} Returns `collection`.
           * @see _.forEach
           * @example
           *
           * _.forEachRight([1, 2], function(value) {
           *   console.log(value);
           * });
           * // => Logs `2` then `1`.
           */
          function forEachRight(collection, iteratee) {
            var func = isArray(collection) ? arrayEachRight : baseEachRight;
            return func(collection, getIteratee(iteratee, 3));
          }

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The order of grouped values
           * is determined by the order they occur in `collection`. The corresponding
           * value of each key is an array of elements responsible for generating the
           * key. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * _.groupBy([6.1, 4.2, 6.3], Math.floor);
           * // => { '4': [4.2], '6': [6.1, 6.3] }
           *
           * // The `_.property` iteratee shorthand.
           * _.groupBy(['one', 'two', 'three'], 'length');
           * // => { '3': ['one', 'two'], '5': ['three'] }
           */
          var groupBy = createAggregator(function (result, value, key) {
            if (hasOwnProperty.call(result, key)) {
              result[key].push(value);
            } else {
              baseAssignValue(result, key, [value]);
            }
          });

          /**
           * Checks if `value` is in `collection`. If `collection` is a string, it's
           * checked for a substring of `value`, otherwise
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * is used for equality comparisons. If `fromIndex` is negative, it's used as
           * the offset from the end of `collection`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @param {*} value The value to search for.
           * @param {number} [fromIndex=0] The index to search from.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {boolean} Returns `true` if `value` is found, else `false`.
           * @example
           *
           * _.includes([1, 2, 3], 1);
           * // => true
           *
           * _.includes([1, 2, 3], 1, 2);
           * // => false
           *
           * _.includes({ 'a': 1, 'b': 2 }, 1);
           * // => true
           *
           * _.includes('abcd', 'bc');
           * // => true
           */
          function includes(collection, value, fromIndex, guard) {
            collection = isArrayLike(collection) ? collection : values(collection);
            fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
            var length = collection.length;
            if (fromIndex < 0) {
              fromIndex = nativeMax(length + fromIndex, 0);
            }
            return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
          }

          /**
           * Invokes the method at `path` of each element in `collection`, returning
           * an array of the results of each invoked method. Any additional arguments
           * are provided to each invoked method. If `path` is a function, it's invoked
           * for, and `this` bound to, each element in `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array|Function|string} path The path of the method to invoke or
           *  the function invoked per iteration.
           * @param {...*} [args] The arguments to invoke each method with.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
           * // => [[1, 5, 7], [1, 2, 3]]
           *
           * _.invokeMap([123, 456], String.prototype.split, '');
           * // => [['1', '2', '3'], ['4', '5', '6']]
           */
          var invokeMap = baseRest(function (collection, path, args) {
            var index = -1,
              isFunc = typeof path == 'function',
              result = isArrayLike(collection) ? Array(collection.length) : [];
            baseEach(collection, function (value) {
              result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
            });
            return result;
          });

          /**
           * Creates an object composed of keys generated from the results of running
           * each element of `collection` thru `iteratee`. The corresponding value of
           * each key is the last element responsible for generating the key. The
           * iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
           * @returns {Object} Returns the composed aggregate object.
           * @example
           *
           * var array = [
           *   { 'dir': 'left', 'code': 97 },
           *   { 'dir': 'right', 'code': 100 }
           * ];
           *
           * _.keyBy(array, function(o) {
           *   return String.fromCharCode(o.code);
           * });
           * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
           *
           * _.keyBy(array, 'dir');
           * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
           */
          var keyBy = createAggregator(function (result, value, key) {
            baseAssignValue(result, key, value);
          });

          /**
           * Creates an array of values by running each element in `collection` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
           *
           * The guarded methods are:
           * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
           * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
           * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
           * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new mapped array.
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * _.map([4, 8], square);
           * // => [16, 64]
           *
           * _.map({ 'a': 4, 'b': 8 }, square);
           * // => [16, 64] (iteration order is not guaranteed)
           *
           * var users = [
           *   { 'user': 'barney' },
           *   { 'user': 'fred' }
           * ];
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, 'user');
           * // => ['barney', 'fred']
           */
          function map(collection, iteratee) {
            var func = isArray(collection) ? arrayMap : baseMap;
            return func(collection, getIteratee(iteratee, 3));
          }

          /**
           * This method is like `_.sortBy` except that it allows specifying the sort
           * orders of the iteratees to sort by. If `orders` is unspecified, all values
           * are sorted in ascending order. Otherwise, specify an order of "desc" for
           * descending or "asc" for ascending sort order of corresponding values.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @param {string[]} [orders] The sort orders of `iteratees`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 34 },
           *   { 'user': 'fred',   'age': 40 },
           *   { 'user': 'barney', 'age': 36 }
           * ];
           *
           * // Sort by `user` in ascending order and by `age` in descending order.
           * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
           */
          function orderBy(collection, iteratees, orders, guard) {
            if (collection == null) {
              return [];
            }
            if (!isArray(iteratees)) {
              iteratees = iteratees == null ? [] : [iteratees];
            }
            orders = guard ? undefined : orders;
            if (!isArray(orders)) {
              orders = orders == null ? [] : [orders];
            }
            return baseOrderBy(collection, iteratees, orders);
          }

          /**
           * Creates an array of elements split into two groups, the first of which
           * contains elements `predicate` returns truthy for, the second of which
           * contains elements `predicate` returns falsey for. The predicate is
           * invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of grouped elements.
           * @example
           *
           * var users = [
           *   { 'user': 'barney',  'age': 36, 'active': false },
           *   { 'user': 'fred',    'age': 40, 'active': true },
           *   { 'user': 'pebbles', 'age': 1,  'active': false }
           * ];
           *
           * _.partition(users, function(o) { return o.active; });
           * // => objects for [['fred'], ['barney', 'pebbles']]
           *
           * // The `_.matches` iteratee shorthand.
           * _.partition(users, { 'age': 1, 'active': false });
           * // => objects for [['pebbles'], ['barney', 'fred']]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.partition(users, ['active', false]);
           * // => objects for [['barney', 'pebbles'], ['fred']]
           *
           * // The `_.property` iteratee shorthand.
           * _.partition(users, 'active');
           * // => objects for [['fred'], ['barney', 'pebbles']]
           */
          var partition = createAggregator(function (result, value, key) {
            result[key ? 0 : 1].push(value);
          }, function () {
            return [[], []];
          });

          /**
           * Reduces `collection` to a value which is the accumulated result of running
           * each element in `collection` thru `iteratee`, where each successive
           * invocation is supplied the return value of the previous. If `accumulator`
           * is not given, the first element of `collection` is used as the initial
           * value. The iteratee is invoked with four arguments:
           * (accumulator, value, index|key, collection).
           *
           * Many lodash methods are guarded to work as iteratees for methods like
           * `_.reduce`, `_.reduceRight`, and `_.transform`.
           *
           * The guarded methods are:
           * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
           * and `sortBy`
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduceRight
           * @example
           *
           * _.reduce([1, 2], function(sum, n) {
           *   return sum + n;
           * }, 0);
           * // => 3
           *
           * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           *   return result;
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
           */
          function reduce(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduce : baseReduce,
              initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
          }

          /**
           * This method is like `_.reduce` except that it iterates over elements of
           * `collection` from right to left.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The initial value.
           * @returns {*} Returns the accumulated value.
           * @see _.reduce
           * @example
           *
           * var array = [[0, 1], [2, 3], [4, 5]];
           *
           * _.reduceRight(array, function(flattened, other) {
           *   return flattened.concat(other);
           * }, []);
           * // => [4, 5, 2, 3, 0, 1]
           */
          function reduceRight(collection, iteratee, accumulator) {
            var func = isArray(collection) ? arrayReduceRight : baseReduce,
              initAccum = arguments.length < 3;
            return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
          }

          /**
           * The opposite of `_.filter`; this method returns the elements of `collection`
           * that `predicate` does **not** return truthy for.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the new filtered array.
           * @see _.filter
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': false },
           *   { 'user': 'fred',   'age': 40, 'active': true }
           * ];
           *
           * _.reject(users, function(o) { return !o.active; });
           * // => objects for ['fred']
           *
           * // The `_.matches` iteratee shorthand.
           * _.reject(users, { 'age': 40, 'active': true });
           * // => objects for ['barney']
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.reject(users, ['active', false]);
           * // => objects for ['fred']
           *
           * // The `_.property` iteratee shorthand.
           * _.reject(users, 'active');
           * // => objects for ['barney']
           */
          function reject(collection, predicate) {
            var func = isArray(collection) ? arrayFilter : baseFilter;
            return func(collection, negate(getIteratee(predicate, 3)));
          }

          /**
           * Gets a random element from `collection`.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @returns {*} Returns the random element.
           * @example
           *
           * _.sample([1, 2, 3, 4]);
           * // => 2
           */
          function sample(collection) {
            var func = isArray(collection) ? arraySample : baseSample;
            return func(collection);
          }

          /**
           * Gets `n` random elements at unique keys from `collection` up to the
           * size of `collection`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Collection
           * @param {Array|Object} collection The collection to sample.
           * @param {number} [n=1] The number of elements to sample.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the random elements.
           * @example
           *
           * _.sampleSize([1, 2, 3], 2);
           * // => [3, 1]
           *
           * _.sampleSize([1, 2, 3], 4);
           * // => [2, 3, 1]
           */
          function sampleSize(collection, n, guard) {
            if (guard ? isIterateeCall(collection, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            var func = isArray(collection) ? arraySampleSize : baseSampleSize;
            return func(collection, n);
          }

          /**
           * Creates an array of shuffled values, using a version of the
           * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to shuffle.
           * @returns {Array} Returns the new shuffled array.
           * @example
           *
           * _.shuffle([1, 2, 3, 4]);
           * // => [4, 1, 3, 2]
           */
          function shuffle(collection) {
            var func = isArray(collection) ? arrayShuffle : baseShuffle;
            return func(collection);
          }

          /**
           * Gets the size of `collection` by returning its length for array-like
           * values or the number of own enumerable string keyed properties for objects.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object|string} collection The collection to inspect.
           * @returns {number} Returns the collection size.
           * @example
           *
           * _.size([1, 2, 3]);
           * // => 3
           *
           * _.size({ 'a': 1, 'b': 2 });
           * // => 2
           *
           * _.size('pebbles');
           * // => 7
           */
          function size(collection) {
            if (collection == null) {
              return 0;
            }
            if (isArrayLike(collection)) {
              return isString(collection) ? stringSize(collection) : collection.length;
            }
            var tag = getTag(collection);
            if (tag == mapTag || tag == setTag) {
              return collection.size;
            }
            return baseKeys(collection).length;
          }

          /**
           * Checks if `predicate` returns truthy for **any** element of `collection`.
           * Iteration is stopped once `predicate` returns truthy. The predicate is
           * invoked with three arguments: (value, index|key, collection).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {boolean} Returns `true` if any element passes the predicate check,
           *  else `false`.
           * @example
           *
           * _.some([null, 0, 'yes', false], Boolean);
           * // => true
           *
           * var users = [
           *   { 'user': 'barney', 'active': true },
           *   { 'user': 'fred',   'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.some(users, { 'user': 'barney', 'active': false });
           * // => false
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.some(users, ['active', false]);
           * // => true
           *
           * // The `_.property` iteratee shorthand.
           * _.some(users, 'active');
           * // => true
           */
          function some(collection, predicate, guard) {
            var func = isArray(collection) ? arraySome : baseSome;
            if (guard && isIterateeCall(collection, predicate, guard)) {
              predicate = undefined;
            }
            return func(collection, getIteratee(predicate, 3));
          }

          /**
           * Creates an array of elements, sorted in ascending order by the results of
           * running each element in a collection thru each iteratee. This method
           * performs a stable sort, that is, it preserves the original sort order of
           * equal elements. The iteratees are invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Collection
           * @param {Array|Object} collection The collection to iterate over.
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to sort by.
           * @returns {Array} Returns the new sorted array.
           * @example
           *
           * var users = [
           *   { 'user': 'fred',   'age': 48 },
           *   { 'user': 'barney', 'age': 36 },
           *   { 'user': 'fred',   'age': 30 },
           *   { 'user': 'barney', 'age': 34 }
           * ];
           *
           * _.sortBy(users, [function(o) { return o.user; }]);
           * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
           *
           * _.sortBy(users, ['user', 'age']);
           * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
           */
          var sortBy = baseRest(function (collection, iteratees) {
            if (collection == null) {
              return [];
            }
            var length = iteratees.length;
            if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
              iteratees = [];
            } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
              iteratees = [iteratees[0]];
            }
            return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
          });

          /*------------------------------------------------------------------------*/

          /**
           * Gets the timestamp of the number of milliseconds that have elapsed since
           * the Unix epoch (1 January 1970 00:00:00 UTC).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Date
           * @returns {number} Returns the timestamp.
           * @example
           *
           * _.defer(function(stamp) {
           *   console.log(_.now() - stamp);
           * }, _.now());
           * // => Logs the number of milliseconds it took for the deferred invocation.
           */
          var now = ctxNow || function () {
            return root.Date.now();
          };

          /*------------------------------------------------------------------------*/

          /**
           * The opposite of `_.before`; this method creates a function that invokes
           * `func` once it's called `n` or more times.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {number} n The number of calls before `func` is invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var saves = ['profile', 'settings'];
           *
           * var done = _.after(saves.length, function() {
           *   console.log('done saving!');
           * });
           *
           * _.forEach(saves, function(type) {
           *   asyncSave({ 'type': type, 'complete': done });
           * });
           * // => Logs 'done saving!' after the two async saves have completed.
           */
          function after(n, func) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function () {
              if (--n < 1) {
                return func.apply(this, arguments);
              }
            };
          }

          /**
           * Creates a function that invokes `func`, with up to `n` arguments,
           * ignoring any additional arguments.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @param {number} [n=func.length] The arity cap.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.ary(parseInt, 1));
           * // => [6, 8, 10]
           */
          function ary(func, n, guard) {
            n = guard ? undefined : n;
            n = func && n == null ? func.length : n;
            return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
          }

          /**
           * Creates a function that invokes `func`, with the `this` binding and arguments
           * of the created function, while it's called less than `n` times. Subsequent
           * calls to the created function return the result of the last `func` invocation.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {number} n The number of calls at which `func` is no longer invoked.
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * jQuery(element).on('click', _.before(5, addContactToList));
           * // => Allows adding up to 4 contacts to the list.
           */
          function before(n, func) {
            var result;
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            n = toInteger(n);
            return function () {
              if (--n > 0) {
                result = func.apply(this, arguments);
              }
              if (n <= 1) {
                func = undefined;
              }
              return result;
            };
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of `thisArg`
           * and `partials` prepended to the arguments it receives.
           *
           * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for partially applied arguments.
           *
           * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
           * property of bound functions.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to bind.
           * @param {*} thisArg The `this` binding of `func`.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * function greet(greeting, punctuation) {
           *   return greeting + ' ' + this.user + punctuation;
           * }
           *
           * var object = { 'user': 'fred' };
           *
           * var bound = _.bind(greet, object, 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bind(greet, object, _, '!');
           * bound('hi');
           * // => 'hi fred!'
           */
          var bind = baseRest(function (func, thisArg, partials) {
            var bitmask = WRAP_BIND_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bind));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(func, bitmask, thisArg, partials, holders);
          });

          /**
           * Creates a function that invokes the method at `object[key]` with `partials`
           * prepended to the arguments it receives.
           *
           * This method differs from `_.bind` by allowing bound functions to reference
           * methods that may be redefined or don't yet exist. See
           * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
           * for more details.
           *
           * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Function
           * @param {Object} object The object to invoke the method on.
           * @param {string} key The key of the method.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new bound function.
           * @example
           *
           * var object = {
           *   'user': 'fred',
           *   'greet': function(greeting, punctuation) {
           *     return greeting + ' ' + this.user + punctuation;
           *   }
           * };
           *
           * var bound = _.bindKey(object, 'greet', 'hi');
           * bound('!');
           * // => 'hi fred!'
           *
           * object.greet = function(greeting, punctuation) {
           *   return greeting + 'ya ' + this.user + punctuation;
           * };
           *
           * bound('!');
           * // => 'hiya fred!'
           *
           * // Bound with placeholders.
           * var bound = _.bindKey(object, 'greet', _, '!');
           * bound('hi');
           * // => 'hiya fred!'
           */
          var bindKey = baseRest(function (object, key, partials) {
            var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
            if (partials.length) {
              var holders = replaceHolders(partials, getHolder(bindKey));
              bitmask |= WRAP_PARTIAL_FLAG;
            }
            return createWrap(key, bitmask, object, partials, holders);
          });

          /**
           * Creates a function that accepts arguments of `func` and either invokes
           * `func` returning its result, if at least `arity` number of arguments have
           * been provided, or returns a function that accepts the remaining `func`
           * arguments, and so on. The arity of `func` may be specified if `func.length`
           * is not sufficient.
           *
           * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
           * may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curry(abc);
           *
           * curried(1)(2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2)(3);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(1)(_, 3)(2);
           * // => [1, 2, 3]
           */
          function curry(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curry.placeholder;
            return result;
          }

          /**
           * This method is like `_.curry` except that arguments are applied to `func`
           * in the manner of `_.partialRight` instead of `_.partial`.
           *
           * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for provided arguments.
           *
           * **Note:** This method doesn't set the "length" property of curried functions.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to curry.
           * @param {number} [arity=func.length] The arity of `func`.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the new curried function.
           * @example
           *
           * var abc = function(a, b, c) {
           *   return [a, b, c];
           * };
           *
           * var curried = _.curryRight(abc);
           *
           * curried(3)(2)(1);
           * // => [1, 2, 3]
           *
           * curried(2, 3)(1);
           * // => [1, 2, 3]
           *
           * curried(1, 2, 3);
           * // => [1, 2, 3]
           *
           * // Curried with placeholders.
           * curried(3)(1, _)(2);
           * // => [1, 2, 3]
           */
          function curryRight(func, arity, guard) {
            arity = guard ? undefined : arity;
            var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
            result.placeholder = curryRight.placeholder;
            return result;
          }

          /**
           * Creates a debounced function that delays invoking `func` until after `wait`
           * milliseconds have elapsed since the last time the debounced function was
           * invoked. The debounced function comes with a `cancel` method to cancel
           * delayed `func` invocations and a `flush` method to immediately invoke them.
           * Provide `options` to indicate whether `func` should be invoked on the
           * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
           * with the last arguments provided to the debounced function. Subsequent
           * calls to the debounced function return the result of the last `func`
           * invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the debounced function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.debounce` and `_.throttle`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to debounce.
           * @param {number} [wait=0] The number of milliseconds to delay.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=false]
           *  Specify invoking on the leading edge of the timeout.
           * @param {number} [options.maxWait]
           *  The maximum time `func` is allowed to be delayed before it's invoked.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new debounced function.
           * @example
           *
           * // Avoid costly calculations while the window size is in flux.
           * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
           *
           * // Invoke `sendMail` when clicked, debouncing subsequent calls.
           * jQuery(element).on('click', _.debounce(sendMail, 300, {
           *   'leading': true,
           *   'trailing': false
           * }));
           *
           * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
           * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
           * var source = new EventSource('/stream');
           * jQuery(source).on('message', debounced);
           *
           * // Cancel the trailing debounced invocation.
           * jQuery(window).on('popstate', debounced.cancel);
           */
          function debounce(func, wait, options) {
            var lastArgs,
              lastThis,
              maxWait,
              result,
              timerId,
              lastCallTime,
              lastInvokeTime = 0,
              leading = false,
              maxing = false,
              trailing = true;
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            wait = toNumber(wait) || 0;
            if (isObject(options)) {
              leading = !!options.leading;
              maxing = 'maxWait' in options;
              maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            function invokeFunc(time) {
              var args = lastArgs,
                thisArg = lastThis;
              lastArgs = lastThis = undefined;
              lastInvokeTime = time;
              result = func.apply(thisArg, args);
              return result;
            }
            function leadingEdge(time) {
              // Reset any `maxWait` timer.
              lastInvokeTime = time;
              // Start the timer for the trailing edge.
              timerId = setTimeout(timerExpired, wait);
              // Invoke the leading edge.
              return leading ? invokeFunc(time) : result;
            }
            function remainingWait(time) {
              var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime,
                timeWaiting = wait - timeSinceLastCall;
              return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
            }
            function shouldInvoke(time) {
              var timeSinceLastCall = time - lastCallTime,
                timeSinceLastInvoke = time - lastInvokeTime;

              // Either this is the first call, activity has stopped and we're at the
              // trailing edge, the system time has gone backwards and we're treating
              // it as the trailing edge, or we've hit the `maxWait` limit.
              return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
            }
            function timerExpired() {
              var time = now();
              if (shouldInvoke(time)) {
                return trailingEdge(time);
              }
              // Restart the timer.
              timerId = setTimeout(timerExpired, remainingWait(time));
            }
            function trailingEdge(time) {
              timerId = undefined;

              // Only invoke if we have `lastArgs` which means `func` has been
              // debounced at least once.
              if (trailing && lastArgs) {
                return invokeFunc(time);
              }
              lastArgs = lastThis = undefined;
              return result;
            }
            function cancel() {
              if (timerId !== undefined) {
                clearTimeout(timerId);
              }
              lastInvokeTime = 0;
              lastArgs = lastCallTime = lastThis = timerId = undefined;
            }
            function flush() {
              return timerId === undefined ? result : trailingEdge(now());
            }
            function debounced() {
              var time = now(),
                isInvoking = shouldInvoke(time);
              lastArgs = arguments;
              lastThis = this;
              lastCallTime = time;
              if (isInvoking) {
                if (timerId === undefined) {
                  return leadingEdge(lastCallTime);
                }
                if (maxing) {
                  // Handle invocations in a tight loop.
                  clearTimeout(timerId);
                  timerId = setTimeout(timerExpired, wait);
                  return invokeFunc(lastCallTime);
                }
              }
              if (timerId === undefined) {
                timerId = setTimeout(timerExpired, wait);
              }
              return result;
            }
            debounced.cancel = cancel;
            debounced.flush = flush;
            return debounced;
          }

          /**
           * Defers invoking the `func` until the current call stack has cleared. Any
           * additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to defer.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.defer(function(text) {
           *   console.log(text);
           * }, 'deferred');
           * // => Logs 'deferred' after one millisecond.
           */
          var defer = baseRest(function (func, args) {
            return baseDelay(func, 1, args);
          });

          /**
           * Invokes `func` after `wait` milliseconds. Any additional arguments are
           * provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to delay.
           * @param {number} wait The number of milliseconds to delay invocation.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {number} Returns the timer id.
           * @example
           *
           * _.delay(function(text) {
           *   console.log(text);
           * }, 1000, 'later');
           * // => Logs 'later' after one second.
           */
          var delay = baseRest(function (func, wait, args) {
            return baseDelay(func, toNumber(wait) || 0, args);
          });

          /**
           * Creates a function that invokes `func` with arguments reversed.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to flip arguments for.
           * @returns {Function} Returns the new flipped function.
           * @example
           *
           * var flipped = _.flip(function() {
           *   return _.toArray(arguments);
           * });
           *
           * flipped('a', 'b', 'c', 'd');
           * // => ['d', 'c', 'b', 'a']
           */
          function flip(func) {
            return createWrap(func, WRAP_FLIP_FLAG);
          }

          /**
           * Creates a function that memoizes the result of `func`. If `resolver` is
           * provided, it determines the cache key for storing the result based on the
           * arguments provided to the memoized function. By default, the first argument
           * provided to the memoized function is used as the map cache key. The `func`
           * is invoked with the `this` binding of the memoized function.
           *
           * **Note:** The cache is exposed as the `cache` property on the memoized
           * function. Its creation may be customized by replacing the `_.memoize.Cache`
           * constructor with one whose instances implement the
           * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
           * method interface of `clear`, `delete`, `get`, `has`, and `set`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to have its output memoized.
           * @param {Function} [resolver] The function to resolve the cache key.
           * @returns {Function} Returns the new memoized function.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           * var other = { 'c': 3, 'd': 4 };
           *
           * var values = _.memoize(_.values);
           * values(object);
           * // => [1, 2]
           *
           * values(other);
           * // => [3, 4]
           *
           * object.a = 2;
           * values(object);
           * // => [1, 2]
           *
           * // Modify the result cache.
           * values.cache.set(object, ['a', 'b']);
           * values(object);
           * // => ['a', 'b']
           *
           * // Replace `_.memoize.Cache`.
           * _.memoize.Cache = WeakMap;
           */
          function memoize(func, resolver) {
            if (typeof func != 'function' || resolver != null && typeof resolver != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            var memoized = function memoized() {
              var args = arguments,
                key = resolver ? resolver.apply(this, args) : args[0],
                cache = memoized.cache;
              if (cache.has(key)) {
                return cache.get(key);
              }
              var result = func.apply(this, args);
              memoized.cache = cache.set(key, result) || cache;
              return result;
            };
            memoized.cache = new (memoize.Cache || MapCache)();
            return memoized;
          }

          // Expose `MapCache`.
          memoize.Cache = MapCache;

          /**
           * Creates a function that negates the result of the predicate `func`. The
           * `func` predicate is invoked with the `this` binding and arguments of the
           * created function.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} predicate The predicate to negate.
           * @returns {Function} Returns the new negated function.
           * @example
           *
           * function isEven(n) {
           *   return n % 2 == 0;
           * }
           *
           * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
           * // => [1, 3, 5]
           */
          function negate(predicate) {
            if (typeof predicate != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            return function () {
              var args = arguments;
              switch (args.length) {
                case 0:
                  return !predicate.call(this);
                case 1:
                  return !predicate.call(this, args[0]);
                case 2:
                  return !predicate.call(this, args[0], args[1]);
                case 3:
                  return !predicate.call(this, args[0], args[1], args[2]);
              }
              return !predicate.apply(this, args);
            };
          }

          /**
           * Creates a function that is restricted to invoking `func` once. Repeat calls
           * to the function return the value of the first invocation. The `func` is
           * invoked with the `this` binding and arguments of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to restrict.
           * @returns {Function} Returns the new restricted function.
           * @example
           *
           * var initialize = _.once(createApplication);
           * initialize();
           * initialize();
           * // => `createApplication` is invoked once
           */
          function once(func) {
            return before(2, func);
          }

          /**
           * Creates a function that invokes `func` with its arguments transformed.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Function
           * @param {Function} func The function to wrap.
           * @param {...(Function|Function[])} [transforms=[_.identity]]
           *  The argument transforms.
           * @returns {Function} Returns the new function.
           * @example
           *
           * function doubled(n) {
           *   return n * 2;
           * }
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var func = _.overArgs(function(x, y) {
           *   return [x, y];
           * }, [square, doubled]);
           *
           * func(9, 3);
           * // => [81, 6]
           *
           * func(10, 5);
           * // => [100, 10]
           */
          var overArgs = castRest(function (func, transforms) {
            transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
            var funcsLength = transforms.length;
            return baseRest(function (args) {
              var index = -1,
                length = nativeMin(args.length, funcsLength);
              while (++index < length) {
                args[index] = transforms[index].call(this, args[index]);
              }
              return apply(func, this, args);
            });
          });

          /**
           * Creates a function that invokes `func` with `partials` prepended to the
           * arguments it receives. This method is like `_.bind` except it does **not**
           * alter the `this` binding.
           *
           * The `_.partial.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 0.2.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var sayHelloTo = _.partial(greet, 'hello');
           * sayHelloTo('fred');
           * // => 'hello fred'
           *
           * // Partially applied with placeholders.
           * var greetFred = _.partial(greet, _, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           */
          var partial = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partial));
            return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
          });

          /**
           * This method is like `_.partial` except that partially applied arguments
           * are appended to the arguments it receives.
           *
           * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
           * builds, may be used as a placeholder for partially applied arguments.
           *
           * **Note:** This method doesn't set the "length" property of partially
           * applied functions.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Function
           * @param {Function} func The function to partially apply arguments to.
           * @param {...*} [partials] The arguments to be partially applied.
           * @returns {Function} Returns the new partially applied function.
           * @example
           *
           * function greet(greeting, name) {
           *   return greeting + ' ' + name;
           * }
           *
           * var greetFred = _.partialRight(greet, 'fred');
           * greetFred('hi');
           * // => 'hi fred'
           *
           * // Partially applied with placeholders.
           * var sayHelloTo = _.partialRight(greet, 'hello', _);
           * sayHelloTo('fred');
           * // => 'hello fred'
           */
          var partialRight = baseRest(function (func, partials) {
            var holders = replaceHolders(partials, getHolder(partialRight));
            return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
          });

          /**
           * Creates a function that invokes `func` with arguments arranged according
           * to the specified `indexes` where the argument value at the first index is
           * provided as the first argument, the argument value at the second index is
           * provided as the second argument, and so on.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Function
           * @param {Function} func The function to rearrange arguments for.
           * @param {...(number|number[])} indexes The arranged argument indexes.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var rearged = _.rearg(function(a, b, c) {
           *   return [a, b, c];
           * }, [2, 0, 1]);
           *
           * rearged('b', 'c', 'a')
           * // => ['a', 'b', 'c']
           */
          var rearg = flatRest(function (func, indexes) {
            return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
          });

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * created function and arguments from `start` and beyond provided as
           * an array.
           *
           * **Note:** This method is based on the
           * [rest parameter](https://mdn.io/rest_parameters).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to apply a rest parameter to.
           * @param {number} [start=func.length-1] The start position of the rest parameter.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.rest(function(what, names) {
           *   return what + ' ' + _.initial(names).join(', ') +
           *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
           * });
           *
           * say('hello', 'fred', 'barney', 'pebbles');
           * // => 'hello fred, barney, & pebbles'
           */
          function rest(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = start === undefined ? start : toInteger(start);
            return baseRest(func, start);
          }

          /**
           * Creates a function that invokes `func` with the `this` binding of the
           * create function and an array of arguments much like
           * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
           *
           * **Note:** This method is based on the
           * [spread operator](https://mdn.io/spread_operator).
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Function
           * @param {Function} func The function to spread arguments over.
           * @param {number} [start=0] The start position of the spread.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var say = _.spread(function(who, what) {
           *   return who + ' says ' + what;
           * });
           *
           * say(['fred', 'hello']);
           * // => 'fred says hello'
           *
           * var numbers = Promise.all([
           *   Promise.resolve(40),
           *   Promise.resolve(36)
           * ]);
           *
           * numbers.then(_.spread(function(x, y) {
           *   return x + y;
           * }));
           * // => a Promise of 76
           */
          function spread(func, start) {
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            start = start == null ? 0 : nativeMax(toInteger(start), 0);
            return baseRest(function (args) {
              var array = args[start],
                otherArgs = castSlice(args, 0, start);
              if (array) {
                arrayPush(otherArgs, array);
              }
              return apply(func, this, otherArgs);
            });
          }

          /**
           * Creates a throttled function that only invokes `func` at most once per
           * every `wait` milliseconds. The throttled function comes with a `cancel`
           * method to cancel delayed `func` invocations and a `flush` method to
           * immediately invoke them. Provide `options` to indicate whether `func`
           * should be invoked on the leading and/or trailing edge of the `wait`
           * timeout. The `func` is invoked with the last arguments provided to the
           * throttled function. Subsequent calls to the throttled function return the
           * result of the last `func` invocation.
           *
           * **Note:** If `leading` and `trailing` options are `true`, `func` is
           * invoked on the trailing edge of the timeout only if the throttled function
           * is invoked more than once during the `wait` timeout.
           *
           * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
           * until to the next tick, similar to `setTimeout` with a timeout of `0`.
           *
           * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
           * for details over the differences between `_.throttle` and `_.debounce`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {Function} func The function to throttle.
           * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.leading=true]
           *  Specify invoking on the leading edge of the timeout.
           * @param {boolean} [options.trailing=true]
           *  Specify invoking on the trailing edge of the timeout.
           * @returns {Function} Returns the new throttled function.
           * @example
           *
           * // Avoid excessively updating the position while scrolling.
           * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
           *
           * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
           * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
           * jQuery(element).on('click', throttled);
           *
           * // Cancel the trailing throttled invocation.
           * jQuery(window).on('popstate', throttled.cancel);
           */
          function throttle(func, wait, options) {
            var leading = true,
              trailing = true;
            if (typeof func != 'function') {
              throw new TypeError(FUNC_ERROR_TEXT);
            }
            if (isObject(options)) {
              leading = 'leading' in options ? !!options.leading : leading;
              trailing = 'trailing' in options ? !!options.trailing : trailing;
            }
            return debounce(func, wait, {
              'leading': leading,
              'maxWait': wait,
              'trailing': trailing
            });
          }

          /**
           * Creates a function that accepts up to one argument, ignoring any
           * additional arguments.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Function
           * @param {Function} func The function to cap arguments for.
           * @returns {Function} Returns the new capped function.
           * @example
           *
           * _.map(['6', '8', '10'], _.unary(parseInt));
           * // => [6, 8, 10]
           */
          function unary(func) {
            return ary(func, 1);
          }

          /**
           * Creates a function that provides `value` to `wrapper` as its first
           * argument. Any additional arguments provided to the function are appended
           * to those provided to the `wrapper`. The wrapper is invoked with the `this`
           * binding of the created function.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Function
           * @param {*} value The value to wrap.
           * @param {Function} [wrapper=identity] The wrapper function.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var p = _.wrap(_.escape, function(func, text) {
           *   return '<p>' + func(text) + '</p>';
           * });
           *
           * p('fred, barney, & pebbles');
           * // => '<p>fred, barney, &amp; pebbles</p>'
           */
          function wrap(value, wrapper) {
            return partial(castFunction(wrapper), value);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Casts `value` as an array if it's not one.
           *
           * @static
           * @memberOf _
           * @since 4.4.0
           * @category Lang
           * @param {*} value The value to inspect.
           * @returns {Array} Returns the cast array.
           * @example
           *
           * _.castArray(1);
           * // => [1]
           *
           * _.castArray({ 'a': 1 });
           * // => [{ 'a': 1 }]
           *
           * _.castArray('abc');
           * // => ['abc']
           *
           * _.castArray(null);
           * // => [null]
           *
           * _.castArray(undefined);
           * // => [undefined]
           *
           * _.castArray();
           * // => []
           *
           * var array = [1, 2, 3];
           * console.log(_.castArray(array) === array);
           * // => true
           */
          function castArray() {
            if (!arguments.length) {
              return [];
            }
            var value = arguments[0];
            return isArray(value) ? value : [value];
          }

          /**
           * Creates a shallow clone of `value`.
           *
           * **Note:** This method is loosely based on the
           * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
           * and supports cloning arrays, array buffers, booleans, date objects, maps,
           * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
           * arrays. The own enumerable properties of `arguments` objects are cloned
           * as plain objects. An empty object is returned for uncloneable values such
           * as error objects, functions, DOM nodes, and WeakMaps.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to clone.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeep
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var shallow = _.clone(objects);
           * console.log(shallow[0] === objects[0]);
           * // => true
           */
          function clone(value) {
            return baseClone(value, CLONE_SYMBOLS_FLAG);
          }

          /**
           * This method is like `_.clone` except that it accepts `customizer` which
           * is invoked to produce the cloned value. If `customizer` returns `undefined`,
           * cloning is handled by the method instead. The `customizer` is invoked with
           * up to four arguments; (value [, index|key, object, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the cloned value.
           * @see _.cloneDeepWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(false);
           *   }
           * }
           *
           * var el = _.cloneWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 0
           */
          function cloneWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
          }

          /**
           * This method is like `_.clone` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @returns {*} Returns the deep cloned value.
           * @see _.clone
           * @example
           *
           * var objects = [{ 'a': 1 }, { 'b': 2 }];
           *
           * var deep = _.cloneDeep(objects);
           * console.log(deep[0] === objects[0]);
           * // => false
           */
          function cloneDeep(value) {
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
          }

          /**
           * This method is like `_.cloneWith` except that it recursively clones `value`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to recursively clone.
           * @param {Function} [customizer] The function to customize cloning.
           * @returns {*} Returns the deep cloned value.
           * @see _.cloneWith
           * @example
           *
           * function customizer(value) {
           *   if (_.isElement(value)) {
           *     return value.cloneNode(true);
           *   }
           * }
           *
           * var el = _.cloneDeepWith(document.body, customizer);
           *
           * console.log(el === document.body);
           * // => false
           * console.log(el.nodeName);
           * // => 'BODY'
           * console.log(el.childNodes.length);
           * // => 20
           */
          function cloneDeepWith(value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
          }

          /**
           * Checks if `object` conforms to `source` by invoking the predicate
           * properties of `source` with the corresponding property values of `object`.
           *
           * **Note:** This method is equivalent to `_.conforms` when `source` is
           * partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property predicates to conform to.
           * @returns {boolean} Returns `true` if `object` conforms, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
           * // => true
           *
           * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
           * // => false
           */
          function conformsTo(object, source) {
            return source == null || baseConformsTo(object, source, keys(source));
          }

          /**
           * Performs a
           * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
           * comparison between two values to determine if they are equivalent.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.eq(object, object);
           * // => true
           *
           * _.eq(object, other);
           * // => false
           *
           * _.eq('a', 'a');
           * // => true
           *
           * _.eq('a', Object('a'));
           * // => false
           *
           * _.eq(NaN, NaN);
           * // => true
           */
          function eq(value, other) {
            return value === other || value !== value && other !== other;
          }

          /**
           * Checks if `value` is greater than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than `other`,
           *  else `false`.
           * @see _.lt
           * @example
           *
           * _.gt(3, 1);
           * // => true
           *
           * _.gt(3, 3);
           * // => false
           *
           * _.gt(1, 3);
           * // => false
           */
          var gt = createRelationalOperation(baseGt);

          /**
           * Checks if `value` is greater than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is greater than or equal to
           *  `other`, else `false`.
           * @see _.lte
           * @example
           *
           * _.gte(3, 1);
           * // => true
           *
           * _.gte(3, 3);
           * // => true
           *
           * _.gte(1, 3);
           * // => false
           */
          var gte = createRelationalOperation(function (value, other) {
            return value >= other;
          });

          /**
           * Checks if `value` is likely an `arguments` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an `arguments` object,
           *  else `false`.
           * @example
           *
           * _.isArguments(function() { return arguments; }());
           * // => true
           *
           * _.isArguments([1, 2, 3]);
           * // => false
           */
          var isArguments = baseIsArguments(function () {
            return arguments;
          }()) ? baseIsArguments : function (value) {
            return isObjectLike(value) && hasOwnProperty.call(value, 'callee') && !propertyIsEnumerable.call(value, 'callee');
          };

          /**
           * Checks if `value` is classified as an `Array` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array, else `false`.
           * @example
           *
           * _.isArray([1, 2, 3]);
           * // => true
           *
           * _.isArray(document.body.children);
           * // => false
           *
           * _.isArray('abc');
           * // => false
           *
           * _.isArray(_.noop);
           * // => false
           */
          var isArray = Array.isArray;

          /**
           * Checks if `value` is classified as an `ArrayBuffer` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
           * @example
           *
           * _.isArrayBuffer(new ArrayBuffer(2));
           * // => true
           *
           * _.isArrayBuffer(new Array(2));
           * // => false
           */
          var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

          /**
           * Checks if `value` is array-like. A value is considered array-like if it's
           * not a function and has a `value.length` that's an integer greater than or
           * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
           * @example
           *
           * _.isArrayLike([1, 2, 3]);
           * // => true
           *
           * _.isArrayLike(document.body.children);
           * // => true
           *
           * _.isArrayLike('abc');
           * // => true
           *
           * _.isArrayLike(_.noop);
           * // => false
           */
          function isArrayLike(value) {
            return value != null && isLength(value.length) && !isFunction(value);
          }

          /**
           * This method is like `_.isArrayLike` except that it also checks if `value`
           * is an object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an array-like object,
           *  else `false`.
           * @example
           *
           * _.isArrayLikeObject([1, 2, 3]);
           * // => true
           *
           * _.isArrayLikeObject(document.body.children);
           * // => true
           *
           * _.isArrayLikeObject('abc');
           * // => false
           *
           * _.isArrayLikeObject(_.noop);
           * // => false
           */
          function isArrayLikeObject(value) {
            return isObjectLike(value) && isArrayLike(value);
          }

          /**
           * Checks if `value` is classified as a boolean primitive or object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
           * @example
           *
           * _.isBoolean(false);
           * // => true
           *
           * _.isBoolean(null);
           * // => false
           */
          function isBoolean(value) {
            return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
          }

          /**
           * Checks if `value` is a buffer.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
           * @example
           *
           * _.isBuffer(new Buffer(2));
           * // => true
           *
           * _.isBuffer(new Uint8Array(2));
           * // => false
           */
          var isBuffer = nativeIsBuffer || stubFalse;

          /**
           * Checks if `value` is classified as a `Date` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
           * @example
           *
           * _.isDate(new Date);
           * // => true
           *
           * _.isDate('Mon April 23 2012');
           * // => false
           */
          var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

          /**
           * Checks if `value` is likely a DOM element.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
           * @example
           *
           * _.isElement(document.body);
           * // => true
           *
           * _.isElement('<body>');
           * // => false
           */
          function isElement(value) {
            return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
          }

          /**
           * Checks if `value` is an empty object, collection, map, or set.
           *
           * Objects are considered empty if they have no own enumerable string keyed
           * properties.
           *
           * Array-like values such as `arguments` objects, arrays, buffers, strings, or
           * jQuery-like collections are considered empty if they have a `length` of `0`.
           * Similarly, maps and sets are considered empty if they have a `size` of `0`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is empty, else `false`.
           * @example
           *
           * _.isEmpty(null);
           * // => true
           *
           * _.isEmpty(true);
           * // => true
           *
           * _.isEmpty(1);
           * // => true
           *
           * _.isEmpty([1, 2, 3]);
           * // => false
           *
           * _.isEmpty({ 'a': 1 });
           * // => false
           */
          function isEmpty(value) {
            if (value == null) {
              return true;
            }
            if (isArrayLike(value) && (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
              return !value.length;
            }
            var tag = getTag(value);
            if (tag == mapTag || tag == setTag) {
              return !value.size;
            }
            if (isPrototype(value)) {
              return !baseKeys(value).length;
            }
            for (var key in value) {
              if (hasOwnProperty.call(value, key)) {
                return false;
              }
            }
            return true;
          }

          /**
           * Performs a deep comparison between two values to determine if they are
           * equivalent.
           *
           * **Note:** This method supports comparing arrays, array buffers, booleans,
           * date objects, error objects, maps, numbers, `Object` objects, regexes,
           * sets, strings, symbols, and typed arrays. `Object` objects are compared
           * by their own, not inherited, enumerable properties. Functions and DOM
           * nodes are compared by strict equality, i.e. `===`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * var object = { 'a': 1 };
           * var other = { 'a': 1 };
           *
           * _.isEqual(object, other);
           * // => true
           *
           * object === other;
           * // => false
           */
          function isEqual(value, other) {
            return baseIsEqual(value, other);
          }

          /**
           * This method is like `_.isEqual` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with up to
           * six arguments: (objValue, othValue [, index|key, object, other, stack]).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, othValue) {
           *   if (isGreeting(objValue) && isGreeting(othValue)) {
           *     return true;
           *   }
           * }
           *
           * var array = ['hello', 'goodbye'];
           * var other = ['hi', 'goodbye'];
           *
           * _.isEqualWith(array, other, customizer);
           * // => true
           */
          function isEqualWith(value, other, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            var result = customizer ? customizer(value, other) : undefined;
            return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
          }

          /**
           * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
           * `SyntaxError`, `TypeError`, or `URIError` object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
           * @example
           *
           * _.isError(new Error);
           * // => true
           *
           * _.isError(Error);
           * // => false
           */
          function isError(value) {
            if (!isObjectLike(value)) {
              return false;
            }
            var tag = baseGetTag(value);
            return tag == errorTag || tag == domExcTag || typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value);
          }

          /**
           * Checks if `value` is a finite primitive number.
           *
           * **Note:** This method is based on
           * [`Number.isFinite`](https://mdn.io/Number/isFinite).
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
           * @example
           *
           * _.isFinite(3);
           * // => true
           *
           * _.isFinite(Number.MIN_VALUE);
           * // => true
           *
           * _.isFinite(Infinity);
           * // => false
           *
           * _.isFinite('3');
           * // => false
           */
          function isFinite(value) {
            return typeof value == 'number' && nativeIsFinite(value);
          }

          /**
           * Checks if `value` is classified as a `Function` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a function, else `false`.
           * @example
           *
           * _.isFunction(_);
           * // => true
           *
           * _.isFunction(/abc/);
           * // => false
           */
          function isFunction(value) {
            if (!isObject(value)) {
              return false;
            }
            // The use of `Object#toString` avoids issues with the `typeof` operator
            // in Safari 9 which returns 'object' for typed arrays and other constructors.
            var tag = baseGetTag(value);
            return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
          }

          /**
           * Checks if `value` is an integer.
           *
           * **Note:** This method is based on
           * [`Number.isInteger`](https://mdn.io/Number/isInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
           * @example
           *
           * _.isInteger(3);
           * // => true
           *
           * _.isInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isInteger(Infinity);
           * // => false
           *
           * _.isInteger('3');
           * // => false
           */
          function isInteger(value) {
            return typeof value == 'number' && value == toInteger(value);
          }

          /**
           * Checks if `value` is a valid array-like length.
           *
           * **Note:** This method is loosely based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
           * @example
           *
           * _.isLength(3);
           * // => true
           *
           * _.isLength(Number.MIN_VALUE);
           * // => false
           *
           * _.isLength(Infinity);
           * // => false
           *
           * _.isLength('3');
           * // => false
           */
          function isLength(value) {
            return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is the
           * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
           * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is an object, else `false`.
           * @example
           *
           * _.isObject({});
           * // => true
           *
           * _.isObject([1, 2, 3]);
           * // => true
           *
           * _.isObject(_.noop);
           * // => true
           *
           * _.isObject(null);
           * // => false
           */
          function isObject(value) {
            var type = typeof value;
            return value != null && (type == 'object' || type == 'function');
          }

          /**
           * Checks if `value` is object-like. A value is object-like if it's not `null`
           * and has a `typeof` result of "object".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
           * @example
           *
           * _.isObjectLike({});
           * // => true
           *
           * _.isObjectLike([1, 2, 3]);
           * // => true
           *
           * _.isObjectLike(_.noop);
           * // => false
           *
           * _.isObjectLike(null);
           * // => false
           */
          function isObjectLike(value) {
            return value != null && typeof value == 'object';
          }

          /**
           * Checks if `value` is classified as a `Map` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a map, else `false`.
           * @example
           *
           * _.isMap(new Map);
           * // => true
           *
           * _.isMap(new WeakMap);
           * // => false
           */
          var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

          /**
           * Performs a partial deep comparison between `object` and `source` to
           * determine if `object` contains equivalent property values.
           *
           * **Note:** This method is equivalent to `_.matches` when `source` is
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * var object = { 'a': 1, 'b': 2 };
           *
           * _.isMatch(object, { 'b': 2 });
           * // => true
           *
           * _.isMatch(object, { 'b': 1 });
           * // => false
           */
          function isMatch(object, source) {
            return object === source || baseIsMatch(object, source, getMatchData(source));
          }

          /**
           * This method is like `_.isMatch` except that it accepts `customizer` which
           * is invoked to compare values. If `customizer` returns `undefined`, comparisons
           * are handled by the method instead. The `customizer` is invoked with five
           * arguments: (objValue, srcValue, index|key, object, source).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {Object} object The object to inspect.
           * @param {Object} source The object of property values to match.
           * @param {Function} [customizer] The function to customize comparisons.
           * @returns {boolean} Returns `true` if `object` is a match, else `false`.
           * @example
           *
           * function isGreeting(value) {
           *   return /^h(?:i|ello)$/.test(value);
           * }
           *
           * function customizer(objValue, srcValue) {
           *   if (isGreeting(objValue) && isGreeting(srcValue)) {
           *     return true;
           *   }
           * }
           *
           * var object = { 'greeting': 'hello' };
           * var source = { 'greeting': 'hi' };
           *
           * _.isMatchWith(object, source, customizer);
           * // => true
           */
          function isMatchWith(object, source, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return baseIsMatch(object, source, getMatchData(source), customizer);
          }

          /**
           * Checks if `value` is `NaN`.
           *
           * **Note:** This method is based on
           * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
           * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
           * `undefined` and other non-number values.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
           * @example
           *
           * _.isNaN(NaN);
           * // => true
           *
           * _.isNaN(new Number(NaN));
           * // => true
           *
           * isNaN(undefined);
           * // => true
           *
           * _.isNaN(undefined);
           * // => false
           */
          function isNaN(value) {
            // An `NaN` primitive is the only value that is not equal to itself.
            // Perform the `toStringTag` check first to avoid errors with some
            // ActiveX objects in IE.
            return isNumber(value) && value != +value;
          }

          /**
           * Checks if `value` is a pristine native function.
           *
           * **Note:** This method can't reliably detect native functions in the presence
           * of the core-js package because core-js circumvents this kind of detection.
           * Despite multiple requests, the core-js maintainer has made it clear: any
           * attempt to fix the detection will be obstructed. As a result, we're left
           * with little choice but to throw an error. Unfortunately, this also affects
           * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
           * which rely on core-js.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a native function,
           *  else `false`.
           * @example
           *
           * _.isNative(Array.prototype.push);
           * // => true
           *
           * _.isNative(_);
           * // => false
           */
          function isNative(value) {
            if (isMaskable(value)) {
              throw new Error(CORE_ERROR_TEXT);
            }
            return baseIsNative(value);
          }

          /**
           * Checks if `value` is `null`.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
           * @example
           *
           * _.isNull(null);
           * // => true
           *
           * _.isNull(void 0);
           * // => false
           */
          function isNull(value) {
            return value === null;
          }

          /**
           * Checks if `value` is `null` or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
           * @example
           *
           * _.isNil(null);
           * // => true
           *
           * _.isNil(void 0);
           * // => true
           *
           * _.isNil(NaN);
           * // => false
           */
          function isNil(value) {
            return value == null;
          }

          /**
           * Checks if `value` is classified as a `Number` primitive or object.
           *
           * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
           * classified as numbers, use the `_.isFinite` method.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a number, else `false`.
           * @example
           *
           * _.isNumber(3);
           * // => true
           *
           * _.isNumber(Number.MIN_VALUE);
           * // => true
           *
           * _.isNumber(Infinity);
           * // => true
           *
           * _.isNumber('3');
           * // => false
           */
          function isNumber(value) {
            return typeof value == 'number' || isObjectLike(value) && baseGetTag(value) == numberTag;
          }

          /**
           * Checks if `value` is a plain object, that is, an object created by the
           * `Object` constructor or one with a `[[Prototype]]` of `null`.
           *
           * @static
           * @memberOf _
           * @since 0.8.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * _.isPlainObject(new Foo);
           * // => false
           *
           * _.isPlainObject([1, 2, 3]);
           * // => false
           *
           * _.isPlainObject({ 'x': 0, 'y': 0 });
           * // => true
           *
           * _.isPlainObject(Object.create(null));
           * // => true
           */
          function isPlainObject(value) {
            if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
              return false;
            }
            var proto = getPrototype(value);
            if (proto === null) {
              return true;
            }
            var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
            return typeof Ctor == 'function' && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
          }

          /**
           * Checks if `value` is classified as a `RegExp` object.
           *
           * @static
           * @memberOf _
           * @since 0.1.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
           * @example
           *
           * _.isRegExp(/abc/);
           * // => true
           *
           * _.isRegExp('/abc/');
           * // => false
           */
          var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

          /**
           * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
           * double precision number which isn't the result of a rounded unsafe integer.
           *
           * **Note:** This method is based on
           * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
           * @example
           *
           * _.isSafeInteger(3);
           * // => true
           *
           * _.isSafeInteger(Number.MIN_VALUE);
           * // => false
           *
           * _.isSafeInteger(Infinity);
           * // => false
           *
           * _.isSafeInteger('3');
           * // => false
           */
          function isSafeInteger(value) {
            return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
          }

          /**
           * Checks if `value` is classified as a `Set` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a set, else `false`.
           * @example
           *
           * _.isSet(new Set);
           * // => true
           *
           * _.isSet(new WeakSet);
           * // => false
           */
          var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

          /**
           * Checks if `value` is classified as a `String` primitive or object.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a string, else `false`.
           * @example
           *
           * _.isString('abc');
           * // => true
           *
           * _.isString(1);
           * // => false
           */
          function isString(value) {
            return typeof value == 'string' || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
          }

          /**
           * Checks if `value` is classified as a `Symbol` primitive or object.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
           * @example
           *
           * _.isSymbol(Symbol.iterator);
           * // => true
           *
           * _.isSymbol('abc');
           * // => false
           */
          function isSymbol(value) {
            return typeof value == 'symbol' || isObjectLike(value) && baseGetTag(value) == symbolTag;
          }

          /**
           * Checks if `value` is classified as a typed array.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
           * @example
           *
           * _.isTypedArray(new Uint8Array);
           * // => true
           *
           * _.isTypedArray([]);
           * // => false
           */
          var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

          /**
           * Checks if `value` is `undefined`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
           * @example
           *
           * _.isUndefined(void 0);
           * // => true
           *
           * _.isUndefined(null);
           * // => false
           */
          function isUndefined(value) {
            return value === undefined;
          }

          /**
           * Checks if `value` is classified as a `WeakMap` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
           * @example
           *
           * _.isWeakMap(new WeakMap);
           * // => true
           *
           * _.isWeakMap(new Map);
           * // => false
           */
          function isWeakMap(value) {
            return isObjectLike(value) && getTag(value) == weakMapTag;
          }

          /**
           * Checks if `value` is classified as a `WeakSet` object.
           *
           * @static
           * @memberOf _
           * @since 4.3.0
           * @category Lang
           * @param {*} value The value to check.
           * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
           * @example
           *
           * _.isWeakSet(new WeakSet);
           * // => true
           *
           * _.isWeakSet(new Set);
           * // => false
           */
          function isWeakSet(value) {
            return isObjectLike(value) && baseGetTag(value) == weakSetTag;
          }

          /**
           * Checks if `value` is less than `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than `other`,
           *  else `false`.
           * @see _.gt
           * @example
           *
           * _.lt(1, 3);
           * // => true
           *
           * _.lt(3, 3);
           * // => false
           *
           * _.lt(3, 1);
           * // => false
           */
          var lt = createRelationalOperation(baseLt);

          /**
           * Checks if `value` is less than or equal to `other`.
           *
           * @static
           * @memberOf _
           * @since 3.9.0
           * @category Lang
           * @param {*} value The value to compare.
           * @param {*} other The other value to compare.
           * @returns {boolean} Returns `true` if `value` is less than or equal to
           *  `other`, else `false`.
           * @see _.gte
           * @example
           *
           * _.lte(1, 3);
           * // => true
           *
           * _.lte(3, 3);
           * // => true
           *
           * _.lte(3, 1);
           * // => false
           */
          var lte = createRelationalOperation(function (value, other) {
            return value <= other;
          });

          /**
           * Converts `value` to an array.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Array} Returns the converted array.
           * @example
           *
           * _.toArray({ 'a': 1, 'b': 2 });
           * // => [1, 2]
           *
           * _.toArray('abc');
           * // => ['a', 'b', 'c']
           *
           * _.toArray(1);
           * // => []
           *
           * _.toArray(null);
           * // => []
           */
          function toArray(value) {
            if (!value) {
              return [];
            }
            if (isArrayLike(value)) {
              return isString(value) ? stringToArray(value) : copyArray(value);
            }
            if (symIterator && value[symIterator]) {
              return iteratorToArray(value[symIterator]());
            }
            var tag = getTag(value),
              func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
            return func(value);
          }

          /**
           * Converts `value` to a finite number.
           *
           * @static
           * @memberOf _
           * @since 4.12.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted number.
           * @example
           *
           * _.toFinite(3.2);
           * // => 3.2
           *
           * _.toFinite(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toFinite(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toFinite('3.2');
           * // => 3.2
           */
          function toFinite(value) {
            if (!value) {
              return value === 0 ? value : 0;
            }
            value = toNumber(value);
            if (value === INFINITY || value === -INFINITY) {
              var sign = value < 0 ? -1 : 1;
              return sign * MAX_INTEGER;
            }
            return value === value ? value : 0;
          }

          /**
           * Converts `value` to an integer.
           *
           * **Note:** This method is loosely based on
           * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toInteger(3.2);
           * // => 3
           *
           * _.toInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toInteger(Infinity);
           * // => 1.7976931348623157e+308
           *
           * _.toInteger('3.2');
           * // => 3
           */
          function toInteger(value) {
            var result = toFinite(value),
              remainder = result % 1;
            return result === result ? remainder ? result - remainder : result : 0;
          }

          /**
           * Converts `value` to an integer suitable for use as the length of an
           * array-like object.
           *
           * **Note:** This method is based on
           * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toLength(3.2);
           * // => 3
           *
           * _.toLength(Number.MIN_VALUE);
           * // => 0
           *
           * _.toLength(Infinity);
           * // => 4294967295
           *
           * _.toLength('3.2');
           * // => 3
           */
          function toLength(value) {
            return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
          }

          /**
           * Converts `value` to a number.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to process.
           * @returns {number} Returns the number.
           * @example
           *
           * _.toNumber(3.2);
           * // => 3.2
           *
           * _.toNumber(Number.MIN_VALUE);
           * // => 5e-324
           *
           * _.toNumber(Infinity);
           * // => Infinity
           *
           * _.toNumber('3.2');
           * // => 3.2
           */
          function toNumber(value) {
            if (typeof value == 'number') {
              return value;
            }
            if (isSymbol(value)) {
              return NAN;
            }
            if (isObject(value)) {
              var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
              value = isObject(other) ? other + '' : other;
            }
            if (typeof value != 'string') {
              return value === 0 ? value : +value;
            }
            value = baseTrim(value);
            var isBinary = reIsBinary.test(value);
            return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
          }

          /**
           * Converts `value` to a plain object flattening inherited enumerable string
           * keyed properties of `value` to own properties of the plain object.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {Object} Returns the converted plain object.
           * @example
           *
           * function Foo() {
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.assign({ 'a': 1 }, new Foo);
           * // => { 'a': 1, 'b': 2 }
           *
           * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
           * // => { 'a': 1, 'b': 2, 'c': 3 }
           */
          function toPlainObject(value) {
            return copyObject(value, keysIn(value));
          }

          /**
           * Converts `value` to a safe integer. A safe integer can be compared and
           * represented correctly.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.toSafeInteger(3.2);
           * // => 3
           *
           * _.toSafeInteger(Number.MIN_VALUE);
           * // => 0
           *
           * _.toSafeInteger(Infinity);
           * // => 9007199254740991
           *
           * _.toSafeInteger('3.2');
           * // => 3
           */
          function toSafeInteger(value) {
            return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
          }

          /**
           * Converts `value` to a string. An empty string is returned for `null`
           * and `undefined` values. The sign of `-0` is preserved.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Lang
           * @param {*} value The value to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.toString(null);
           * // => ''
           *
           * _.toString(-0);
           * // => '-0'
           *
           * _.toString([1, 2, 3]);
           * // => '1,2,3'
           */
          function toString(value) {
            return value == null ? '' : baseToString(value);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Assigns own enumerable string keyed properties of source objects to the
           * destination object. Source objects are applied from left to right.
           * Subsequent sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object` and is loosely based on
           * [`Object.assign`](https://mdn.io/Object/assign).
           *
           * @static
           * @memberOf _
           * @since 0.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assignIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assign({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'c': 3 }
           */
          var assign = createAssigner(function (object, source) {
            if (isPrototype(source) || isArrayLike(source)) {
              copyObject(source, keys(source), object);
              return;
            }
            for (var key in source) {
              if (hasOwnProperty.call(source, key)) {
                assignValue(object, key, source[key]);
              }
            }
          });

          /**
           * This method is like `_.assign` except that it iterates over own and
           * inherited source properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extend
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.assign
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           * }
           *
           * function Bar() {
           *   this.c = 3;
           * }
           *
           * Foo.prototype.b = 2;
           * Bar.prototype.d = 4;
           *
           * _.assignIn({ 'a': 0 }, new Foo, new Bar);
           * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
           */
          var assignIn = createAssigner(function (object, source) {
            copyObject(source, keysIn(source), object);
          });

          /**
           * This method is like `_.assignIn` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias extendWith
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignInWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var assignInWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keysIn(source), object, customizer);
          });

          /**
           * This method is like `_.assign` except that it accepts `customizer`
           * which is invoked to produce the assigned values. If `customizer` returns
           * `undefined`, assignment is handled by the method instead. The `customizer`
           * is invoked with five arguments: (objValue, srcValue, key, object, source).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @see _.assignInWith
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   return _.isUndefined(objValue) ? srcValue : objValue;
           * }
           *
           * var defaults = _.partialRight(_.assignWith, customizer);
           *
           * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var assignWith = createAssigner(function (object, source, srcIndex, customizer) {
            copyObject(source, keys(source), object, customizer);
          });

          /**
           * Creates an array of values corresponding to `paths` of `object`.
           *
           * @static
           * @memberOf _
           * @since 1.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Array} Returns the picked values.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
           *
           * _.at(object, ['a[0].b.c', 'a[1]']);
           * // => [3, 4]
           */
          var at = flatRest(baseAt);

          /**
           * Creates an object that inherits from the `prototype` object. If a
           * `properties` object is given, its own enumerable string keyed properties
           * are assigned to the created object.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Object
           * @param {Object} prototype The object to inherit from.
           * @param {Object} [properties] The properties to assign to the object.
           * @returns {Object} Returns the new object.
           * @example
           *
           * function Shape() {
           *   this.x = 0;
           *   this.y = 0;
           * }
           *
           * function Circle() {
           *   Shape.call(this);
           * }
           *
           * Circle.prototype = _.create(Shape.prototype, {
           *   'constructor': Circle
           * });
           *
           * var circle = new Circle;
           * circle instanceof Circle;
           * // => true
           *
           * circle instanceof Shape;
           * // => true
           */
          function create(prototype, properties) {
            var result = baseCreate(prototype);
            return properties == null ? result : baseAssign(result, properties);
          }

          /**
           * Assigns own and inherited enumerable string keyed properties of source
           * objects to the destination object for all destination properties that
           * resolve to `undefined`. Source objects are applied from left to right.
           * Once a property is set, additional values of the same property are ignored.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaultsDeep
           * @example
           *
           * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
           * // => { 'a': 1, 'b': 2 }
           */
          var defaults = baseRest(function (object, sources) {
            object = Object(object);
            var index = -1;
            var length = sources.length;
            var guard = length > 2 ? sources[2] : undefined;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              length = 1;
            }
            while (++index < length) {
              var source = sources[index];
              var props = keysIn(source);
              var propsIndex = -1;
              var propsLength = props.length;
              while (++propsIndex < propsLength) {
                var key = props[propsIndex];
                var value = object[key];
                if (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                  object[key] = source[key];
                }
              }
            }
            return object;
          });

          /**
           * This method is like `_.defaults` except that it recursively assigns
           * default properties.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @see _.defaults
           * @example
           *
           * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
           * // => { 'a': { 'b': 2, 'c': 3 } }
           */
          var defaultsDeep = baseRest(function (args) {
            args.push(undefined, customDefaultsMerge);
            return apply(mergeWith, undefined, args);
          });

          /**
           * This method is like `_.find` except that it returns the key of the first
           * element `predicate` returns truthy for instead of the element itself.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findKey(users, function(o) { return o.age < 40; });
           * // => 'barney' (iteration order is not guaranteed)
           *
           * // The `_.matches` iteratee shorthand.
           * _.findKey(users, { 'age': 1, 'active': true });
           * // => 'pebbles'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findKey(users, 'active');
           * // => 'barney'
           */
          function findKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
          }

          /**
           * This method is like `_.findKey` except that it iterates over elements of
           * a collection in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @param {Function} [predicate=_.identity] The function invoked per iteration.
           * @returns {string|undefined} Returns the key of the matched element,
           *  else `undefined`.
           * @example
           *
           * var users = {
           *   'barney':  { 'age': 36, 'active': true },
           *   'fred':    { 'age': 40, 'active': false },
           *   'pebbles': { 'age': 1,  'active': true }
           * };
           *
           * _.findLastKey(users, function(o) { return o.age < 40; });
           * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
           *
           * // The `_.matches` iteratee shorthand.
           * _.findLastKey(users, { 'age': 36, 'active': true });
           * // => 'barney'
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.findLastKey(users, ['active', false]);
           * // => 'fred'
           *
           * // The `_.property` iteratee shorthand.
           * _.findLastKey(users, 'active');
           * // => 'pebbles'
           */
          function findLastKey(object, predicate) {
            return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
          }

          /**
           * Iterates over own and inherited enumerable string keyed properties of an
           * object and invokes `iteratee` for each property. The iteratee is invoked
           * with three arguments: (value, key, object). Iteratee functions may exit
           * iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forInRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forIn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
           */
          function forIn(object, iteratee) {
            return object == null ? object : baseFor(object, getIteratee(iteratee, 3), keysIn);
          }

          /**
           * This method is like `_.forIn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forIn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forInRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
           */
          function forInRight(object, iteratee) {
            return object == null ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn);
          }

          /**
           * Iterates over own enumerable string keyed properties of an object and
           * invokes `iteratee` for each property. The iteratee is invoked with three
           * arguments: (value, key, object). Iteratee functions may exit iteration
           * early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 0.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwnRight
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwn(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'a' then 'b' (iteration order is not guaranteed).
           */
          function forOwn(object, iteratee) {
            return object && baseForOwn(object, getIteratee(iteratee, 3));
          }

          /**
           * This method is like `_.forOwn` except that it iterates over properties of
           * `object` in the opposite order.
           *
           * @static
           * @memberOf _
           * @since 2.0.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns `object`.
           * @see _.forOwn
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.forOwnRight(new Foo, function(value, key) {
           *   console.log(key);
           * });
           * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
           */
          function forOwnRight(object, iteratee) {
            return object && baseForOwnRight(object, getIteratee(iteratee, 3));
          }

          /**
           * Creates an array of function property names from own enumerable properties
           * of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functionsIn
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functions(new Foo);
           * // => ['a', 'b']
           */
          function functions(object) {
            return object == null ? [] : baseFunctions(object, keys(object));
          }

          /**
           * Creates an array of function property names from own and inherited
           * enumerable properties of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to inspect.
           * @returns {Array} Returns the function names.
           * @see _.functions
           * @example
           *
           * function Foo() {
           *   this.a = _.constant('a');
           *   this.b = _.constant('b');
           * }
           *
           * Foo.prototype.c = _.constant('c');
           *
           * _.functionsIn(new Foo);
           * // => ['a', 'b', 'c']
           */
          function functionsIn(object) {
            return object == null ? [] : baseFunctions(object, keysIn(object));
          }

          /**
           * Gets the value at `path` of `object`. If the resolved value is
           * `undefined`, the `defaultValue` is returned in its place.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to get.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.get(object, 'a[0].b.c');
           * // => 3
           *
           * _.get(object, ['a', '0', 'b', 'c']);
           * // => 3
           *
           * _.get(object, 'a.b.c', 'default');
           * // => 'default'
           */
          function get(object, path, defaultValue) {
            var result = object == null ? undefined : baseGet(object, path);
            return result === undefined ? defaultValue : result;
          }

          /**
           * Checks if `path` is a direct property of `object`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = { 'a': { 'b': 2 } };
           * var other = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.has(object, 'a');
           * // => true
           *
           * _.has(object, 'a.b');
           * // => true
           *
           * _.has(object, ['a', 'b']);
           * // => true
           *
           * _.has(other, 'a');
           * // => false
           */
          function has(object, path) {
            return object != null && hasPath(object, path, baseHas);
          }

          /**
           * Checks if `path` is a direct or inherited property of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path to check.
           * @returns {boolean} Returns `true` if `path` exists, else `false`.
           * @example
           *
           * var object = _.create({ 'a': _.create({ 'b': 2 }) });
           *
           * _.hasIn(object, 'a');
           * // => true
           *
           * _.hasIn(object, 'a.b');
           * // => true
           *
           * _.hasIn(object, ['a', 'b']);
           * // => true
           *
           * _.hasIn(object, 'b');
           * // => false
           */
          function hasIn(object, path) {
            return object != null && hasPath(object, path, baseHasIn);
          }

          /**
           * Creates an object composed of the inverted keys and values of `object`.
           * If `object` contains duplicate values, subsequent values overwrite
           * property assignments of previous values.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Object
           * @param {Object} object The object to invert.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invert(object);
           * // => { '1': 'c', '2': 'b' }
           */
          var invert = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }
            result[value] = key;
          }, constant(identity));

          /**
           * This method is like `_.invert` except that the inverted object is generated
           * from the results of running each element of `object` thru `iteratee`. The
           * corresponding inverted value of each inverted key is an array of keys
           * responsible for generating the inverted value. The iteratee is invoked
           * with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.1.0
           * @category Object
           * @param {Object} object The object to invert.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {Object} Returns the new inverted object.
           * @example
           *
           * var object = { 'a': 1, 'b': 2, 'c': 1 };
           *
           * _.invertBy(object);
           * // => { '1': ['a', 'c'], '2': ['b'] }
           *
           * _.invertBy(object, function(value) {
           *   return 'group' + value;
           * });
           * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
           */
          var invertBy = createInverter(function (result, value, key) {
            if (value != null && typeof value.toString != 'function') {
              value = nativeObjectToString.call(value);
            }
            if (hasOwnProperty.call(result, value)) {
              result[value].push(key);
            } else {
              result[value] = [key];
            }
          }, getIteratee);

          /**
           * Invokes the method at `path` of `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {*} Returns the result of the invoked method.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
           *
           * _.invoke(object, 'a[0].b.c.slice', 1, 3);
           * // => [2, 3]
           */
          var invoke = baseRest(baseInvoke);

          /**
           * Creates an array of the own enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects. See the
           * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
           * for more details.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keys(new Foo);
           * // => ['a', 'b'] (iteration order is not guaranteed)
           *
           * _.keys('hi');
           * // => ['0', '1']
           */
          function keys(object) {
            return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
          }

          /**
           * Creates an array of the own and inherited enumerable property names of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property names.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.keysIn(new Foo);
           * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
           */
          function keysIn(object) {
            return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
          }

          /**
           * The opposite of `_.mapValues`; this method creates an object with the
           * same values as `object` and keys generated by running each own enumerable
           * string keyed property of `object` thru `iteratee`. The iteratee is invoked
           * with three arguments: (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 3.8.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapValues
           * @example
           *
           * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
           *   return key + value;
           * });
           * // => { 'a1': 1, 'b2': 2 }
           */
          function mapKeys(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, iteratee(value, key, object), value);
            });
            return result;
          }

          /**
           * Creates an object with the same keys as `object` and values generated
           * by running each own enumerable string keyed property of `object` thru
           * `iteratee`. The iteratee is invoked with three arguments:
           * (value, key, object).
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Object} Returns the new mapped object.
           * @see _.mapKeys
           * @example
           *
           * var users = {
           *   'fred':    { 'user': 'fred',    'age': 40 },
           *   'pebbles': { 'user': 'pebbles', 'age': 1 }
           * };
           *
           * _.mapValues(users, function(o) { return o.age; });
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           *
           * // The `_.property` iteratee shorthand.
           * _.mapValues(users, 'age');
           * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
           */
          function mapValues(object, iteratee) {
            var result = {};
            iteratee = getIteratee(iteratee, 3);
            baseForOwn(object, function (value, key, object) {
              baseAssignValue(result, key, iteratee(value, key, object));
            });
            return result;
          }

          /**
           * This method is like `_.assign` except that it recursively merges own and
           * inherited enumerable string keyed properties of source objects into the
           * destination object. Source properties that resolve to `undefined` are
           * skipped if a destination value exists. Array and plain object properties
           * are merged recursively. Other objects and value types are overridden by
           * assignment. Source objects are applied from left to right. Subsequent
           * sources overwrite property assignments of previous sources.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 0.5.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} [sources] The source objects.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {
           *   'a': [{ 'b': 2 }, { 'd': 4 }]
           * };
           *
           * var other = {
           *   'a': [{ 'c': 3 }, { 'e': 5 }]
           * };
           *
           * _.merge(object, other);
           * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
           */
          var merge = createAssigner(function (object, source, srcIndex) {
            baseMerge(object, source, srcIndex);
          });

          /**
           * This method is like `_.merge` except that it accepts `customizer` which
           * is invoked to produce the merged values of the destination and source
           * properties. If `customizer` returns `undefined`, merging is handled by the
           * method instead. The `customizer` is invoked with six arguments:
           * (objValue, srcValue, key, object, source, stack).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The destination object.
           * @param {...Object} sources The source objects.
           * @param {Function} customizer The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * function customizer(objValue, srcValue) {
           *   if (_.isArray(objValue)) {
           *     return objValue.concat(srcValue);
           *   }
           * }
           *
           * var object = { 'a': [1], 'b': [2] };
           * var other = { 'a': [3], 'b': [4] };
           *
           * _.mergeWith(object, other, customizer);
           * // => { 'a': [1, 3], 'b': [2, 4] }
           */
          var mergeWith = createAssigner(function (object, source, srcIndex, customizer) {
            baseMerge(object, source, srcIndex, customizer);
          });

          /**
           * The opposite of `_.pick`; this method creates an object composed of the
           * own and inherited enumerable property paths of `object` that are not omitted.
           *
           * **Note:** This method is considerably slower than `_.pick`.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to omit.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omit(object, ['a', 'c']);
           * // => { 'b': '2' }
           */
          var omit = flatRest(function (object, paths) {
            var result = {};
            if (object == null) {
              return result;
            }
            var isDeep = false;
            paths = arrayMap(paths, function (path) {
              path = castPath(path, object);
              isDeep || (isDeep = path.length > 1);
              return path;
            });
            copyObject(object, getAllKeysIn(object), result);
            if (isDeep) {
              result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
            }
            var length = paths.length;
            while (length--) {
              baseUnset(result, paths[length]);
            }
            return result;
          });

          /**
           * The opposite of `_.pickBy`; this method creates an object composed of
           * the own and inherited enumerable string keyed properties of `object` that
           * `predicate` doesn't return truthy for. The predicate is invoked with two
           * arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.omitBy(object, _.isNumber);
           * // => { 'b': '2' }
           */
          function omitBy(object, predicate) {
            return pickBy(object, negate(getIteratee(predicate)));
          }

          /**
           * Creates an object composed of the picked `object` properties.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The source object.
           * @param {...(string|string[])} [paths] The property paths to pick.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pick(object, ['a', 'c']);
           * // => { 'a': 1, 'c': 3 }
           */
          var pick = flatRest(function (object, paths) {
            return object == null ? {} : basePick(object, paths);
          });

          /**
           * Creates an object composed of the `object` properties `predicate` returns
           * truthy for. The predicate is invoked with two arguments: (value, key).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The source object.
           * @param {Function} [predicate=_.identity] The function invoked per property.
           * @returns {Object} Returns the new object.
           * @example
           *
           * var object = { 'a': 1, 'b': '2', 'c': 3 };
           *
           * _.pickBy(object, _.isNumber);
           * // => { 'a': 1, 'c': 3 }
           */
          function pickBy(object, predicate) {
            if (object == null) {
              return {};
            }
            var props = arrayMap(getAllKeysIn(object), function (prop) {
              return [prop];
            });
            predicate = getIteratee(predicate);
            return basePickBy(object, props, function (value, path) {
              return predicate(value, path[0]);
            });
          }

          /**
           * This method is like `_.get` except that if the resolved value is a
           * function it's invoked with the `this` binding of its parent object and
           * its result is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @param {Array|string} path The path of the property to resolve.
           * @param {*} [defaultValue] The value returned for `undefined` resolved values.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
           *
           * _.result(object, 'a[0].b.c1');
           * // => 3
           *
           * _.result(object, 'a[0].b.c2');
           * // => 4
           *
           * _.result(object, 'a[0].b.c3', 'default');
           * // => 'default'
           *
           * _.result(object, 'a[0].b.c3', _.constant('default'));
           * // => 'default'
           */
          function result(object, path, defaultValue) {
            path = castPath(path, object);
            var index = -1,
              length = path.length;

            // Ensure the loop is entered when path is empty.
            if (!length) {
              length = 1;
              object = undefined;
            }
            while (++index < length) {
              var value = object == null ? undefined : object[toKey(path[index])];
              if (value === undefined) {
                index = length;
                value = defaultValue;
              }
              object = isFunction(value) ? value.call(object) : value;
            }
            return object;
          }

          /**
           * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
           * it's created. Arrays are created for missing index properties while objects
           * are created for all other missing properties. Use `_.setWith` to customize
           * `path` creation.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.set(object, 'a[0].b.c', 4);
           * console.log(object.a[0].b.c);
           * // => 4
           *
           * _.set(object, ['x', '0', 'y', 'z'], 5);
           * console.log(object.x[0].y.z);
           * // => 5
           */
          function set(object, path, value) {
            return object == null ? object : baseSet(object, path, value);
          }

          /**
           * This method is like `_.set` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {*} value The value to set.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.setWith(object, '[0][1]', 'a', Object);
           * // => { '0': { '1': 'a' } }
           */
          function setWith(object, path, value, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseSet(object, path, value, customizer);
          }

          /**
           * Creates an array of own enumerable string keyed-value pairs for `object`
           * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
           * entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entries
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairs(new Foo);
           * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
           */
          var toPairs = createToPairs(keys);

          /**
           * Creates an array of own and inherited enumerable string keyed-value pairs
           * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
           * or set, its entries are returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @alias entriesIn
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the key-value pairs.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.toPairsIn(new Foo);
           * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
           */
          var toPairsIn = createToPairs(keysIn);

          /**
           * An alternative to `_.reduce`; this method transforms `object` to a new
           * `accumulator` object which is the result of running each of its own
           * enumerable string keyed properties thru `iteratee`, with each invocation
           * potentially mutating the `accumulator` object. If `accumulator` is not
           * provided, a new object with the same `[[Prototype]]` will be used. The
           * iteratee is invoked with four arguments: (accumulator, value, key, object).
           * Iteratee functions may exit iteration early by explicitly returning `false`.
           *
           * @static
           * @memberOf _
           * @since 1.3.0
           * @category Object
           * @param {Object} object The object to iterate over.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @param {*} [accumulator] The custom accumulator value.
           * @returns {*} Returns the accumulated value.
           * @example
           *
           * _.transform([2, 3, 4], function(result, n) {
           *   result.push(n *= n);
           *   return n % 2 == 0;
           * }, []);
           * // => [4, 9]
           *
           * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
           *   (result[value] || (result[value] = [])).push(key);
           * }, {});
           * // => { '1': ['a', 'c'], '2': ['b'] }
           */
          function transform(object, iteratee, accumulator) {
            var isArr = isArray(object),
              isArrLike = isArr || isBuffer(object) || isTypedArray(object);
            iteratee = getIteratee(iteratee, 4);
            if (accumulator == null) {
              var Ctor = object && object.constructor;
              if (isArrLike) {
                accumulator = isArr ? new Ctor() : [];
              } else if (isObject(object)) {
                accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
              } else {
                accumulator = {};
              }
            }
            (isArrLike ? arrayEach : baseForOwn)(object, function (value, index, object) {
              return iteratee(accumulator, value, index, object);
            });
            return accumulator;
          }

          /**
           * Removes the property at `path` of `object`.
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to unset.
           * @returns {boolean} Returns `true` if the property is deleted, else `false`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 7 } }] };
           * _.unset(object, 'a[0].b.c');
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           *
           * _.unset(object, ['a', '0', 'b', 'c']);
           * // => true
           *
           * console.log(object);
           * // => { 'a': [{ 'b': {} }] };
           */
          function unset(object, path) {
            return object == null ? true : baseUnset(object, path);
          }

          /**
           * This method is like `_.set` except that accepts `updater` to produce the
           * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
           * is invoked with one argument: (value).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = { 'a': [{ 'b': { 'c': 3 } }] };
           *
           * _.update(object, 'a[0].b.c', function(n) { return n * n; });
           * console.log(object.a[0].b.c);
           * // => 9
           *
           * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
           * console.log(object.x[0].y.z);
           * // => 0
           */
          function update(object, path, updater) {
            return object == null ? object : baseUpdate(object, path, castFunction(updater));
          }

          /**
           * This method is like `_.update` except that it accepts `customizer` which is
           * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
           * path creation is handled by the method instead. The `customizer` is invoked
           * with three arguments: (nsValue, key, nsObject).
           *
           * **Note:** This method mutates `object`.
           *
           * @static
           * @memberOf _
           * @since 4.6.0
           * @category Object
           * @param {Object} object The object to modify.
           * @param {Array|string} path The path of the property to set.
           * @param {Function} updater The function to produce the updated value.
           * @param {Function} [customizer] The function to customize assigned values.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var object = {};
           *
           * _.updateWith(object, '[0][1]', _.constant('a'), Object);
           * // => { '0': { '1': 'a' } }
           */
          function updateWith(object, path, updater, customizer) {
            customizer = typeof customizer == 'function' ? customizer : undefined;
            return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
          }

          /**
           * Creates an array of the own enumerable string keyed property values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.values(new Foo);
           * // => [1, 2] (iteration order is not guaranteed)
           *
           * _.values('hi');
           * // => ['h', 'i']
           */
          function values(object) {
            return object == null ? [] : baseValues(object, keys(object));
          }

          /**
           * Creates an array of the own and inherited enumerable string keyed property
           * values of `object`.
           *
           * **Note:** Non-object values are coerced to objects.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Object
           * @param {Object} object The object to query.
           * @returns {Array} Returns the array of property values.
           * @example
           *
           * function Foo() {
           *   this.a = 1;
           *   this.b = 2;
           * }
           *
           * Foo.prototype.c = 3;
           *
           * _.valuesIn(new Foo);
           * // => [1, 2, 3] (iteration order is not guaranteed)
           */
          function valuesIn(object) {
            return object == null ? [] : baseValues(object, keysIn(object));
          }

          /*------------------------------------------------------------------------*/

          /**
           * Clamps `number` within the inclusive `lower` and `upper` bounds.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Number
           * @param {number} number The number to clamp.
           * @param {number} [lower] The lower bound.
           * @param {number} upper The upper bound.
           * @returns {number} Returns the clamped number.
           * @example
           *
           * _.clamp(-10, -5, 5);
           * // => -5
           *
           * _.clamp(10, -5, 5);
           * // => 5
           */
          function clamp(number, lower, upper) {
            if (upper === undefined) {
              upper = lower;
              lower = undefined;
            }
            if (upper !== undefined) {
              upper = toNumber(upper);
              upper = upper === upper ? upper : 0;
            }
            if (lower !== undefined) {
              lower = toNumber(lower);
              lower = lower === lower ? lower : 0;
            }
            return baseClamp(toNumber(number), lower, upper);
          }

          /**
           * Checks if `n` is between `start` and up to, but not including, `end`. If
           * `end` is not specified, it's set to `start` with `start` then set to `0`.
           * If `start` is greater than `end` the params are swapped to support
           * negative ranges.
           *
           * @static
           * @memberOf _
           * @since 3.3.0
           * @category Number
           * @param {number} number The number to check.
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
           * @see _.range, _.rangeRight
           * @example
           *
           * _.inRange(3, 2, 4);
           * // => true
           *
           * _.inRange(4, 8);
           * // => true
           *
           * _.inRange(4, 2);
           * // => false
           *
           * _.inRange(2, 2);
           * // => false
           *
           * _.inRange(1.2, 2);
           * // => true
           *
           * _.inRange(5.2, 4);
           * // => false
           *
           * _.inRange(-3, -2, -6);
           * // => true
           */
          function inRange(number, start, end) {
            start = toFinite(start);
            if (end === undefined) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            number = toNumber(number);
            return baseInRange(number, start, end);
          }

          /**
           * Produces a random number between the inclusive `lower` and `upper` bounds.
           * If only one argument is provided a number between `0` and the given number
           * is returned. If `floating` is `true`, or either `lower` or `upper` are
           * floats, a floating-point number is returned instead of an integer.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @memberOf _
           * @since 0.7.0
           * @category Number
           * @param {number} [lower=0] The lower bound.
           * @param {number} [upper=1] The upper bound.
           * @param {boolean} [floating] Specify returning a floating-point number.
           * @returns {number} Returns the random number.
           * @example
           *
           * _.random(0, 5);
           * // => an integer between 0 and 5
           *
           * _.random(5);
           * // => also an integer between 0 and 5
           *
           * _.random(5, true);
           * // => a floating-point number between 0 and 5
           *
           * _.random(1.2, 5.2);
           * // => a floating-point number between 1.2 and 5.2
           */
          function random(lower, upper, floating) {
            if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
              upper = floating = undefined;
            }
            if (floating === undefined) {
              if (typeof upper == 'boolean') {
                floating = upper;
                upper = undefined;
              } else if (typeof lower == 'boolean') {
                floating = lower;
                lower = undefined;
              }
            }
            if (lower === undefined && upper === undefined) {
              lower = 0;
              upper = 1;
            } else {
              lower = toFinite(lower);
              if (upper === undefined) {
                upper = lower;
                lower = 0;
              } else {
                upper = toFinite(upper);
              }
            }
            if (lower > upper) {
              var temp = lower;
              lower = upper;
              upper = temp;
            }
            if (floating || lower % 1 || upper % 1) {
              var rand = nativeRandom();
              return nativeMin(lower + rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1))), upper);
            }
            return baseRandom(lower, upper);
          }

          /*------------------------------------------------------------------------*/

          /**
           * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the camel cased string.
           * @example
           *
           * _.camelCase('Foo Bar');
           * // => 'fooBar'
           *
           * _.camelCase('--foo-bar--');
           * // => 'fooBar'
           *
           * _.camelCase('__FOO_BAR__');
           * // => 'fooBar'
           */
          var camelCase = createCompounder(function (result, word, index) {
            word = word.toLowerCase();
            return result + (index ? capitalize(word) : word);
          });

          /**
           * Converts the first character of `string` to upper case and the remaining
           * to lower case.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to capitalize.
           * @returns {string} Returns the capitalized string.
           * @example
           *
           * _.capitalize('FRED');
           * // => 'Fred'
           */
          function capitalize(string) {
            return upperFirst(toString(string).toLowerCase());
          }

          /**
           * Deburrs `string` by converting
           * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
           * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
           * letters to basic Latin letters and removing
           * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to deburr.
           * @returns {string} Returns the deburred string.
           * @example
           *
           * _.deburr('dj vu');
           * // => 'deja vu'
           */
          function deburr(string) {
            string = toString(string);
            return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
          }

          /**
           * Checks if `string` ends with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=string.length] The position to search up to.
           * @returns {boolean} Returns `true` if `string` ends with `target`,
           *  else `false`.
           * @example
           *
           * _.endsWith('abc', 'c');
           * // => true
           *
           * _.endsWith('abc', 'b');
           * // => false
           *
           * _.endsWith('abc', 'b', 2);
           * // => true
           */
          function endsWith(string, target, position) {
            string = toString(string);
            target = baseToString(target);
            var length = string.length;
            position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
            var end = position;
            position -= target.length;
            return position >= 0 && string.slice(position, end) == target;
          }

          /**
           * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
           * corresponding HTML entities.
           *
           * **Note:** No other characters are escaped. To escape additional
           * characters use a third-party library like [_he_](https://mths.be/he).
           *
           * Though the ">" character is escaped for symmetry, characters like
           * ">" and "/" don't need escaping in HTML and have no special meaning
           * unless they're part of a tag or unquoted attribute value. See
           * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
           * (under "semi-related fun fact") for more details.
           *
           * When working with HTML you should always
           * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
           * XSS vectors.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escape('fred, barney, & pebbles');
           * // => 'fred, barney, &amp; pebbles'
           */
          function escape(string) {
            string = toString(string);
            return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
          }

          /**
           * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
           * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to escape.
           * @returns {string} Returns the escaped string.
           * @example
           *
           * _.escapeRegExp('[lodash](https://lodash.com/)');
           * // => '\[lodash\]\(https://lodash\.com/\)'
           */
          function escapeRegExp(string) {
            string = toString(string);
            return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, '\\$&') : string;
          }

          /**
           * Converts `string` to
           * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the kebab cased string.
           * @example
           *
           * _.kebabCase('Foo Bar');
           * // => 'foo-bar'
           *
           * _.kebabCase('fooBar');
           * // => 'foo-bar'
           *
           * _.kebabCase('__FOO_BAR__');
           * // => 'foo-bar'
           */
          var kebabCase = createCompounder(function (result, word, index) {
            return result + (index ? '-' : '') + word.toLowerCase();
          });

          /**
           * Converts `string`, as space separated words, to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.lowerCase('--Foo-Bar--');
           * // => 'foo bar'
           *
           * _.lowerCase('fooBar');
           * // => 'foo bar'
           *
           * _.lowerCase('__FOO_BAR__');
           * // => 'foo bar'
           */
          var lowerCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toLowerCase();
          });

          /**
           * Converts the first character of `string` to lower case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.lowerFirst('Fred');
           * // => 'fred'
           *
           * _.lowerFirst('FRED');
           * // => 'fRED'
           */
          var lowerFirst = createCaseFirst('toLowerCase');

          /**
           * Pads `string` on the left and right sides if it's shorter than `length`.
           * Padding characters are truncated if they can't be evenly divided by `length`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.pad('abc', 8);
           * // => '  abc   '
           *
           * _.pad('abc', 8, '_-');
           * // => '_-abc_-_'
           *
           * _.pad('abc', 3);
           * // => 'abc'
           */
          function pad(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            if (!length || strLength >= length) {
              return string;
            }
            var mid = (length - strLength) / 2;
            return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
          }

          /**
           * Pads `string` on the right side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padEnd('abc', 6);
           * // => 'abc   '
           *
           * _.padEnd('abc', 6, '_-');
           * // => 'abc_-_'
           *
           * _.padEnd('abc', 3);
           * // => 'abc'
           */
          function padEnd(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
          }

          /**
           * Pads `string` on the left side if it's shorter than `length`. Padding
           * characters are truncated if they exceed `length`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to pad.
           * @param {number} [length=0] The padding length.
           * @param {string} [chars=' '] The string used as padding.
           * @returns {string} Returns the padded string.
           * @example
           *
           * _.padStart('abc', 6);
           * // => '   abc'
           *
           * _.padStart('abc', 6, '_-');
           * // => '_-_abc'
           *
           * _.padStart('abc', 3);
           * // => 'abc'
           */
          function padStart(string, length, chars) {
            string = toString(string);
            length = toInteger(length);
            var strLength = length ? stringSize(string) : 0;
            return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
          }

          /**
           * Converts `string` to an integer of the specified radix. If `radix` is
           * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
           * hexadecimal, in which case a `radix` of `16` is used.
           *
           * **Note:** This method aligns with the
           * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
           *
           * @static
           * @memberOf _
           * @since 1.1.0
           * @category String
           * @param {string} string The string to convert.
           * @param {number} [radix=10] The radix to interpret `value` by.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {number} Returns the converted integer.
           * @example
           *
           * _.parseInt('08');
           * // => 8
           *
           * _.map(['6', '08', '10'], _.parseInt);
           * // => [6, 8, 10]
           */
          function parseInt(string, radix, guard) {
            if (guard || radix == null) {
              radix = 0;
            } else if (radix) {
              radix = +radix;
            }
            return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
          }

          /**
           * Repeats the given string `n` times.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to repeat.
           * @param {number} [n=1] The number of times to repeat the string.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the repeated string.
           * @example
           *
           * _.repeat('*', 3);
           * // => '***'
           *
           * _.repeat('abc', 2);
           * // => 'abcabc'
           *
           * _.repeat('abc', 0);
           * // => ''
           */
          function repeat(string, n, guard) {
            if (guard ? isIterateeCall(string, n, guard) : n === undefined) {
              n = 1;
            } else {
              n = toInteger(n);
            }
            return baseRepeat(toString(string), n);
          }

          /**
           * Replaces matches for `pattern` in `string` with `replacement`.
           *
           * **Note:** This method is based on
           * [`String#replace`](https://mdn.io/String/replace).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to modify.
           * @param {RegExp|string} pattern The pattern to replace.
           * @param {Function|string} replacement The match replacement.
           * @returns {string} Returns the modified string.
           * @example
           *
           * _.replace('Hi Fred', 'Fred', 'Barney');
           * // => 'Hi Barney'
           */
          function replace() {
            var args = arguments,
              string = toString(args[0]);
            return args.length < 3 ? string : string.replace(args[1], args[2]);
          }

          /**
           * Converts `string` to
           * [snake case](https://en.wikipedia.org/wiki/Snake_case).
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the snake cased string.
           * @example
           *
           * _.snakeCase('Foo Bar');
           * // => 'foo_bar'
           *
           * _.snakeCase('fooBar');
           * // => 'foo_bar'
           *
           * _.snakeCase('--FOO-BAR--');
           * // => 'foo_bar'
           */
          var snakeCase = createCompounder(function (result, word, index) {
            return result + (index ? '_' : '') + word.toLowerCase();
          });

          /**
           * Splits `string` by `separator`.
           *
           * **Note:** This method is based on
           * [`String#split`](https://mdn.io/String/split).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to split.
           * @param {RegExp|string} separator The separator pattern to split by.
           * @param {number} [limit] The length to truncate results to.
           * @returns {Array} Returns the string segments.
           * @example
           *
           * _.split('a-b-c', '-', 2);
           * // => ['a', 'b']
           */
          function split(string, separator, limit) {
            if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
              separator = limit = undefined;
            }
            limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
            if (!limit) {
              return [];
            }
            string = toString(string);
            if (string && (typeof separator == 'string' || separator != null && !isRegExp(separator))) {
              separator = baseToString(separator);
              if (!separator && hasUnicode(string)) {
                return castSlice(stringToArray(string), 0, limit);
              }
            }
            return string.split(separator, limit);
          }

          /**
           * Converts `string` to
           * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
           *
           * @static
           * @memberOf _
           * @since 3.1.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the start cased string.
           * @example
           *
           * _.startCase('--foo-bar--');
           * // => 'Foo Bar'
           *
           * _.startCase('fooBar');
           * // => 'Foo Bar'
           *
           * _.startCase('__FOO_BAR__');
           * // => 'FOO BAR'
           */
          var startCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + upperFirst(word);
          });

          /**
           * Checks if `string` starts with the given target string.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {string} [target] The string to search for.
           * @param {number} [position=0] The position to search from.
           * @returns {boolean} Returns `true` if `string` starts with `target`,
           *  else `false`.
           * @example
           *
           * _.startsWith('abc', 'a');
           * // => true
           *
           * _.startsWith('abc', 'b');
           * // => false
           *
           * _.startsWith('abc', 'b', 1);
           * // => true
           */
          function startsWith(string, target, position) {
            string = toString(string);
            position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
            target = baseToString(target);
            return string.slice(position, position + target.length) == target;
          }

          /**
           * Creates a compiled template function that can interpolate data properties
           * in "interpolate" delimiters, HTML-escape interpolated data properties in
           * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
           * properties may be accessed as free variables in the template. If a setting
           * object is given, it takes precedence over `_.templateSettings` values.
           *
           * **Note:** In the development build `_.template` utilizes
           * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
           * for easier debugging.
           *
           * For more information on precompiling templates see
           * [lodash's custom builds documentation](https://lodash.com/custom-builds).
           *
           * For more information on Chrome extension sandboxes see
           * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category String
           * @param {string} [string=''] The template string.
           * @param {Object} [options={}] The options object.
           * @param {RegExp} [options.escape=_.templateSettings.escape]
           *  The HTML "escape" delimiter.
           * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
           *  The "evaluate" delimiter.
           * @param {Object} [options.imports=_.templateSettings.imports]
           *  An object to import into the template as free variables.
           * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
           *  The "interpolate" delimiter.
           * @param {string} [options.sourceURL='lodash.templateSources[n]']
           *  The sourceURL of the compiled template.
           * @param {string} [options.variable='obj']
           *  The data object variable name.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Function} Returns the compiled template function.
           * @example
           *
           * // Use the "interpolate" delimiter to create a compiled template.
           * var compiled = _.template('hello <%= user %>!');
           * compiled({ 'user': 'fred' });
           * // => 'hello fred!'
           *
           * // Use the HTML "escape" delimiter to escape data property values.
           * var compiled = _.template('<b><%- value %></b>');
           * compiled({ 'value': '<script>' });
           * // => '<b>&lt;script&gt;</b>'
           *
           * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
           * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the internal `print` function in "evaluate" delimiters.
           * var compiled = _.template('<% print("hello " + user); %>!');
           * compiled({ 'user': 'barney' });
           * // => 'hello barney!'
           *
           * // Use the ES template literal delimiter as an "interpolate" delimiter.
           * // Disable support by replacing the "interpolate" delimiter.
           * var compiled = _.template('hello ${ user }!');
           * compiled({ 'user': 'pebbles' });
           * // => 'hello pebbles!'
           *
           * // Use backslashes to treat delimiters as plain text.
           * var compiled = _.template('<%= "\\<%- value %\\>" %>');
           * compiled({ 'value': 'ignored' });
           * // => '<%- value %>'
           *
           * // Use the `imports` option to import `jQuery` as `jq`.
           * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
           * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
           * compiled({ 'users': ['fred', 'barney'] });
           * // => '<li>fred</li><li>barney</li>'
           *
           * // Use the `sourceURL` option to specify a custom sourceURL for the template.
           * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
           * compiled(data);
           * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
           *
           * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
           * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
           * compiled.source;
           * // => function(data) {
           * //   var __t, __p = '';
           * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
           * //   return __p;
           * // }
           *
           * // Use custom template delimiters.
           * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
           * var compiled = _.template('hello {{ user }}!');
           * compiled({ 'user': 'mustache' });
           * // => 'hello mustache!'
           *
           * // Use the `source` property to inline compiled templates for meaningful
           * // line numbers in error messages and stack traces.
           * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
           *   var JST = {\
           *     "main": ' + _.template(mainText).source + '\
           *   };\
           * ');
           */
          function template(string, options, guard) {
            // Based on John Resig's `tmpl` implementation
            // (http://ejohn.org/blog/javascript-micro-templating/)
            // and Laura Doktorova's doT.js (https://github.com/olado/doT).
            var settings = lodash.templateSettings;
            if (guard && isIterateeCall(string, options, guard)) {
              options = undefined;
            }
            string = toString(string);
            options = assignInWith({}, options, settings, customDefaultsAssignIn);
            var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
              importsKeys = keys(imports),
              importsValues = baseValues(imports, importsKeys);
            var isEscaping,
              isEvaluating,
              index = 0,
              interpolate = options.interpolate || reNoMatch,
              source = "__p += '";

            // Compile the regexp to match each delimiter.
            var reDelimiters = RegExp((options.escape || reNoMatch).source + '|' + interpolate.source + '|' + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' + (options.evaluate || reNoMatch).source + '|$', 'g');

            // Use a sourceURL for easier debugging.
            // The sourceURL gets injected into the source that's eval-ed, so be careful
            // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
            // and escape the comment, thus injecting code that gets evaled.
            var sourceURL = '//# sourceURL=' + (hasOwnProperty.call(options, 'sourceURL') ? (options.sourceURL + '').replace(/\s/g, ' ') : 'lodash.templateSources[' + ++templateCounter + ']') + '\n';
            string.replace(reDelimiters, function (match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
              interpolateValue || (interpolateValue = esTemplateValue);

              // Escape characters that can't be included in string literals.
              source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

              // Replace delimiters with snippets.
              if (escapeValue) {
                isEscaping = true;
                source += "' +\n__e(" + escapeValue + ") +\n'";
              }
              if (evaluateValue) {
                isEvaluating = true;
                source += "';\n" + evaluateValue + ";\n__p += '";
              }
              if (interpolateValue) {
                source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
              }
              index = offset + match.length;

              // The JS engine embedded in Adobe products needs `match` returned in
              // order to produce the correct `offset` value.
              return match;
            });
            source += "';\n";

            // If `variable` is not specified wrap a with-statement around the generated
            // code to add the data object to the top of the scope chain.
            var variable = hasOwnProperty.call(options, 'variable') && options.variable;
            if (!variable) {
              source = 'with (obj) {\n' + source + '\n}\n';
            }
            // Throw an error if a forbidden character was found in `variable`, to prevent
            // potential command injection attacks.
            else if (reForbiddenIdentifierChars.test(variable)) {
              throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
            }

            // Cleanup code by stripping empty strings.
            source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source).replace(reEmptyStringMiddle, '$1').replace(reEmptyStringTrailing, '$1;');

            // Frame code as the function body.
            source = 'function(' + (variable || 'obj') + ') {\n' + (variable ? '' : 'obj || (obj = {});\n') + "var __t, __p = ''" + (isEscaping ? ', __e = _.escape' : '') + (isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n') + source + 'return __p\n}';
            var result = attempt(function () {
              return Function(importsKeys, sourceURL + 'return ' + source).apply(undefined, importsValues);
            });

            // Provide the compiled function's source by its `toString` method or
            // the `source` property as a convenience for inlining compiled templates.
            result.source = source;
            if (isError(result)) {
              throw result;
            }
            return result;
          }

          /**
           * Converts `string`, as a whole, to lower case just like
           * [String#toLowerCase](https://mdn.io/toLowerCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the lower cased string.
           * @example
           *
           * _.toLower('--Foo-Bar--');
           * // => '--foo-bar--'
           *
           * _.toLower('fooBar');
           * // => 'foobar'
           *
           * _.toLower('__FOO_BAR__');
           * // => '__foo_bar__'
           */
          function toLower(value) {
            return toString(value).toLowerCase();
          }

          /**
           * Converts `string`, as a whole, to upper case just like
           * [String#toUpperCase](https://mdn.io/toUpperCase).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.toUpper('--foo-bar--');
           * // => '--FOO-BAR--'
           *
           * _.toUpper('fooBar');
           * // => 'FOOBAR'
           *
           * _.toUpper('__foo_bar__');
           * // => '__FOO_BAR__'
           */
          function toUpper(value) {
            return toString(value).toUpperCase();
          }

          /**
           * Removes leading and trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trim('  abc  ');
           * // => 'abc'
           *
           * _.trim('-_-abc-_-', '_-');
           * // => 'abc'
           *
           * _.map(['  foo  ', '  bar  '], _.trim);
           * // => ['foo', 'bar']
           */
          function trim(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
              return baseTrim(string);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string),
              chrSymbols = stringToArray(chars),
              start = charsStartIndex(strSymbols, chrSymbols),
              end = charsEndIndex(strSymbols, chrSymbols) + 1;
            return castSlice(strSymbols, start, end).join('');
          }

          /**
           * Removes trailing whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimEnd('  abc  ');
           * // => '  abc'
           *
           * _.trimEnd('-_-abc-_-', '_-');
           * // => '-_-abc'
           */
          function trimEnd(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
              return string.slice(0, trimmedEndIndex(string) + 1);
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string),
              end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
            return castSlice(strSymbols, 0, end).join('');
          }

          /**
           * Removes leading whitespace or specified characters from `string`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to trim.
           * @param {string} [chars=whitespace] The characters to trim.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {string} Returns the trimmed string.
           * @example
           *
           * _.trimStart('  abc  ');
           * // => 'abc  '
           *
           * _.trimStart('-_-abc-_-', '_-');
           * // => 'abc-_-'
           */
          function trimStart(string, chars, guard) {
            string = toString(string);
            if (string && (guard || chars === undefined)) {
              return string.replace(reTrimStart, '');
            }
            if (!string || !(chars = baseToString(chars))) {
              return string;
            }
            var strSymbols = stringToArray(string),
              start = charsStartIndex(strSymbols, stringToArray(chars));
            return castSlice(strSymbols, start).join('');
          }

          /**
           * Truncates `string` if it's longer than the given maximum string length.
           * The last characters of the truncated string are replaced with the omission
           * string which defaults to "...".
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to truncate.
           * @param {Object} [options={}] The options object.
           * @param {number} [options.length=30] The maximum string length.
           * @param {string} [options.omission='...'] The string to indicate text is omitted.
           * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
           * @returns {string} Returns the truncated string.
           * @example
           *
           * _.truncate('hi-diddly-ho there, neighborino');
           * // => 'hi-diddly-ho there, neighbo...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': ' '
           * });
           * // => 'hi-diddly-ho there,...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'length': 24,
           *   'separator': /,? +/
           * });
           * // => 'hi-diddly-ho there...'
           *
           * _.truncate('hi-diddly-ho there, neighborino', {
           *   'omission': ' [...]'
           * });
           * // => 'hi-diddly-ho there, neig [...]'
           */
          function truncate(string, options) {
            var length = DEFAULT_TRUNC_LENGTH,
              omission = DEFAULT_TRUNC_OMISSION;
            if (isObject(options)) {
              var separator = 'separator' in options ? options.separator : separator;
              length = 'length' in options ? toInteger(options.length) : length;
              omission = 'omission' in options ? baseToString(options.omission) : omission;
            }
            string = toString(string);
            var strLength = string.length;
            if (hasUnicode(string)) {
              var strSymbols = stringToArray(string);
              strLength = strSymbols.length;
            }
            if (length >= strLength) {
              return string;
            }
            var end = length - stringSize(omission);
            if (end < 1) {
              return omission;
            }
            var result = strSymbols ? castSlice(strSymbols, 0, end).join('') : string.slice(0, end);
            if (separator === undefined) {
              return result + omission;
            }
            if (strSymbols) {
              end += result.length - end;
            }
            if (isRegExp(separator)) {
              if (string.slice(end).search(separator)) {
                var match,
                  substring = result;
                if (!separator.global) {
                  separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
                }
                separator.lastIndex = 0;
                while (match = separator.exec(substring)) {
                  var newEnd = match.index;
                }
                result = result.slice(0, newEnd === undefined ? end : newEnd);
              }
            } else if (string.indexOf(baseToString(separator), end) != end) {
              var index = result.lastIndexOf(separator);
              if (index > -1) {
                result = result.slice(0, index);
              }
            }
            return result + omission;
          }

          /**
           * The inverse of `_.escape`; this method converts the HTML entities
           * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
           * their corresponding characters.
           *
           * **Note:** No other HTML entities are unescaped. To unescape additional
           * HTML entities use a third-party library like [_he_](https://mths.be/he).
           *
           * @static
           * @memberOf _
           * @since 0.6.0
           * @category String
           * @param {string} [string=''] The string to unescape.
           * @returns {string} Returns the unescaped string.
           * @example
           *
           * _.unescape('fred, barney, &amp; pebbles');
           * // => 'fred, barney, & pebbles'
           */
          function unescape(string) {
            string = toString(string);
            return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
          }

          /**
           * Converts `string`, as space separated words, to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the upper cased string.
           * @example
           *
           * _.upperCase('--foo-bar');
           * // => 'FOO BAR'
           *
           * _.upperCase('fooBar');
           * // => 'FOO BAR'
           *
           * _.upperCase('__foo_bar__');
           * // => 'FOO BAR'
           */
          var upperCase = createCompounder(function (result, word, index) {
            return result + (index ? ' ' : '') + word.toUpperCase();
          });

          /**
           * Converts the first character of `string` to upper case.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category String
           * @param {string} [string=''] The string to convert.
           * @returns {string} Returns the converted string.
           * @example
           *
           * _.upperFirst('fred');
           * // => 'Fred'
           *
           * _.upperFirst('FRED');
           * // => 'FRED'
           */
          var upperFirst = createCaseFirst('toUpperCase');

          /**
           * Splits `string` into an array of its words.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category String
           * @param {string} [string=''] The string to inspect.
           * @param {RegExp|string} [pattern] The pattern to match words.
           * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
           * @returns {Array} Returns the words of `string`.
           * @example
           *
           * _.words('fred, barney, & pebbles');
           * // => ['fred', 'barney', 'pebbles']
           *
           * _.words('fred, barney, & pebbles', /[^, ]+/g);
           * // => ['fred', 'barney', '&', 'pebbles']
           */
          function words(string, pattern, guard) {
            string = toString(string);
            pattern = guard ? undefined : pattern;
            if (pattern === undefined) {
              return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
            }
            return string.match(pattern) || [];
          }

          /*------------------------------------------------------------------------*/

          /**
           * Attempts to invoke `func`, returning either the result or the caught error
           * object. Any additional arguments are provided to `func` when it's invoked.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Function} func The function to attempt.
           * @param {...*} [args] The arguments to invoke `func` with.
           * @returns {*} Returns the `func` result or error object.
           * @example
           *
           * // Avoid throwing errors for invalid selectors.
           * var elements = _.attempt(function(selector) {
           *   return document.querySelectorAll(selector);
           * }, '>_>');
           *
           * if (_.isError(elements)) {
           *   elements = [];
           * }
           */
          var attempt = baseRest(function (func, args) {
            try {
              return apply(func, undefined, args);
            } catch (e) {
              return isError(e) ? e : new Error(e);
            }
          });

          /**
           * Binds methods of an object to the object itself, overwriting the existing
           * method.
           *
           * **Note:** This method doesn't set the "length" property of bound functions.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Object} object The object to bind and assign the bound methods to.
           * @param {...(string|string[])} methodNames The object method names to bind.
           * @returns {Object} Returns `object`.
           * @example
           *
           * var view = {
           *   'label': 'docs',
           *   'click': function() {
           *     console.log('clicked ' + this.label);
           *   }
           * };
           *
           * _.bindAll(view, ['click']);
           * jQuery(element).on('click', view.click);
           * // => Logs 'clicked docs' when clicked.
           */
          var bindAll = flatRest(function (object, methodNames) {
            arrayEach(methodNames, function (key) {
              key = toKey(key);
              baseAssignValue(object, key, bind(object[key], object));
            });
            return object;
          });

          /**
           * Creates a function that iterates over `pairs` and invokes the corresponding
           * function of the first predicate to return truthy. The predicate-function
           * pairs are invoked with the `this` binding and arguments of the created
           * function.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Array} pairs The predicate-function pairs.
           * @returns {Function} Returns the new composite function.
           * @example
           *
           * var func = _.cond([
           *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
           *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
           *   [_.stubTrue,                      _.constant('no match')]
           * ]);
           *
           * func({ 'a': 1, 'b': 2 });
           * // => 'matches A'
           *
           * func({ 'a': 0, 'b': 1 });
           * // => 'matches B'
           *
           * func({ 'a': '1', 'b': '2' });
           * // => 'no match'
           */
          function cond(pairs) {
            var length = pairs == null ? 0 : pairs.length,
              toIteratee = getIteratee();
            pairs = !length ? [] : arrayMap(pairs, function (pair) {
              if (typeof pair[1] != 'function') {
                throw new TypeError(FUNC_ERROR_TEXT);
              }
              return [toIteratee(pair[0]), pair[1]];
            });
            return baseRest(function (args) {
              var index = -1;
              while (++index < length) {
                var pair = pairs[index];
                if (apply(pair[0], this, args)) {
                  return apply(pair[1], this, args);
                }
              }
            });
          }

          /**
           * Creates a function that invokes the predicate properties of `source` with
           * the corresponding property values of a given object, returning `true` if
           * all predicates return truthy, else `false`.
           *
           * **Note:** The created function is equivalent to `_.conformsTo` with
           * `source` partially applied.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {Object} source The object of property predicates to conform to.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 2, 'b': 1 },
           *   { 'a': 1, 'b': 2 }
           * ];
           *
           * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
           * // => [{ 'a': 1, 'b': 2 }]
           */
          function conforms(source) {
            return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
          }

          /**
           * Creates a function that returns `value`.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {*} value The value to return from the new function.
           * @returns {Function} Returns the new constant function.
           * @example
           *
           * var objects = _.times(2, _.constant({ 'a': 1 }));
           *
           * console.log(objects);
           * // => [{ 'a': 1 }, { 'a': 1 }]
           *
           * console.log(objects[0] === objects[1]);
           * // => true
           */
          function constant(value) {
            return function () {
              return value;
            };
          }

          /**
           * Checks `value` to determine whether a default value should be returned in
           * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
           * or `undefined`.
           *
           * @static
           * @memberOf _
           * @since 4.14.0
           * @category Util
           * @param {*} value The value to check.
           * @param {*} defaultValue The default value.
           * @returns {*} Returns the resolved value.
           * @example
           *
           * _.defaultTo(1, 10);
           * // => 1
           *
           * _.defaultTo(undefined, 10);
           * // => 10
           */
          function defaultTo(value, defaultValue) {
            return value == null || value !== value ? defaultValue : value;
          }

          /**
           * Creates a function that returns the result of invoking the given functions
           * with the `this` binding of the created function, where each successive
           * invocation is supplied the return value of the previous.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flowRight
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flow([_.add, square]);
           * addSquare(1, 2);
           * // => 9
           */
          var flow = createFlow();

          /**
           * This method is like `_.flow` except that it creates a function that
           * invokes the given functions from right to left.
           *
           * @static
           * @since 3.0.0
           * @memberOf _
           * @category Util
           * @param {...(Function|Function[])} [funcs] The functions to invoke.
           * @returns {Function} Returns the new composite function.
           * @see _.flow
           * @example
           *
           * function square(n) {
           *   return n * n;
           * }
           *
           * var addSquare = _.flowRight([square, _.add]);
           * addSquare(1, 2);
           * // => 9
           */
          var flowRight = createFlow(true);

          /**
           * This method returns the first argument it receives.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {*} value Any value.
           * @returns {*} Returns `value`.
           * @example
           *
           * var object = { 'a': 1 };
           *
           * console.log(_.identity(object) === object);
           * // => true
           */
          function identity(value) {
            return value;
          }

          /**
           * Creates a function that invokes `func` with the arguments of the created
           * function. If `func` is a property name, the created function returns the
           * property value for a given element. If `func` is an array or object, the
           * created function returns `true` for elements that contain the equivalent
           * source properties, otherwise it returns `false`.
           *
           * @static
           * @since 4.0.0
           * @memberOf _
           * @category Util
           * @param {*} [func=_.identity] The value to convert to a callback.
           * @returns {Function} Returns the callback.
           * @example
           *
           * var users = [
           *   { 'user': 'barney', 'age': 36, 'active': true },
           *   { 'user': 'fred',   'age': 40, 'active': false }
           * ];
           *
           * // The `_.matches` iteratee shorthand.
           * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
           * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
           *
           * // The `_.matchesProperty` iteratee shorthand.
           * _.filter(users, _.iteratee(['user', 'fred']));
           * // => [{ 'user': 'fred', 'age': 40 }]
           *
           * // The `_.property` iteratee shorthand.
           * _.map(users, _.iteratee('user'));
           * // => ['barney', 'fred']
           *
           * // Create custom iteratee shorthands.
           * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
           *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
           *     return func.test(string);
           *   };
           * });
           *
           * _.filter(['abc', 'def'], /ef/);
           * // => ['def']
           */
          function iteratee(func) {
            return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
          }

          /**
           * Creates a function that performs a partial deep comparison between a given
           * object and `source`, returning `true` if the given object has equivalent
           * property values, else `false`.
           *
           * **Note:** The created function is equivalent to `_.isMatch` with `source`
           * partially applied.
           *
           * Partial comparisons will match empty array and empty object `source`
           * values against any array or object value, respectively. See `_.isEqual`
           * for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} source The object of property values to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
           * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */
          function matches(source) {
            return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
          }

          /**
           * Creates a function that performs a partial deep comparison between the
           * value at `path` of a given object to `srcValue`, returning `true` if the
           * object value is equivalent, else `false`.
           *
           * **Note:** Partial comparisons will match empty array and empty object
           * `srcValue` values against any array or object value, respectively. See
           * `_.isEqual` for a list of supported value comparisons.
           *
           * **Note:** Multiple values can be checked by combining several matchers
           * using `_.overSome`
           *
           * @static
           * @memberOf _
           * @since 3.2.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @param {*} srcValue The value to match.
           * @returns {Function} Returns the new spec function.
           * @example
           *
           * var objects = [
           *   { 'a': 1, 'b': 2, 'c': 3 },
           *   { 'a': 4, 'b': 5, 'c': 6 }
           * ];
           *
           * _.find(objects, _.matchesProperty('a', 4));
           * // => { 'a': 4, 'b': 5, 'c': 6 }
           *
           * // Checking for several possible values
           * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
           * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
           */
          function matchesProperty(path, srcValue) {
            return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
          }

          /**
           * Creates a function that invokes the method at `path` of a given object.
           * Any additional arguments are provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Array|string} path The path of the method to invoke.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': _.constant(2) } },
           *   { 'a': { 'b': _.constant(1) } }
           * ];
           *
           * _.map(objects, _.method('a.b'));
           * // => [2, 1]
           *
           * _.map(objects, _.method(['a', 'b']));
           * // => [2, 1]
           */
          var method = baseRest(function (path, args) {
            return function (object) {
              return baseInvoke(object, path, args);
            };
          });

          /**
           * The opposite of `_.method`; this method creates a function that invokes
           * the method at a given path of `object`. Any additional arguments are
           * provided to the invoked method.
           *
           * @static
           * @memberOf _
           * @since 3.7.0
           * @category Util
           * @param {Object} object The object to query.
           * @param {...*} [args] The arguments to invoke the method with.
           * @returns {Function} Returns the new invoker function.
           * @example
           *
           * var array = _.times(3, _.constant),
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.methodOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
           * // => [2, 0]
           */
          var methodOf = baseRest(function (object, args) {
            return function (path) {
              return baseInvoke(object, path, args);
            };
          });

          /**
           * Adds all own enumerable string keyed function properties of a source
           * object to the destination object. If `object` is a function, then methods
           * are added to its prototype as well.
           *
           * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
           * avoid conflicts caused by modifying the original.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {Function|Object} [object=lodash] The destination object.
           * @param {Object} source The object of functions to add.
           * @param {Object} [options={}] The options object.
           * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
           * @returns {Function|Object} Returns `object`.
           * @example
           *
           * function vowels(string) {
           *   return _.filter(string, function(v) {
           *     return /[aeiou]/i.test(v);
           *   });
           * }
           *
           * _.mixin({ 'vowels': vowels });
           * _.vowels('fred');
           * // => ['e']
           *
           * _('fred').vowels().value();
           * // => ['e']
           *
           * _.mixin({ 'vowels': vowels }, { 'chain': false });
           * _('fred').vowels();
           * // => ['e']
           */
          function mixin(object, source, options) {
            var props = keys(source),
              methodNames = baseFunctions(source, props);
            if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
              options = source;
              source = object;
              object = this;
              methodNames = baseFunctions(source, keys(source));
            }
            var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
              isFunc = isFunction(object);
            arrayEach(methodNames, function (methodName) {
              var func = source[methodName];
              object[methodName] = func;
              if (isFunc) {
                object.prototype[methodName] = function () {
                  var chainAll = this.__chain__;
                  if (chain || chainAll) {
                    var result = object(this.__wrapped__),
                      actions = result.__actions__ = copyArray(this.__actions__);
                    actions.push({
                      'func': func,
                      'args': arguments,
                      'thisArg': object
                    });
                    result.__chain__ = chainAll;
                    return result;
                  }
                  return func.apply(object, arrayPush([this.value()], arguments));
                };
              }
            });
            return object;
          }

          /**
           * Reverts the `_` variable to its previous value and returns a reference to
           * the `lodash` function.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @returns {Function} Returns the `lodash` function.
           * @example
           *
           * var lodash = _.noConflict();
           */
          function noConflict() {
            if (root._ === this) {
              root._ = oldDash;
            }
            return this;
          }

          /**
           * This method returns `undefined`.
           *
           * @static
           * @memberOf _
           * @since 2.3.0
           * @category Util
           * @example
           *
           * _.times(2, _.noop);
           * // => [undefined, undefined]
           */
          function noop() {
            // No operation performed.
          }

          /**
           * Creates a function that gets the argument at index `n`. If `n` is negative,
           * the nth argument from the end is returned.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [n=0] The index of the argument to return.
           * @returns {Function} Returns the new pass-thru function.
           * @example
           *
           * var func = _.nthArg(1);
           * func('a', 'b', 'c', 'd');
           * // => 'b'
           *
           * var func = _.nthArg(-2);
           * func('a', 'b', 'c', 'd');
           * // => 'c'
           */
          function nthArg(n) {
            n = toInteger(n);
            return baseRest(function (args) {
              return baseNth(args, n);
            });
          }

          /**
           * Creates a function that invokes `iteratees` with the arguments it receives
           * and returns their results.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [iteratees=[_.identity]]
           *  The iteratees to invoke.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.over([Math.max, Math.min]);
           *
           * func(1, 2, 3, 4);
           * // => [4, 1]
           */
          var over = createOver(arrayMap);

          /**
           * Creates a function that checks if **all** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overEvery([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => false
           *
           * func(NaN);
           * // => false
           */
          var overEvery = createOver(arrayEvery);

          /**
           * Creates a function that checks if **any** of the `predicates` return
           * truthy when invoked with the arguments it receives.
           *
           * Following shorthands are possible for providing predicates.
           * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
           * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {...(Function|Function[])} [predicates=[_.identity]]
           *  The predicates to check.
           * @returns {Function} Returns the new function.
           * @example
           *
           * var func = _.overSome([Boolean, isFinite]);
           *
           * func('1');
           * // => true
           *
           * func(null);
           * // => true
           *
           * func(NaN);
           * // => false
           *
           * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
           * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
           */
          var overSome = createOver(arraySome);

          /**
           * Creates a function that returns the value at `path` of a given object.
           *
           * @static
           * @memberOf _
           * @since 2.4.0
           * @category Util
           * @param {Array|string} path The path of the property to get.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var objects = [
           *   { 'a': { 'b': 2 } },
           *   { 'a': { 'b': 1 } }
           * ];
           *
           * _.map(objects, _.property('a.b'));
           * // => [2, 1]
           *
           * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
           * // => [1, 2]
           */
          function property(path) {
            return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
          }

          /**
           * The opposite of `_.property`; this method creates a function that returns
           * the value at a given path of `object`.
           *
           * @static
           * @memberOf _
           * @since 3.0.0
           * @category Util
           * @param {Object} object The object to query.
           * @returns {Function} Returns the new accessor function.
           * @example
           *
           * var array = [0, 1, 2],
           *     object = { 'a': array, 'b': array, 'c': array };
           *
           * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
           * // => [2, 0]
           *
           * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
           * // => [2, 0]
           */
          function propertyOf(object) {
            return function (path) {
              return object == null ? undefined : baseGet(object, path);
            };
          }

          /**
           * Creates an array of numbers (positive and/or negative) progressing from
           * `start` up to, but not including, `end`. A step of `-1` is used if a negative
           * `start` is specified without an `end` or `step`. If `end` is not specified,
           * it's set to `start` with `start` then set to `0`.
           *
           * **Note:** JavaScript follows the IEEE-754 standard for resolving
           * floating-point values which can produce unexpected results.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.rangeRight
           * @example
           *
           * _.range(4);
           * // => [0, 1, 2, 3]
           *
           * _.range(-4);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 5);
           * // => [1, 2, 3, 4]
           *
           * _.range(0, 20, 5);
           * // => [0, 5, 10, 15]
           *
           * _.range(0, -4, -1);
           * // => [0, -1, -2, -3]
           *
           * _.range(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.range(0);
           * // => []
           */
          var range = createRange();

          /**
           * This method is like `_.range` except that it populates values in
           * descending order.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {number} [start=0] The start of the range.
           * @param {number} end The end of the range.
           * @param {number} [step=1] The value to increment or decrement by.
           * @returns {Array} Returns the range of numbers.
           * @see _.inRange, _.range
           * @example
           *
           * _.rangeRight(4);
           * // => [3, 2, 1, 0]
           *
           * _.rangeRight(-4);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 5);
           * // => [4, 3, 2, 1]
           *
           * _.rangeRight(0, 20, 5);
           * // => [15, 10, 5, 0]
           *
           * _.rangeRight(0, -4, -1);
           * // => [-3, -2, -1, 0]
           *
           * _.rangeRight(1, 4, 0);
           * // => [1, 1, 1]
           *
           * _.rangeRight(0);
           * // => []
           */
          var rangeRight = createRange(true);

          /**
           * This method returns a new empty array.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Array} Returns the new empty array.
           * @example
           *
           * var arrays = _.times(2, _.stubArray);
           *
           * console.log(arrays);
           * // => [[], []]
           *
           * console.log(arrays[0] === arrays[1]);
           * // => false
           */
          function stubArray() {
            return [];
          }

          /**
           * This method returns `false`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `false`.
           * @example
           *
           * _.times(2, _.stubFalse);
           * // => [false, false]
           */
          function stubFalse() {
            return false;
          }

          /**
           * This method returns a new empty object.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {Object} Returns the new empty object.
           * @example
           *
           * var objects = _.times(2, _.stubObject);
           *
           * console.log(objects);
           * // => [{}, {}]
           *
           * console.log(objects[0] === objects[1]);
           * // => false
           */
          function stubObject() {
            return {};
          }

          /**
           * This method returns an empty string.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {string} Returns the empty string.
           * @example
           *
           * _.times(2, _.stubString);
           * // => ['', '']
           */
          function stubString() {
            return '';
          }

          /**
           * This method returns `true`.
           *
           * @static
           * @memberOf _
           * @since 4.13.0
           * @category Util
           * @returns {boolean} Returns `true`.
           * @example
           *
           * _.times(2, _.stubTrue);
           * // => [true, true]
           */
          function stubTrue() {
            return true;
          }

          /**
           * Invokes the iteratee `n` times, returning an array of the results of
           * each invocation. The iteratee is invoked with one argument; (index).
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {number} n The number of times to invoke `iteratee`.
           * @param {Function} [iteratee=_.identity] The function invoked per iteration.
           * @returns {Array} Returns the array of results.
           * @example
           *
           * _.times(3, String);
           * // => ['0', '1', '2']
           *
           *  _.times(4, _.constant(0));
           * // => [0, 0, 0, 0]
           */
          function times(n, iteratee) {
            n = toInteger(n);
            if (n < 1 || n > MAX_SAFE_INTEGER) {
              return [];
            }
            var index = MAX_ARRAY_LENGTH,
              length = nativeMin(n, MAX_ARRAY_LENGTH);
            iteratee = getIteratee(iteratee);
            n -= MAX_ARRAY_LENGTH;
            var result = baseTimes(length, iteratee);
            while (++index < n) {
              iteratee(index);
            }
            return result;
          }

          /**
           * Converts `value` to a property path array.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Util
           * @param {*} value The value to convert.
           * @returns {Array} Returns the new property path array.
           * @example
           *
           * _.toPath('a.b.c');
           * // => ['a', 'b', 'c']
           *
           * _.toPath('a[0].b.c');
           * // => ['a', '0', 'b', 'c']
           */
          function toPath(value) {
            if (isArray(value)) {
              return arrayMap(value, toKey);
            }
            return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
          }

          /**
           * Generates a unique ID. If `prefix` is given, the ID is appended to it.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Util
           * @param {string} [prefix=''] The value to prefix the ID with.
           * @returns {string} Returns the unique ID.
           * @example
           *
           * _.uniqueId('contact_');
           * // => 'contact_104'
           *
           * _.uniqueId();
           * // => '105'
           */
          function uniqueId(prefix) {
            var id = ++idCounter;
            return toString(prefix) + id;
          }

          /*------------------------------------------------------------------------*/

          /**
           * Adds two numbers.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {number} augend The first number in an addition.
           * @param {number} addend The second number in an addition.
           * @returns {number} Returns the total.
           * @example
           *
           * _.add(6, 4);
           * // => 10
           */
          var add = createMathOperation(function (augend, addend) {
            return augend + addend;
          }, 0);

          /**
           * Computes `number` rounded up to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round up.
           * @param {number} [precision=0] The precision to round up to.
           * @returns {number} Returns the rounded up number.
           * @example
           *
           * _.ceil(4.006);
           * // => 5
           *
           * _.ceil(6.004, 2);
           * // => 6.01
           *
           * _.ceil(6040, -2);
           * // => 6100
           */
          var ceil = createRound('ceil');

          /**
           * Divide two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} dividend The first number in a division.
           * @param {number} divisor The second number in a division.
           * @returns {number} Returns the quotient.
           * @example
           *
           * _.divide(6, 4);
           * // => 1.5
           */
          var divide = createMathOperation(function (dividend, divisor) {
            return dividend / divisor;
          }, 1);

          /**
           * Computes `number` rounded down to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round down.
           * @param {number} [precision=0] The precision to round down to.
           * @returns {number} Returns the rounded down number.
           * @example
           *
           * _.floor(4.006);
           * // => 4
           *
           * _.floor(0.046, 2);
           * // => 0.04
           *
           * _.floor(4060, -2);
           * // => 4000
           */
          var floor = createRound('floor');

          /**
           * Computes the maximum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * _.max([4, 2, 8, 6]);
           * // => 8
           *
           * _.max([]);
           * // => undefined
           */
          function max(array) {
            return array && array.length ? baseExtremum(array, identity, baseGt) : undefined;
          }

          /**
           * This method is like `_.max` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the maximum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.maxBy(objects, function(o) { return o.n; });
           * // => { 'n': 2 }
           *
           * // The `_.property` iteratee shorthand.
           * _.maxBy(objects, 'n');
           * // => { 'n': 2 }
           */
          function maxBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined;
          }

          /**
           * Computes the mean of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the mean.
           * @example
           *
           * _.mean([4, 2, 8, 6]);
           * // => 5
           */
          function mean(array) {
            return baseMean(array, identity);
          }

          /**
           * This method is like `_.mean` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be averaged.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the mean.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.meanBy(objects, function(o) { return o.n; });
           * // => 5
           *
           * // The `_.property` iteratee shorthand.
           * _.meanBy(objects, 'n');
           * // => 5
           */
          function meanBy(array, iteratee) {
            return baseMean(array, getIteratee(iteratee, 2));
          }

          /**
           * Computes the minimum value of `array`. If `array` is empty or falsey,
           * `undefined` is returned.
           *
           * @static
           * @since 0.1.0
           * @memberOf _
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * _.min([4, 2, 8, 6]);
           * // => 2
           *
           * _.min([]);
           * // => undefined
           */
          function min(array) {
            return array && array.length ? baseExtremum(array, identity, baseLt) : undefined;
          }

          /**
           * This method is like `_.min` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the criterion by which
           * the value is ranked. The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {*} Returns the minimum value.
           * @example
           *
           * var objects = [{ 'n': 1 }, { 'n': 2 }];
           *
           * _.minBy(objects, function(o) { return o.n; });
           * // => { 'n': 1 }
           *
           * // The `_.property` iteratee shorthand.
           * _.minBy(objects, 'n');
           * // => { 'n': 1 }
           */
          function minBy(array, iteratee) {
            return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined;
          }

          /**
           * Multiply two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.7.0
           * @category Math
           * @param {number} multiplier The first number in a multiplication.
           * @param {number} multiplicand The second number in a multiplication.
           * @returns {number} Returns the product.
           * @example
           *
           * _.multiply(6, 4);
           * // => 24
           */
          var multiply = createMathOperation(function (multiplier, multiplicand) {
            return multiplier * multiplicand;
          }, 1);

          /**
           * Computes `number` rounded to `precision`.
           *
           * @static
           * @memberOf _
           * @since 3.10.0
           * @category Math
           * @param {number} number The number to round.
           * @param {number} [precision=0] The precision to round to.
           * @returns {number} Returns the rounded number.
           * @example
           *
           * _.round(4.006);
           * // => 4
           *
           * _.round(4.006, 2);
           * // => 4.01
           *
           * _.round(4060, -2);
           * // => 4100
           */
          var round = createRound('round');

          /**
           * Subtract two numbers.
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {number} minuend The first number in a subtraction.
           * @param {number} subtrahend The second number in a subtraction.
           * @returns {number} Returns the difference.
           * @example
           *
           * _.subtract(6, 4);
           * // => 2
           */
          var subtract = createMathOperation(function (minuend, subtrahend) {
            return minuend - subtrahend;
          }, 0);

          /**
           * Computes the sum of the values in `array`.
           *
           * @static
           * @memberOf _
           * @since 3.4.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @returns {number} Returns the sum.
           * @example
           *
           * _.sum([4, 2, 8, 6]);
           * // => 20
           */
          function sum(array) {
            return array && array.length ? baseSum(array, identity) : 0;
          }

          /**
           * This method is like `_.sum` except that it accepts `iteratee` which is
           * invoked for each element in `array` to generate the value to be summed.
           * The iteratee is invoked with one argument: (value).
           *
           * @static
           * @memberOf _
           * @since 4.0.0
           * @category Math
           * @param {Array} array The array to iterate over.
           * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
           * @returns {number} Returns the sum.
           * @example
           *
           * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
           *
           * _.sumBy(objects, function(o) { return o.n; });
           * // => 20
           *
           * // The `_.property` iteratee shorthand.
           * _.sumBy(objects, 'n');
           * // => 20
           */
          function sumBy(array, iteratee) {
            return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0;
          }

          /*------------------------------------------------------------------------*/

          // Add methods that return wrapped values in chain sequences.
          lodash.after = after;
          lodash.ary = ary;
          lodash.assign = assign;
          lodash.assignIn = assignIn;
          lodash.assignInWith = assignInWith;
          lodash.assignWith = assignWith;
          lodash.at = at;
          lodash.before = before;
          lodash.bind = bind;
          lodash.bindAll = bindAll;
          lodash.bindKey = bindKey;
          lodash.castArray = castArray;
          lodash.chain = chain;
          lodash.chunk = chunk;
          lodash.compact = compact;
          lodash.concat = concat;
          lodash.cond = cond;
          lodash.conforms = conforms;
          lodash.constant = constant;
          lodash.countBy = countBy;
          lodash.create = create;
          lodash.curry = curry;
          lodash.curryRight = curryRight;
          lodash.debounce = debounce;
          lodash.defaults = defaults;
          lodash.defaultsDeep = defaultsDeep;
          lodash.defer = defer;
          lodash.delay = delay;
          lodash.difference = difference;
          lodash.differenceBy = differenceBy;
          lodash.differenceWith = differenceWith;
          lodash.drop = drop;
          lodash.dropRight = dropRight;
          lodash.dropRightWhile = dropRightWhile;
          lodash.dropWhile = dropWhile;
          lodash.fill = fill;
          lodash.filter = filter;
          lodash.flatMap = flatMap;
          lodash.flatMapDeep = flatMapDeep;
          lodash.flatMapDepth = flatMapDepth;
          lodash.flatten = flatten;
          lodash.flattenDeep = flattenDeep;
          lodash.flattenDepth = flattenDepth;
          lodash.flip = flip;
          lodash.flow = flow;
          lodash.flowRight = flowRight;
          lodash.fromPairs = fromPairs;
          lodash.functions = functions;
          lodash.functionsIn = functionsIn;
          lodash.groupBy = groupBy;
          lodash.initial = initial;
          lodash.intersection = intersection;
          lodash.intersectionBy = intersectionBy;
          lodash.intersectionWith = intersectionWith;
          lodash.invert = invert;
          lodash.invertBy = invertBy;
          lodash.invokeMap = invokeMap;
          lodash.iteratee = iteratee;
          lodash.keyBy = keyBy;
          lodash.keys = keys;
          lodash.keysIn = keysIn;
          lodash.map = map;
          lodash.mapKeys = mapKeys;
          lodash.mapValues = mapValues;
          lodash.matches = matches;
          lodash.matchesProperty = matchesProperty;
          lodash.memoize = memoize;
          lodash.merge = merge;
          lodash.mergeWith = mergeWith;
          lodash.method = method;
          lodash.methodOf = methodOf;
          lodash.mixin = mixin;
          lodash.negate = negate;
          lodash.nthArg = nthArg;
          lodash.omit = omit;
          lodash.omitBy = omitBy;
          lodash.once = once;
          lodash.orderBy = orderBy;
          lodash.over = over;
          lodash.overArgs = overArgs;
          lodash.overEvery = overEvery;
          lodash.overSome = overSome;
          lodash.partial = partial;
          lodash.partialRight = partialRight;
          lodash.partition = partition;
          lodash.pick = pick;
          lodash.pickBy = pickBy;
          lodash.property = property;
          lodash.propertyOf = propertyOf;
          lodash.pull = pull;
          lodash.pullAll = pullAll;
          lodash.pullAllBy = pullAllBy;
          lodash.pullAllWith = pullAllWith;
          lodash.pullAt = pullAt;
          lodash.range = range;
          lodash.rangeRight = rangeRight;
          lodash.rearg = rearg;
          lodash.reject = reject;
          lodash.remove = remove;
          lodash.rest = rest;
          lodash.reverse = reverse;
          lodash.sampleSize = sampleSize;
          lodash.set = set;
          lodash.setWith = setWith;
          lodash.shuffle = shuffle;
          lodash.slice = slice;
          lodash.sortBy = sortBy;
          lodash.sortedUniq = sortedUniq;
          lodash.sortedUniqBy = sortedUniqBy;
          lodash.split = split;
          lodash.spread = spread;
          lodash.tail = tail;
          lodash.take = take;
          lodash.takeRight = takeRight;
          lodash.takeRightWhile = takeRightWhile;
          lodash.takeWhile = takeWhile;
          lodash.tap = tap;
          lodash.throttle = throttle;
          lodash.thru = thru;
          lodash.toArray = toArray;
          lodash.toPairs = toPairs;
          lodash.toPairsIn = toPairsIn;
          lodash.toPath = toPath;
          lodash.toPlainObject = toPlainObject;
          lodash.transform = transform;
          lodash.unary = unary;
          lodash.union = union;
          lodash.unionBy = unionBy;
          lodash.unionWith = unionWith;
          lodash.uniq = uniq;
          lodash.uniqBy = uniqBy;
          lodash.uniqWith = uniqWith;
          lodash.unset = unset;
          lodash.unzip = unzip;
          lodash.unzipWith = unzipWith;
          lodash.update = update;
          lodash.updateWith = updateWith;
          lodash.values = values;
          lodash.valuesIn = valuesIn;
          lodash.without = without;
          lodash.words = words;
          lodash.wrap = wrap;
          lodash.xor = xor;
          lodash.xorBy = xorBy;
          lodash.xorWith = xorWith;
          lodash.zip = zip;
          lodash.zipObject = zipObject;
          lodash.zipObjectDeep = zipObjectDeep;
          lodash.zipWith = zipWith;

          // Add aliases.
          lodash.entries = toPairs;
          lodash.entriesIn = toPairsIn;
          lodash.extend = assignIn;
          lodash.extendWith = assignInWith;

          // Add methods to `lodash.prototype`.
          mixin(lodash, lodash);

          /*------------------------------------------------------------------------*/

          // Add methods that return unwrapped values in chain sequences.
          lodash.add = add;
          lodash.attempt = attempt;
          lodash.camelCase = camelCase;
          lodash.capitalize = capitalize;
          lodash.ceil = ceil;
          lodash.clamp = clamp;
          lodash.clone = clone;
          lodash.cloneDeep = cloneDeep;
          lodash.cloneDeepWith = cloneDeepWith;
          lodash.cloneWith = cloneWith;
          lodash.conformsTo = conformsTo;
          lodash.deburr = deburr;
          lodash.defaultTo = defaultTo;
          lodash.divide = divide;
          lodash.endsWith = endsWith;
          lodash.eq = eq;
          lodash.escape = escape;
          lodash.escapeRegExp = escapeRegExp;
          lodash.every = every;
          lodash.find = find;
          lodash.findIndex = findIndex;
          lodash.findKey = findKey;
          lodash.findLast = findLast;
          lodash.findLastIndex = findLastIndex;
          lodash.findLastKey = findLastKey;
          lodash.floor = floor;
          lodash.forEach = forEach;
          lodash.forEachRight = forEachRight;
          lodash.forIn = forIn;
          lodash.forInRight = forInRight;
          lodash.forOwn = forOwn;
          lodash.forOwnRight = forOwnRight;
          lodash.get = get;
          lodash.gt = gt;
          lodash.gte = gte;
          lodash.has = has;
          lodash.hasIn = hasIn;
          lodash.head = head;
          lodash.identity = identity;
          lodash.includes = includes;
          lodash.indexOf = indexOf;
          lodash.inRange = inRange;
          lodash.invoke = invoke;
          lodash.isArguments = isArguments;
          lodash.isArray = isArray;
          lodash.isArrayBuffer = isArrayBuffer;
          lodash.isArrayLike = isArrayLike;
          lodash.isArrayLikeObject = isArrayLikeObject;
          lodash.isBoolean = isBoolean;
          lodash.isBuffer = isBuffer;
          lodash.isDate = isDate;
          lodash.isElement = isElement;
          lodash.isEmpty = isEmpty;
          lodash.isEqual = isEqual;
          lodash.isEqualWith = isEqualWith;
          lodash.isError = isError;
          lodash.isFinite = isFinite;
          lodash.isFunction = isFunction;
          lodash.isInteger = isInteger;
          lodash.isLength = isLength;
          lodash.isMap = isMap;
          lodash.isMatch = isMatch;
          lodash.isMatchWith = isMatchWith;
          lodash.isNaN = isNaN;
          lodash.isNative = isNative;
          lodash.isNil = isNil;
          lodash.isNull = isNull;
          lodash.isNumber = isNumber;
          lodash.isObject = isObject;
          lodash.isObjectLike = isObjectLike;
          lodash.isPlainObject = isPlainObject;
          lodash.isRegExp = isRegExp;
          lodash.isSafeInteger = isSafeInteger;
          lodash.isSet = isSet;
          lodash.isString = isString;
          lodash.isSymbol = isSymbol;
          lodash.isTypedArray = isTypedArray;
          lodash.isUndefined = isUndefined;
          lodash.isWeakMap = isWeakMap;
          lodash.isWeakSet = isWeakSet;
          lodash.join = join;
          lodash.kebabCase = kebabCase;
          lodash.last = last;
          lodash.lastIndexOf = lastIndexOf;
          lodash.lowerCase = lowerCase;
          lodash.lowerFirst = lowerFirst;
          lodash.lt = lt;
          lodash.lte = lte;
          lodash.max = max;
          lodash.maxBy = maxBy;
          lodash.mean = mean;
          lodash.meanBy = meanBy;
          lodash.min = min;
          lodash.minBy = minBy;
          lodash.stubArray = stubArray;
          lodash.stubFalse = stubFalse;
          lodash.stubObject = stubObject;
          lodash.stubString = stubString;
          lodash.stubTrue = stubTrue;
          lodash.multiply = multiply;
          lodash.nth = nth;
          lodash.noConflict = noConflict;
          lodash.noop = noop;
          lodash.now = now;
          lodash.pad = pad;
          lodash.padEnd = padEnd;
          lodash.padStart = padStart;
          lodash.parseInt = parseInt;
          lodash.random = random;
          lodash.reduce = reduce;
          lodash.reduceRight = reduceRight;
          lodash.repeat = repeat;
          lodash.replace = replace;
          lodash.result = result;
          lodash.round = round;
          lodash.runInContext = runInContext;
          lodash.sample = sample;
          lodash.size = size;
          lodash.snakeCase = snakeCase;
          lodash.some = some;
          lodash.sortedIndex = sortedIndex;
          lodash.sortedIndexBy = sortedIndexBy;
          lodash.sortedIndexOf = sortedIndexOf;
          lodash.sortedLastIndex = sortedLastIndex;
          lodash.sortedLastIndexBy = sortedLastIndexBy;
          lodash.sortedLastIndexOf = sortedLastIndexOf;
          lodash.startCase = startCase;
          lodash.startsWith = startsWith;
          lodash.subtract = subtract;
          lodash.sum = sum;
          lodash.sumBy = sumBy;
          lodash.template = template;
          lodash.times = times;
          lodash.toFinite = toFinite;
          lodash.toInteger = toInteger;
          lodash.toLength = toLength;
          lodash.toLower = toLower;
          lodash.toNumber = toNumber;
          lodash.toSafeInteger = toSafeInteger;
          lodash.toString = toString;
          lodash.toUpper = toUpper;
          lodash.trim = trim;
          lodash.trimEnd = trimEnd;
          lodash.trimStart = trimStart;
          lodash.truncate = truncate;
          lodash.unescape = unescape;
          lodash.uniqueId = uniqueId;
          lodash.upperCase = upperCase;
          lodash.upperFirst = upperFirst;

          // Add aliases.
          lodash.each = forEach;
          lodash.eachRight = forEachRight;
          lodash.first = head;
          mixin(lodash, function () {
            var source = {};
            baseForOwn(lodash, function (func, methodName) {
              if (!hasOwnProperty.call(lodash.prototype, methodName)) {
                source[methodName] = func;
              }
            });
            return source;
          }(), {
            'chain': false
          });

          /*------------------------------------------------------------------------*/

          /**
           * The semantic version number.
           *
           * @static
           * @memberOf _
           * @type {string}
           */
          lodash.VERSION = VERSION;

          // Assign default placeholders.
          arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function (methodName) {
            lodash[methodName].placeholder = lodash;
          });

          // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
          arrayEach(['drop', 'take'], function (methodName, index) {
            LazyWrapper.prototype[methodName] = function (n) {
              n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
              var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
              if (result.__filtered__) {
                result.__takeCount__ = nativeMin(n, result.__takeCount__);
              } else {
                result.__views__.push({
                  'size': nativeMin(n, MAX_ARRAY_LENGTH),
                  'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
                });
              }
              return result;
            };
            LazyWrapper.prototype[methodName + 'Right'] = function (n) {
              return this.reverse()[methodName](n).reverse();
            };
          });

          // Add `LazyWrapper` methods that accept an `iteratee` value.
          arrayEach(['filter', 'map', 'takeWhile'], function (methodName, index) {
            var type = index + 1,
              isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
            LazyWrapper.prototype[methodName] = function (iteratee) {
              var result = this.clone();
              result.__iteratees__.push({
                'iteratee': getIteratee(iteratee, 3),
                'type': type
              });
              result.__filtered__ = result.__filtered__ || isFilter;
              return result;
            };
          });

          // Add `LazyWrapper` methods for `_.head` and `_.last`.
          arrayEach(['head', 'last'], function (methodName, index) {
            var takeName = 'take' + (index ? 'Right' : '');
            LazyWrapper.prototype[methodName] = function () {
              return this[takeName](1).value()[0];
            };
          });

          // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
          arrayEach(['initial', 'tail'], function (methodName, index) {
            var dropName = 'drop' + (index ? '' : 'Right');
            LazyWrapper.prototype[methodName] = function () {
              return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
            };
          });
          LazyWrapper.prototype.compact = function () {
            return this.filter(identity);
          };
          LazyWrapper.prototype.find = function (predicate) {
            return this.filter(predicate).head();
          };
          LazyWrapper.prototype.findLast = function (predicate) {
            return this.reverse().find(predicate);
          };
          LazyWrapper.prototype.invokeMap = baseRest(function (path, args) {
            if (typeof path == 'function') {
              return new LazyWrapper(this);
            }
            return this.map(function (value) {
              return baseInvoke(value, path, args);
            });
          });
          LazyWrapper.prototype.reject = function (predicate) {
            return this.filter(negate(getIteratee(predicate)));
          };
          LazyWrapper.prototype.slice = function (start, end) {
            start = toInteger(start);
            var result = this;
            if (result.__filtered__ && (start > 0 || end < 0)) {
              return new LazyWrapper(result);
            }
            if (start < 0) {
              result = result.takeRight(-start);
            } else if (start) {
              result = result.drop(start);
            }
            if (end !== undefined) {
              end = toInteger(end);
              result = end < 0 ? result.dropRight(-end) : result.take(end - start);
            }
            return result;
          };
          LazyWrapper.prototype.takeRightWhile = function (predicate) {
            return this.reverse().takeWhile(predicate).reverse();
          };
          LazyWrapper.prototype.toArray = function () {
            return this.take(MAX_ARRAY_LENGTH);
          };

          // Add `LazyWrapper` methods to `lodash.prototype`.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
              isTaker = /^(?:head|last)$/.test(methodName),
              lodashFunc = lodash[isTaker ? 'take' + (methodName == 'last' ? 'Right' : '') : methodName],
              retUnwrapped = isTaker || /^find/.test(methodName);
            if (!lodashFunc) {
              return;
            }
            lodash.prototype[methodName] = function () {
              var value = this.__wrapped__,
                args = isTaker ? [1] : arguments,
                isLazy = value instanceof LazyWrapper,
                iteratee = args[0],
                useLazy = isLazy || isArray(value);
              var interceptor = function interceptor(value) {
                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                return isTaker && chainAll ? result[0] : result;
              };
              if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
                // Avoid lazy use if the iteratee has a "length" value other than `1`.
                isLazy = useLazy = false;
              }
              var chainAll = this.__chain__,
                isHybrid = !!this.__actions__.length,
                isUnwrapped = retUnwrapped && !chainAll,
                onlyLazy = isLazy && !isHybrid;
              if (!retUnwrapped && useLazy) {
                value = onlyLazy ? value : new LazyWrapper(this);
                var result = func.apply(value, args);
                result.__actions__.push({
                  'func': thru,
                  'args': [interceptor],
                  'thisArg': undefined
                });
                return new LodashWrapper(result, chainAll);
              }
              if (isUnwrapped && onlyLazy) {
                return func.apply(this, args);
              }
              result = this.thru(interceptor);
              return isUnwrapped ? isTaker ? result.value()[0] : result.value() : result;
            };
          });

          // Add `Array` methods to `lodash.prototype`.
          arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function (methodName) {
            var func = arrayProto[methodName],
              chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
              retUnwrapped = /^(?:pop|shift)$/.test(methodName);
            lodash.prototype[methodName] = function () {
              var args = arguments;
              if (retUnwrapped && !this.__chain__) {
                var value = this.value();
                return func.apply(isArray(value) ? value : [], args);
              }
              return this[chainName](function (value) {
                return func.apply(isArray(value) ? value : [], args);
              });
            };
          });

          // Map minified method names to their real names.
          baseForOwn(LazyWrapper.prototype, function (func, methodName) {
            var lodashFunc = lodash[methodName];
            if (lodashFunc) {
              var key = lodashFunc.name + '';
              if (!hasOwnProperty.call(realNames, key)) {
                realNames[key] = [];
              }
              realNames[key].push({
                'name': methodName,
                'func': lodashFunc
              });
            }
          });
          realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
            'name': 'wrapper',
            'func': undefined
          }];

          // Add methods to `LazyWrapper`.
          LazyWrapper.prototype.clone = lazyClone;
          LazyWrapper.prototype.reverse = lazyReverse;
          LazyWrapper.prototype.value = lazyValue;

          // Add chain sequence methods to the `lodash` wrapper.
          lodash.prototype.at = wrapperAt;
          lodash.prototype.chain = wrapperChain;
          lodash.prototype.commit = wrapperCommit;
          lodash.prototype.next = wrapperNext;
          lodash.prototype.plant = wrapperPlant;
          lodash.prototype.reverse = wrapperReverse;
          lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

          // Add lazy aliases.
          lodash.prototype.first = lodash.prototype.head;
          if (symIterator) {
            lodash.prototype[symIterator] = wrapperToIterator;
          }
          return lodash;
        };

        /*--------------------------------------------------------------------------*/

        // Export lodash.
        var _ = runInContext();

        // Some AMD build optimizers, like r.js, check for condition patterns like:
        if (true) {
          // Expose Lodash on the global object to prevent errors when Lodash is
          // loaded by a script tag in the presence of an AMD loader.
          // See http://requirejs.org/docs/errors.html#mismatch for more details.
          // Use `_.noConflict` to remove Lodash from the global object.
          root._ = _;

          // Define as an anonymous module so, through path mapping, it can be
          // referenced as the "underscore" module.
          !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
            return _;
          }.call(exports, __webpack_require__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
        }
        // Check for `exports` after `define` in case a build optimizer adds it.
        else {}
      }).call(this);

      /***/
    },

    /***/"./src/yjs-test.ts":
    /*!*************************!*\
      !*** ./src/yjs-test.ts ***!
      \*************************/
    /***/
    function srcYjsTestTs(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */testYJS: function testYJS() {
          return (/* binding */_testYJS
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var yjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! yjs */"./node_modules/yjs/dist/yjs.mjs");
      function _testYJS() {
        // Yjs documents are collections of
        // shared objects that sync automatically.
        var ydoc = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc();
        console.log("YJS Doc A created");
        // Define a shared Y.Map instance
        var ymap = ydoc.getMap();
        ymap.set('keyA', 'valueA');
        console.log("YJS keyA set to ValA");
        console.log(ymap.toJSON());

        // Create another Yjs document (simulating a remote user)
        // and create some conflicting changes
        var ydocRemote = new yjs__WEBPACK_IMPORTED_MODULE_0__.Doc();
        console.log("YJS Doc B created");
        var ymapRemote = ydocRemote.getMap();
        ymapRemote.set('keyB', 'valueB');
        console.log("YJS keyB set to ValB");
        console.log(ymapRemote.toJSON());

        // Merge changes from remote
        var update = yjs__WEBPACK_IMPORTED_MODULE_0__.encodeStateAsUpdate(ydocRemote);
        yjs__WEBPACK_IMPORTED_MODULE_0__.applyUpdate(ydoc, update);
        console.log("Docs A and B were merged");

        // Observe that the changes have merged
        console.log(ymap.toJSON()); // => { keyA: 'valueA', keyB: 'valueB' }
      }

      /***/
    },

    /***/"./node_modules/lib0/array.js":
    /*!************************************!*\
      !*** ./node_modules/lib0/array.js ***!
      \************************************/
    /***/
    function node_modulesLib0ArrayJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */appendTo: function appendTo() {
          return (/* binding */_appendTo
          );
        },
        /* harmony export */copy: function copy() {
          return (/* binding */_copy
          );
        },
        /* harmony export */create: function create() {
          return (/* binding */_create
          );
        },
        /* harmony export */equalFlat: function equalFlat() {
          return (/* binding */_equalFlat
          );
        },
        /* harmony export */every: function every() {
          return (/* binding */_every
          );
        },
        /* harmony export */flatten: function flatten() {
          return (/* binding */_flatten
          );
        },
        /* harmony export */fold: function fold() {
          return (/* binding */_fold
          );
        },
        /* harmony export */from: function from() {
          return (/* binding */_from
          );
        },
        /* harmony export */isArray: function isArray() {
          return (/* binding */_isArray
          );
        },
        /* harmony export */last: function last() {
          return (/* binding */_last
          );
        },
        /* harmony export */map: function map() {
          return (/* binding */_map
          );
        },
        /* harmony export */some: function some() {
          return (/* binding */_some
          );
        },
        /* harmony export */unfold: function unfold() {
          return (/* binding */_unfold
          );
        },
        /* harmony export */unique: function unique() {
          return (/* binding */_unique
          );
        },
        /* harmony export */uniqueBy: function uniqueBy() {
          return (/* binding */_uniqueBy
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _set_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./set.js */"./node_modules/lib0/set.js");
      /**
       * Utility module to work with Arrays.
       *
       * @module array
       */

      /**
       * Return the last element of an array. The element must exist
       *
       * @template L
       * @param {ArrayLike<L>} arr
       * @return {L}
       */
      var _last = function _last(arr) {
        return arr[arr.length - 1];
      };

      /**
       * @template C
       * @return {Array<C>}
       */
      var _create = function _create() {
        return (/** @type {Array<C>} */[]
        );
      };

      /**
       * @template D
       * @param {Array<D>} a
       * @return {Array<D>}
       */
      var _copy = function _copy(a) {
        return (/** @type {Array<D>} */a.slice()
        );
      };

      /**
       * Append elements from src to dest
       *
       * @template M
       * @param {Array<M>} dest
       * @param {Array<M>} src
       */
      var _appendTo = function _appendTo(dest, src) {
        for (var i = 0; i < src.length; i++) {
          dest.push(src[i]);
        }
      };

      /**
       * Transforms something array-like to an actual Array.
       *
       * @function
       * @template T
       * @param {ArrayLike<T>|Iterable<T>} arraylike
       * @return {T}
       */
      var _from = Array.from;

      /**
       * True iff condition holds on every element in the Array.
       *
       * @function
       * @template ITEM
       * @template {ArrayLike<ITEM>} ARR
       *
       * @param {ARR} arr
       * @param {function(ITEM, number, ARR):boolean} f
       * @return {boolean}
       */
      var _every = function _every(arr, f) {
        for (var i = 0; i < arr.length; i++) {
          if (!f(arr[i], i, arr)) {
            return false;
          }
        }
        return true;
      };

      /**
       * True iff condition holds on some element in the Array.
       *
       * @function
       * @template S
       * @template {ArrayLike<S>} ARR
       * @param {ARR} arr
       * @param {function(S, number, ARR):boolean} f
       * @return {boolean}
       */
      var _some = function _some(arr, f) {
        for (var i = 0; i < arr.length; i++) {
          if (f(arr[i], i, arr)) {
            return true;
          }
        }
        return false;
      };

      /**
       * @template ELEM
       *
       * @param {ArrayLike<ELEM>} a
       * @param {ArrayLike<ELEM>} b
       * @return {boolean}
       */
      var _equalFlat = function _equalFlat(a, b) {
        return a.length === b.length && _every(a, function (item, index) {
          return item === b[index];
        });
      };

      /**
       * @template ELEM
       * @param {Array<Array<ELEM>>} arr
       * @return {Array<ELEM>}
       */
      var _flatten = function _flatten(arr) {
        return _fold(arr, /** @type {Array<ELEM>} */[], function (acc, val) {
          return acc.concat(val);
        });
      };

      /**
       * @template T
       * @param {number} len
       * @param {function(number, Array<T>):T} f
       * @return {Array<T>}
       */
      var _unfold = function _unfold(len, f) {
        var array = new Array(len);
        for (var i = 0; i < len; i++) {
          array[i] = f(i, array);
        }
        return array;
      };

      /**
       * @template T
       * @template RESULT
       * @param {Array<T>} arr
       * @param {RESULT} seed
       * @param {function(RESULT, T, number):RESULT} folder
       */
      var _fold = function _fold(arr, seed, folder) {
        return arr.reduce(folder, seed);
      };
      var _isArray = Array.isArray;

      /**
       * @template T
       * @param {Array<T>} arr
       * @return {Array<T>}
       */
      var _unique = function _unique(arr) {
        return _from(_set_js__WEBPACK_IMPORTED_MODULE_0__.from(arr));
      };

      /**
       * @template T
       * @template M
       * @param {ArrayLike<T>} arr
       * @param {function(T):M} mapper
       * @return {Array<T>}
       */
      var _uniqueBy = function _uniqueBy(arr, mapper) {
        /**
         * @type {Set<M>}
         */
        var happened = _set_js__WEBPACK_IMPORTED_MODULE_0__.create();
        /**
         * @type {Array<T>}
         */
        var result = [];
        for (var i = 0; i < arr.length; i++) {
          var el = arr[i];
          var mapped = mapper(el);
          if (!happened.has(mapped)) {
            happened.add(mapped);
            result.push(el);
          }
        }
        return result;
      };

      /**
       * @template {ArrayLike<any>} ARR
       * @template {function(ARR extends ArrayLike<infer T> ? T : never, number, ARR):any} MAPPER
       * @param {ARR} arr
       * @param {MAPPER} mapper
       * @return {Array<MAPPER extends function(...any): infer M ? M : never>}
       */
      var _map = function _map(arr, mapper) {
        /**
         * @type {Array<any>}
         */
        var res = Array(arr.length);
        for (var i = 0; i < arr.length; i++) {
          res[i] = mapper( /** @type {any} */arr[i], i, /** @type {any} */arr);
        }
        return (/** @type {any} */res
        );
      };

      /***/
    },

    /***/"./node_modules/lib0/binary.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/binary.js ***!
      \*************************************/
    /***/
    function node_modulesLib0BinaryJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */BIT1: function BIT1() {
          return (/* binding */_BIT
          );
        },
        /* harmony export */BIT10: function BIT10() {
          return (/* binding */_BIT2
          );
        },
        /* harmony export */BIT11: function BIT11() {
          return (/* binding */_BIT3
          );
        },
        /* harmony export */BIT12: function BIT12() {
          return (/* binding */_BIT4
          );
        },
        /* harmony export */BIT13: function BIT13() {
          return (/* binding */_BIT5
          );
        },
        /* harmony export */BIT14: function BIT14() {
          return (/* binding */_BIT6
          );
        },
        /* harmony export */BIT15: function BIT15() {
          return (/* binding */_BIT7
          );
        },
        /* harmony export */BIT16: function BIT16() {
          return (/* binding */_BIT8
          );
        },
        /* harmony export */BIT17: function BIT17() {
          return (/* binding */_BIT9
          );
        },
        /* harmony export */BIT18: function BIT18() {
          return (/* binding */_BIT10
          );
        },
        /* harmony export */BIT19: function BIT19() {
          return (/* binding */_BIT11
          );
        },
        /* harmony export */BIT2: function BIT2() {
          return (/* binding */_BIT12
          );
        },
        /* harmony export */BIT20: function BIT20() {
          return (/* binding */_BIT13
          );
        },
        /* harmony export */BIT21: function BIT21() {
          return (/* binding */_BIT14
          );
        },
        /* harmony export */BIT22: function BIT22() {
          return (/* binding */_BIT15
          );
        },
        /* harmony export */BIT23: function BIT23() {
          return (/* binding */_BIT16
          );
        },
        /* harmony export */BIT24: function BIT24() {
          return (/* binding */_BIT17
          );
        },
        /* harmony export */BIT25: function BIT25() {
          return (/* binding */_BIT18
          );
        },
        /* harmony export */BIT26: function BIT26() {
          return (/* binding */_BIT19
          );
        },
        /* harmony export */BIT27: function BIT27() {
          return (/* binding */_BIT20
          );
        },
        /* harmony export */BIT28: function BIT28() {
          return (/* binding */_BIT21
          );
        },
        /* harmony export */BIT29: function BIT29() {
          return (/* binding */_BIT22
          );
        },
        /* harmony export */BIT3: function BIT3() {
          return (/* binding */_BIT23
          );
        },
        /* harmony export */BIT30: function BIT30() {
          return (/* binding */_BIT24
          );
        },
        /* harmony export */BIT31: function BIT31() {
          return (/* binding */_BIT25
          );
        },
        /* harmony export */BIT32: function BIT32() {
          return (/* binding */_BIT26
          );
        },
        /* harmony export */BIT4: function BIT4() {
          return (/* binding */_BIT27
          );
        },
        /* harmony export */BIT5: function BIT5() {
          return (/* binding */_BIT28
          );
        },
        /* harmony export */BIT6: function BIT6() {
          return (/* binding */_BIT29
          );
        },
        /* harmony export */BIT7: function BIT7() {
          return (/* binding */_BIT30
          );
        },
        /* harmony export */BIT8: function BIT8() {
          return (/* binding */_BIT31
          );
        },
        /* harmony export */BIT9: function BIT9() {
          return (/* binding */_BIT32
          );
        },
        /* harmony export */BITS0: function BITS0() {
          return (/* binding */_BITS
          );
        },
        /* harmony export */BITS1: function BITS1() {
          return (/* binding */_BITS2
          );
        },
        /* harmony export */BITS10: function BITS10() {
          return (/* binding */_BITS3
          );
        },
        /* harmony export */BITS11: function BITS11() {
          return (/* binding */_BITS4
          );
        },
        /* harmony export */BITS12: function BITS12() {
          return (/* binding */_BITS5
          );
        },
        /* harmony export */BITS13: function BITS13() {
          return (/* binding */_BITS6
          );
        },
        /* harmony export */BITS14: function BITS14() {
          return (/* binding */_BITS7
          );
        },
        /* harmony export */BITS15: function BITS15() {
          return (/* binding */_BITS8
          );
        },
        /* harmony export */BITS16: function BITS16() {
          return (/* binding */_BITS9
          );
        },
        /* harmony export */BITS17: function BITS17() {
          return (/* binding */_BITS10
          );
        },
        /* harmony export */BITS18: function BITS18() {
          return (/* binding */_BITS11
          );
        },
        /* harmony export */BITS19: function BITS19() {
          return (/* binding */_BITS12
          );
        },
        /* harmony export */BITS2: function BITS2() {
          return (/* binding */_BITS13
          );
        },
        /* harmony export */BITS20: function BITS20() {
          return (/* binding */_BITS14
          );
        },
        /* harmony export */BITS21: function BITS21() {
          return (/* binding */_BITS15
          );
        },
        /* harmony export */BITS22: function BITS22() {
          return (/* binding */_BITS16
          );
        },
        /* harmony export */BITS23: function BITS23() {
          return (/* binding */_BITS17
          );
        },
        /* harmony export */BITS24: function BITS24() {
          return (/* binding */_BITS18
          );
        },
        /* harmony export */BITS25: function BITS25() {
          return (/* binding */_BITS19
          );
        },
        /* harmony export */BITS26: function BITS26() {
          return (/* binding */_BITS20
          );
        },
        /* harmony export */BITS27: function BITS27() {
          return (/* binding */_BITS21
          );
        },
        /* harmony export */BITS28: function BITS28() {
          return (/* binding */_BITS22
          );
        },
        /* harmony export */BITS29: function BITS29() {
          return (/* binding */_BITS23
          );
        },
        /* harmony export */BITS3: function BITS3() {
          return (/* binding */_BITS24
          );
        },
        /* harmony export */BITS30: function BITS30() {
          return (/* binding */_BITS25
          );
        },
        /* harmony export */BITS31: function BITS31() {
          return (/* binding */_BITS26
          );
        },
        /* harmony export */BITS32: function BITS32() {
          return (/* binding */_BITS27
          );
        },
        /* harmony export */BITS4: function BITS4() {
          return (/* binding */_BITS28
          );
        },
        /* harmony export */BITS5: function BITS5() {
          return (/* binding */_BITS29
          );
        },
        /* harmony export */BITS6: function BITS6() {
          return (/* binding */_BITS30
          );
        },
        /* harmony export */BITS7: function BITS7() {
          return (/* binding */_BITS31
          );
        },
        /* harmony export */BITS8: function BITS8() {
          return (/* binding */_BITS32
          );
        },
        /* harmony export */BITS9: function BITS9() {
          return (/* binding */_BITS33
          );
        }
        /* harmony export */
      });
      /* eslint-env browser */

      /**
       * Binary data constants.
       *
       * @module binary
       */

      /**
       * n-th bit activated.
       *
       * @type {number}
       */
      var _BIT = 1;
      var _BIT12 = 2;
      var _BIT23 = 4;
      var _BIT27 = 8;
      var _BIT28 = 16;
      var _BIT29 = 32;
      var _BIT30 = 64;
      var _BIT31 = 128;
      var _BIT32 = 256;
      var _BIT2 = 512;
      var _BIT3 = 1024;
      var _BIT4 = 2048;
      var _BIT5 = 4096;
      var _BIT6 = 8192;
      var _BIT7 = 16384;
      var _BIT8 = 32768;
      var _BIT9 = 65536;
      var _BIT10 = 1 << 17;
      var _BIT11 = 1 << 18;
      var _BIT13 = 1 << 19;
      var _BIT14 = 1 << 20;
      var _BIT15 = 1 << 21;
      var _BIT16 = 1 << 22;
      var _BIT17 = 1 << 23;
      var _BIT18 = 1 << 24;
      var _BIT19 = 1 << 25;
      var _BIT20 = 1 << 26;
      var _BIT21 = 1 << 27;
      var _BIT22 = 1 << 28;
      var _BIT24 = 1 << 29;
      var _BIT25 = 1 << 30;
      var _BIT26 = 1 << 31;

      /**
       * First n bits activated.
       *
       * @type {number}
       */
      var _BITS = 0;
      var _BITS2 = 1;
      var _BITS13 = 3;
      var _BITS24 = 7;
      var _BITS28 = 15;
      var _BITS29 = 31;
      var _BITS30 = 63;
      var _BITS31 = 127;
      var _BITS32 = 255;
      var _BITS33 = 511;
      var _BITS3 = 1023;
      var _BITS4 = 2047;
      var _BITS5 = 4095;
      var _BITS6 = 8191;
      var _BITS7 = 16383;
      var _BITS8 = 32767;
      var _BITS9 = 65535;
      var _BITS10 = _BIT10 - 1;
      var _BITS11 = _BIT11 - 1;
      var _BITS12 = _BIT13 - 1;
      var _BITS14 = _BIT14 - 1;
      var _BITS15 = _BIT15 - 1;
      var _BITS16 = _BIT16 - 1;
      var _BITS17 = _BIT17 - 1;
      var _BITS18 = _BIT18 - 1;
      var _BITS19 = _BIT19 - 1;
      var _BITS20 = _BIT20 - 1;
      var _BITS21 = _BIT21 - 1;
      var _BITS22 = _BIT22 - 1;
      var _BITS23 = _BIT24 - 1;
      var _BITS25 = _BIT25 - 1;
      /**
       * @type {number}
       */
      var _BITS26 = 0x7FFFFFFF;
      /**
       * @type {number}
       */
      var _BITS27 = 0xFFFFFFFF;

      /***/
    },

    /***/"./node_modules/lib0/buffer.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/buffer.js ***!
      \*************************************/
    /***/
    function node_modulesLib0BufferJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */copyUint8Array: function copyUint8Array() {
          return (/* binding */_copyUint8Array
          );
        },
        /* harmony export */createUint8ArrayFromArrayBuffer: function createUint8ArrayFromArrayBuffer() {
          return (/* binding */_createUint8ArrayFromArrayBuffer
          );
        },
        /* harmony export */createUint8ArrayFromLen: function createUint8ArrayFromLen() {
          return (/* binding */_createUint8ArrayFromLen
          );
        },
        /* harmony export */createUint8ArrayViewFromArrayBuffer: function createUint8ArrayViewFromArrayBuffer() {
          return (/* binding */_createUint8ArrayViewFromArrayBuffer
          );
        },
        /* harmony export */decodeAny: function decodeAny() {
          return (/* binding */_decodeAny
          );
        },
        /* harmony export */encodeAny: function encodeAny() {
          return (/* binding */_encodeAny
          );
        },
        /* harmony export */fromBase64: function fromBase64() {
          return (/* binding */_fromBase
          );
        },
        /* harmony export */fromBase64UrlEncoded: function fromBase64UrlEncoded() {
          return (/* binding */_fromBase64UrlEncoded
          );
        },
        /* harmony export */fromHexString: function fromHexString() {
          return (/* binding */_fromHexString
          );
        },
        /* harmony export */shiftNBitsLeft: function shiftNBitsLeft() {
          return (/* binding */_shiftNBitsLeft
          );
        },
        /* harmony export */toBase64: function toBase64() {
          return (/* binding */_toBase
          );
        },
        /* harmony export */toBase64UrlEncoded: function toBase64UrlEncoded() {
          return (/* binding */_toBase64UrlEncoded
          );
        },
        /* harmony export */toHexString: function toHexString() {
          return (/* binding */_toHexString
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _string_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./string.js */"./node_modules/lib0/string.js");
      /* harmony import */
      var _environment_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./environment.js */"./node_modules/lib0/environment.js");
      /* harmony import */
      var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./array.js */"./node_modules/lib0/array.js");
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _encoding_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./encoding.js */"./node_modules/lib0/encoding.js");
      /* harmony import */
      var _decoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./decoding.js */"./node_modules/lib0/decoding.js");
      /**
       * Utility functions to work with buffers (Uint8Array).
       *
       * @module buffer
       */

      /**
       * @param {number} len
       */
      var _createUint8ArrayFromLen = function _createUint8ArrayFromLen(len) {
        return new Uint8Array(len);
      };

      /**
       * Create Uint8Array with initial content from buffer
       *
       * @param {ArrayBuffer} buffer
       * @param {number} byteOffset
       * @param {number} length
       */
      var _createUint8ArrayViewFromArrayBuffer = function _createUint8ArrayViewFromArrayBuffer(buffer, byteOffset, length) {
        return new Uint8Array(buffer, byteOffset, length);
      };

      /**
       * Create Uint8Array with initial content from buffer
       *
       * @param {ArrayBuffer} buffer
       */
      var _createUint8ArrayFromArrayBuffer = function _createUint8ArrayFromArrayBuffer(buffer) {
        return new Uint8Array(buffer);
      };

      /* c8 ignore start */
      /**
       * @param {Uint8Array} bytes
       * @return {string}
       */
      var toBase64Browser = function toBase64Browser(bytes) {
        var s = '';
        for (var i = 0; i < bytes.byteLength; i++) {
          s += _string_js__WEBPACK_IMPORTED_MODULE_0__.fromCharCode(bytes[i]);
        }
        // eslint-disable-next-line no-undef
        return btoa(s);
      };
      /* c8 ignore stop */

      /**
       * @param {Uint8Array} bytes
       * @return {string}
       */
      var toBase64Node = function toBase64Node(bytes) {
        return Buffer.from(bytes.buffer, bytes.byteOffset, bytes.byteLength).toString('base64');
      };

      /* c8 ignore start */
      /**
       * @param {string} s
       * @return {Uint8Array}
       */
      var fromBase64Browser = function fromBase64Browser(s) {
        // eslint-disable-next-line no-undef
        var a = atob(s);
        var bytes = _createUint8ArrayFromLen(a.length);
        for (var i = 0; i < a.length; i++) {
          bytes[i] = a.charCodeAt(i);
        }
        return bytes;
      };
      /* c8 ignore stop */

      /**
       * @param {string} s
       */
      var fromBase64Node = function fromBase64Node(s) {
        var buf = Buffer.from(s, 'base64');
        return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
      };

      /* c8 ignore next */
      var _toBase = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? toBase64Browser : toBase64Node;

      /* c8 ignore next */
      var _fromBase = _environment_js__WEBPACK_IMPORTED_MODULE_1__.isBrowser ? fromBase64Browser : fromBase64Node;

      /**
       * Implements base64url - see https://datatracker.ietf.org/doc/html/rfc4648#section-5
       * @param {Uint8Array} buf
       */
      var _toBase64UrlEncoded = function _toBase64UrlEncoded(buf) {
        return _toBase(buf).replaceAll('+', '-').replaceAll('/', '_').replaceAll('=', '');
      };

      /**
       * @param {string} base64
       */
      var _fromBase64UrlEncoded = function _fromBase64UrlEncoded(base64) {
        return _fromBase(base64.replaceAll('-', '+').replaceAll('_', '/'));
      };

      /**
       * Base64 is always a more efficient choice. This exists for utility purposes only.
       *
       * @param {Uint8Array} buf
       */
      var _toHexString = function _toHexString(buf) {
        return _array_js__WEBPACK_IMPORTED_MODULE_2__.map(buf, function (b) {
          return b.toString(16).padStart(2, '0');
        }).join('');
      };

      /**
       * Note: This function expects that the hex doesn't start with 0x..
       *
       * @param {string} hex
       */
      var _fromHexString = function _fromHexString(hex) {
        var hlen = hex.length;
        var buf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_3__.ceil(hlen / 2));
        for (var i = 0; i < hlen; i += 2) {
          buf[buf.length - i / 2 - 1] = Number.parseInt(hex.slice(hlen - i - 2, hlen - i), 16);
        }
        return buf;
      };

      /**
       * Copy the content of an Uint8Array view to a new ArrayBuffer.
       *
       * @param {Uint8Array} uint8Array
       * @return {Uint8Array}
       */
      var _copyUint8Array = function _copyUint8Array(uint8Array) {
        var newBuf = _createUint8ArrayFromLen(uint8Array.byteLength);
        newBuf.set(uint8Array);
        return newBuf;
      };

      /**
       * Encode anything as a UInt8Array. It's a pun on typescripts's `any` type.
       * See encoding.writeAny for more information.
       *
       * @param {any} data
       * @return {Uint8Array}
       */
      var _encodeAny = function _encodeAny(data) {
        var encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
        _encoding_js__WEBPACK_IMPORTED_MODULE_4__.writeAny(encoder, data);
        return _encoding_js__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);
      };

      /**
       * Decode an any-encoded value.
       *
       * @param {Uint8Array} buf
       * @return {any}
       */
      var _decodeAny = function _decodeAny(buf) {
        return _decoding_js__WEBPACK_IMPORTED_MODULE_5__.readAny(_decoding_js__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf));
      };

      /**
       * Shift Byte Array {N} bits to the left. Does not expand byte array.
       *
       * @param {Uint8Array} bs
       * @param {number} N should be in the range of [0-7]
       */
      var _shiftNBitsLeft = function _shiftNBitsLeft(bs, N) {
        if (N === 0) return bs;
        bs = new Uint8Array(bs);
        bs[0] <<= N;
        for (var i = 1; i < bs.length; i++) {
          bs[i - 1] |= bs[i] >>> 8 - N;
          bs[i] <<= N;
        }
        return bs;
      };

      /***/
    },

    /***/"./node_modules/lib0/conditions.js":
    /*!*****************************************!*\
      !*** ./node_modules/lib0/conditions.js ***!
      \*****************************************/
    /***/
    function node_modulesLib0ConditionsJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */undefinedToNull: function undefinedToNull() {
          return (/* binding */_undefinedToNull
          );
        }
        /* harmony export */
      });
      /**
       * Often used conditions.
       *
       * @module conditions
       */

      /**
       * @template T
       * @param {T|null|undefined} v
       * @return {T|null}
       */
      /* c8 ignore next */
      var _undefinedToNull = function _undefinedToNull(v) {
        return v === undefined ? null : v;
      };

      /***/
    },

    /***/"./node_modules/lib0/decoding.js":
    /*!***************************************!*\
      !*** ./node_modules/lib0/decoding.js ***!
      \***************************************/
    /***/
    function node_modulesLib0DecodingJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Decoder: function Decoder() {
          return (/* binding */_Decoder
          );
        },
        /* harmony export */IncUintOptRleDecoder: function IncUintOptRleDecoder() {
          return (/* binding */_IncUintOptRleDecoder
          );
        },
        /* harmony export */IntDiffDecoder: function IntDiffDecoder() {
          return (/* binding */_IntDiffDecoder
          );
        },
        /* harmony export */IntDiffOptRleDecoder: function IntDiffOptRleDecoder() {
          return (/* binding */_IntDiffOptRleDecoder
          );
        },
        /* harmony export */RleDecoder: function RleDecoder() {
          return (/* binding */_RleDecoder
          );
        },
        /* harmony export */RleIntDiffDecoder: function RleIntDiffDecoder() {
          return (/* binding */_RleIntDiffDecoder
          );
        },
        /* harmony export */StringDecoder: function StringDecoder() {
          return (/* binding */_StringDecoder
          );
        },
        /* harmony export */UintOptRleDecoder: function UintOptRleDecoder() {
          return (/* binding */_UintOptRleDecoder
          );
        },
        /* harmony export */_readVarStringNative: function _readVarStringNative() {
          return (/* binding */_readVarStringNative2
          );
        },
        /* harmony export */_readVarStringPolyfill: function _readVarStringPolyfill() {
          return (/* binding */_readVarStringPolyfill2
          );
        },
        /* harmony export */clone: function clone() {
          return (/* binding */_clone
          );
        },
        /* harmony export */createDecoder: function createDecoder() {
          return (/* binding */_createDecoder
          );
        },
        /* harmony export */hasContent: function hasContent() {
          return (/* binding */_hasContent
          );
        },
        /* harmony export */peekUint16: function peekUint16() {
          return (/* binding */_peekUint
          );
        },
        /* harmony export */peekUint32: function peekUint32() {
          return (/* binding */_peekUint2
          );
        },
        /* harmony export */peekUint8: function peekUint8() {
          return (/* binding */_peekUint3
          );
        },
        /* harmony export */peekVarInt: function peekVarInt() {
          return (/* binding */_peekVarInt
          );
        },
        /* harmony export */peekVarString: function peekVarString() {
          return (/* binding */_peekVarString
          );
        },
        /* harmony export */peekVarUint: function peekVarUint() {
          return (/* binding */_peekVarUint
          );
        },
        /* harmony export */readAny: function readAny() {
          return (/* binding */_readAny
          );
        },
        /* harmony export */readBigInt64: function readBigInt64() {
          return (/* binding */_readBigInt
          );
        },
        /* harmony export */readBigUint64: function readBigUint64() {
          return (/* binding */_readBigUint
          );
        },
        /* harmony export */readFloat32: function readFloat32() {
          return (/* binding */_readFloat
          );
        },
        /* harmony export */readFloat64: function readFloat64() {
          return (/* binding */_readFloat2
          );
        },
        /* harmony export */readFromDataView: function readFromDataView() {
          return (/* binding */_readFromDataView
          );
        },
        /* harmony export */readTailAsUint8Array: function readTailAsUint8Array() {
          return (/* binding */_readTailAsUint8Array
          );
        },
        /* harmony export */readTerminatedString: function readTerminatedString() {
          return (/* binding */_readTerminatedString
          );
        },
        /* harmony export */readTerminatedUint8Array: function readTerminatedUint8Array() {
          return (/* binding */_readTerminatedUint8Array
          );
        },
        /* harmony export */readUint16: function readUint16() {
          return (/* binding */_readUint
          );
        },
        /* harmony export */readUint32: function readUint32() {
          return (/* binding */_readUint2
          );
        },
        /* harmony export */readUint32BigEndian: function readUint32BigEndian() {
          return (/* binding */_readUint32BigEndian
          );
        },
        /* harmony export */readUint8: function readUint8() {
          return (/* binding */_readUint3
          );
        },
        /* harmony export */readUint8Array: function readUint8Array() {
          return (/* binding */_readUint8Array
          );
        },
        /* harmony export */readVarInt: function readVarInt() {
          return (/* binding */_readVarInt
          );
        },
        /* harmony export */readVarString: function readVarString() {
          return (/* binding */_readVarString
          );
        },
        /* harmony export */readVarUint: function readVarUint() {
          return (/* binding */_readVarUint
          );
        },
        /* harmony export */readVarUint8Array: function readVarUint8Array() {
          return (/* binding */_readVarUint8Array
          );
        },
        /* harmony export */skip8: function skip8() {
          return (/* binding */_skip
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _buffer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./buffer.js */"./node_modules/lib0/buffer.js");
      /* harmony import */
      var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./binary.js */"./node_modules/lib0/binary.js");
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _number_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./number.js */"./node_modules/lib0/number.js");
      /* harmony import */
      var _string_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./string.js */"./node_modules/lib0/string.js");
      /* harmony import */
      var _error_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./error.js */"./node_modules/lib0/error.js");
      /* harmony import */
      var _encoding_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./encoding.js */"./node_modules/lib0/encoding.js");
      /**
       * Efficient schema-less binary decoding with support for variable length encoding.
       *
       * Use [lib0/decoding] with [lib0/encoding]. Every encoding function has a corresponding decoding function.
       *
       * Encodes numbers in little-endian order (least to most significant byte order)
       * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
       * which is also used in Protocol Buffers.
       *
       * ```js
       * // encoding step
       * const encoder = encoding.createEncoder()
       * encoding.writeVarUint(encoder, 256)
       * encoding.writeVarString(encoder, 'Hello world!')
       * const buf = encoding.toUint8Array(encoder)
       * ```
       *
       * ```js
       * // decoding step
       * const decoder = decoding.createDecoder(buf)
       * decoding.readVarUint(decoder) // => 256
       * decoding.readVarString(decoder) // => 'Hello world!'
       * decoding.hasContent(decoder) // => false - all data is read
       * ```
       *
       * @module decoding
       */

      var errorUnexpectedEndOfArray = _error_js__WEBPACK_IMPORTED_MODULE_0__.create('Unexpected end of array');
      var errorIntegerOutOfRange = _error_js__WEBPACK_IMPORTED_MODULE_0__.create('Integer out of Range');

      /**
       * A Decoder handles the decoding of an Uint8Array.
       */
      var _Decoder = /*#__PURE__*/_createClass(
      /**
       * @param {Uint8Array} uint8Array Binary data to decode
       */
      function _Decoder(uint8Array) {
        _classCallCheck(this, _Decoder);
        /**
         * Decoding target.
         *
         * @type {Uint8Array}
         */
        this.arr = uint8Array;
        /**
         * Current decoding position.
         *
         * @type {number}
         */
        this.pos = 0;
      });
      /**
       * @function
       * @param {Uint8Array} uint8Array
       * @return {Decoder}
       */
      var _createDecoder = function _createDecoder(uint8Array) {
        return new _Decoder(uint8Array);
      };

      /**
       * @function
       * @param {Decoder} decoder
       * @return {boolean}
       */
      var _hasContent = function _hasContent(decoder) {
        return decoder.pos !== decoder.arr.length;
      };

      /**
       * Clone a decoder instance.
       * Optionally set a new position parameter.
       *
       * @function
       * @param {Decoder} decoder The decoder instance
       * @param {number} [newPos] Defaults to current position
       * @return {Decoder} A clone of `decoder`
       */
      var _clone = function _clone(decoder) {
        var newPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : decoder.pos;
        var _decoder = _createDecoder(decoder.arr);
        _decoder.pos = newPos;
        return _decoder;
      };

      /**
       * Create an Uint8Array view of the next `len` bytes and advance the position by `len`.
       *
       * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.
       *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.
       *
       * @function
       * @param {Decoder} decoder The decoder instance
       * @param {number} len The length of bytes to read
       * @return {Uint8Array}
       */
      var _readUint8Array = function _readUint8Array(decoder, len) {
        var view = _buffer_js__WEBPACK_IMPORTED_MODULE_1__.createUint8ArrayViewFromArrayBuffer(decoder.arr.buffer, decoder.pos + decoder.arr.byteOffset, len);
        decoder.pos += len;
        return view;
      };

      /**
       * Read variable length Uint8Array.
       *
       * Important: The Uint8Array still points to the underlying ArrayBuffer. Make sure to discard the result as soon as possible to prevent any memory leaks.
       *            Use `buffer.copyUint8Array` to copy the result into a new Uint8Array.
       *
       * @function
       * @param {Decoder} decoder
       * @return {Uint8Array}
       */
      var _readVarUint8Array = function _readVarUint8Array(decoder) {
        return _readUint8Array(decoder, _readVarUint(decoder));
      };

      /**
       * Read the rest of the content as an ArrayBuffer
       * @function
       * @param {Decoder} decoder
       * @return {Uint8Array}
       */
      var _readTailAsUint8Array = function _readTailAsUint8Array(decoder) {
        return _readUint8Array(decoder, decoder.arr.length - decoder.pos);
      };

      /**
       * Skip one byte, jump to the next position.
       * @function
       * @param {Decoder} decoder The decoder instance
       * @return {number} The next position
       */
      var _skip = function _skip(decoder) {
        return decoder.pos++;
      };

      /**
       * Read one byte as unsigned integer.
       * @function
       * @param {Decoder} decoder The decoder instance
       * @return {number} Unsigned 8-bit integer
       */
      var _readUint3 = function _readUint3(decoder) {
        return decoder.arr[decoder.pos++];
      };

      /**
       * Read 2 bytes as unsigned integer.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _readUint = function _readUint(decoder) {
        var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
        decoder.pos += 2;
        return uint;
      };

      /**
       * Read 4 bytes as unsigned integer.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _readUint2 = function _readUint2(decoder) {
        var uint = decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
        decoder.pos += 4;
        return uint;
      };

      /**
       * Read 4 bytes as unsigned integer in big endian order.
       * (most significant byte first)
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _readUint32BigEndian = function _readUint32BigEndian(decoder) {
        var uint = decoder.arr[decoder.pos + 3] + (decoder.arr[decoder.pos + 2] << 8) + (decoder.arr[decoder.pos + 1] << 16) + (decoder.arr[decoder.pos] << 24) >>> 0;
        decoder.pos += 4;
        return uint;
      };

      /**
       * Look ahead without incrementing the position
       * to the next byte and read it as unsigned integer.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _peekUint3 = function _peekUint3(decoder) {
        return decoder.arr[decoder.pos];
      };

      /**
       * Look ahead without incrementing the position
       * to the next byte and read it as unsigned integer.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _peekUint = function _peekUint(decoder) {
        return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8);
      };

      /**
       * Look ahead without incrementing the position
       * to the next byte and read it as unsigned integer.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.
       */
      var _peekUint2 = function _peekUint2(decoder) {
        return decoder.arr[decoder.pos] + (decoder.arr[decoder.pos + 1] << 8) + (decoder.arr[decoder.pos + 2] << 16) + (decoder.arr[decoder.pos + 3] << 24) >>> 0;
      };

      /**
       * Read unsigned integer (32bit) with variable length.
       * 1/8th of the storage is used as encoding overhead.
       *  * numbers < 2^7 is stored in one bytlength
       *  * numbers < 2^14 is stored in two bylength
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.length
       */
      var _readVarUint = function _readVarUint(decoder) {
        var num = 0;
        var mult = 1;
        var len = decoder.arr.length;
        while (decoder.pos < len) {
          var r = decoder.arr[decoder.pos++];
          // num = num | ((r & binary.BITS7) << len)
          num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) * mult; // shift $r << (7*#iterations) and add it to num
          mult *= 128; // next iteration, shift 7 "more" to the left
          if (r < _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) {
            return num;
          }
          /* c8 ignore start */
          if (num > _number_js__WEBPACK_IMPORTED_MODULE_3__.MAX_SAFE_INTEGER) {
            throw errorIntegerOutOfRange;
          }
          /* c8 ignore stop */
        }

        throw errorUnexpectedEndOfArray;
      };

      /**
       * Read signed integer (32bit) with variable length.
       * 1/8th of the storage is used as encoding overhead.
       *  * numbers < 2^7 is stored in one bytlength
       *  * numbers < 2^14 is stored in two bylength
       * @todo This should probably create the inverse ~num if number is negative - but this would be a breaking change.
       *
       * @function
       * @param {Decoder} decoder
       * @return {number} An unsigned integer.length
       */
      var _readVarInt = function _readVarInt(decoder) {
        var r = decoder.arr[decoder.pos++];
        var num = r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6;
        var mult = 64;
        var sign = (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7) > 0 ? -1 : 1;
        if ((r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) === 0) {
          // don't continue reading
          return sign * num;
        }
        var len = decoder.arr.length;
        while (decoder.pos < len) {
          r = decoder.arr[decoder.pos++];
          // num = num | ((r & binary.BITS7) << len)
          num = num + (r & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) * mult;
          mult *= 128;
          if (r < _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8) {
            return sign * num;
          }
          /* c8 ignore start */
          if (num > _number_js__WEBPACK_IMPORTED_MODULE_3__.MAX_SAFE_INTEGER) {
            throw errorIntegerOutOfRange;
          }
          /* c8 ignore stop */
        }

        throw errorUnexpectedEndOfArray;
      };

      /**
       * Look ahead and read varUint without incrementing position
       *
       * @function
       * @param {Decoder} decoder
       * @return {number}
       */
      var _peekVarUint = function _peekVarUint(decoder) {
        var pos = decoder.pos;
        var s = _readVarUint(decoder);
        decoder.pos = pos;
        return s;
      };

      /**
       * Look ahead and read varUint without incrementing position
       *
       * @function
       * @param {Decoder} decoder
       * @return {number}
       */
      var _peekVarInt = function _peekVarInt(decoder) {
        var pos = decoder.pos;
        var s = _readVarInt(decoder);
        decoder.pos = pos;
        return s;
      };

      /**
       * We don't test this function anymore as we use native decoding/encoding by default now.
       * Better not modify this anymore..
       *
       * Transforming utf8 to a string is pretty expensive. The code performs 10x better
       * when String.fromCodePoint is fed with all characters as arguments.
       * But most environments have a maximum number of arguments per functions.
       * For effiency reasons we apply a maximum of 10000 characters at once.
       *
       * @function
       * @param {Decoder} decoder
       * @return {String} The read String.
       */
      /* c8 ignore start */
      var _readVarStringPolyfill2 = function _readVarStringPolyfill2(decoder) {
        var remainingLen = _readVarUint(decoder);
        if (remainingLen === 0) {
          return '';
        } else {
          var encodedString = String.fromCodePoint(_readUint3(decoder)); // remember to decrease remainingLen
          if (--remainingLen < 100) {
            // do not create a Uint8Array for small strings
            while (remainingLen--) {
              encodedString += String.fromCodePoint(_readUint3(decoder));
            }
          } else {
            while (remainingLen > 0) {
              var nextLen = remainingLen < 10000 ? remainingLen : 10000;
              // this is dangerous, we create a fresh array view from the existing buffer
              var bytes = decoder.arr.subarray(decoder.pos, decoder.pos + nextLen);
              decoder.pos += nextLen;
              // Starting with ES5.1 we can supply a generic array-like object as arguments
              encodedString += String.fromCodePoint.apply(null, /** @type {any} */bytes);
              remainingLen -= nextLen;
            }
          }
          return decodeURIComponent(escape(encodedString));
        }
      };
      /* c8 ignore stop */

      /**
       * @function
       * @param {Decoder} decoder
       * @return {String} The read String
       */
      var _readVarStringNative2 = function _readVarStringNative2(decoder) {
        return (/** @type any */_string_js__WEBPACK_IMPORTED_MODULE_4__.utf8TextDecoder.decode(_readVarUint8Array(decoder))
        );
      };

      /**
       * Read string of variable length
       * * varUint is used to store the length of the string
       *
       * @function
       * @param {Decoder} decoder
       * @return {String} The read String
       *
       */
      /* c8 ignore next */
      var _readVarString = _string_js__WEBPACK_IMPORTED_MODULE_4__.utf8TextDecoder ? _readVarStringNative2 : _readVarStringPolyfill2;

      /**
       * @param {Decoder} decoder
       * @return {Uint8Array}
       */
      var _readTerminatedUint8Array = function _readTerminatedUint8Array(decoder) {
        var encoder = _encoding_js__WEBPACK_IMPORTED_MODULE_5__.createEncoder();
        var b;
        while (true) {
          b = _readUint3(decoder);
          if (b === 0) {
            return _encoding_js__WEBPACK_IMPORTED_MODULE_5__.toUint8Array(encoder);
          }
          if (b === 1) {
            b = _readUint3(decoder);
          }
          _encoding_js__WEBPACK_IMPORTED_MODULE_5__.write(encoder, b);
        }
      };

      /**
       * @param {Decoder} decoder
       * @return {string}
       */
      var _readTerminatedString = function _readTerminatedString(decoder) {
        return _string_js__WEBPACK_IMPORTED_MODULE_4__.decodeUtf8(_readTerminatedUint8Array(decoder));
      };

      /**
       * Look ahead and read varString without incrementing position
       *
       * @function
       * @param {Decoder} decoder
       * @return {string}
       */
      var _peekVarString = function _peekVarString(decoder) {
        var pos = decoder.pos;
        var s = _readVarString(decoder);
        decoder.pos = pos;
        return s;
      };

      /**
       * @param {Decoder} decoder
       * @param {number} len
       * @return {DataView}
       */
      var _readFromDataView = function _readFromDataView(decoder, len) {
        var dv = new DataView(decoder.arr.buffer, decoder.arr.byteOffset + decoder.pos, len);
        decoder.pos += len;
        return dv;
      };

      /**
       * @param {Decoder} decoder
       */
      var _readFloat = function _readFloat(decoder) {
        return _readFromDataView(decoder, 4).getFloat32(0, false);
      };

      /**
       * @param {Decoder} decoder
       */
      var _readFloat2 = function _readFloat2(decoder) {
        return _readFromDataView(decoder, 8).getFloat64(0, false);
      };

      /**
       * @param {Decoder} decoder
       */
      var _readBigInt = function _readBigInt(decoder) {
        return (/** @type {any} */_readFromDataView(decoder, 8).getBigInt64(0, false)
        );
      };

      /**
       * @param {Decoder} decoder
       */
      var _readBigUint = function _readBigUint(decoder) {
        return (/** @type {any} */_readFromDataView(decoder, 8).getBigUint64(0, false)
        );
      };

      /**
       * @type {Array<function(Decoder):any>}
       */
      var readAnyLookupTable = [function (decoder) {
        return undefined;
      },
      // CASE 127: undefined
      function (decoder) {
        return null;
      },
      // CASE 126: null
      _readVarInt,
      // CASE 125: integer
      _readFloat,
      // CASE 124: float32
      _readFloat2,
      // CASE 123: float64
      _readBigInt,
      // CASE 122: bigint
      function (decoder) {
        return false;
      },
      // CASE 121: boolean (false)
      function (decoder) {
        return true;
      },
      // CASE 120: boolean (true)
      _readVarString,
      // CASE 119: string
      function (decoder) {
        // CASE 118: object<string,any>
        var len = _readVarUint(decoder);
        /**
         * @type {Object<string,any>}
         */
        var obj = {};
        for (var i = 0; i < len; i++) {
          var key = _readVarString(decoder);
          obj[key] = _readAny(decoder);
        }
        return obj;
      }, function (decoder) {
        // CASE 117: array<any>
        var len = _readVarUint(decoder);
        var arr = [];
        for (var i = 0; i < len; i++) {
          arr.push(_readAny(decoder));
        }
        return arr;
      }, _readVarUint8Array // CASE 116: Uint8Array
      ];

      /**
       * @param {Decoder} decoder
       */
      var _readAny = function _readAny(decoder) {
        return readAnyLookupTable[127 - _readUint3(decoder)](decoder);
      };

      /**
       * T must not be null.
       *
       * @template T
       */
      var _RleDecoder = /*#__PURE__*/function (_Decoder2) {
        _inherits(_RleDecoder, _Decoder2);
        var _super = _createSuper(_RleDecoder);
        /**
         * @param {Uint8Array} uint8Array
         * @param {function(Decoder):T} reader
         */
        function _RleDecoder(uint8Array, reader) {
          var _this;
          _classCallCheck(this, _RleDecoder);
          _this = _super.call(this, uint8Array);
          /**
           * The reader
           */
          _this.reader = reader;
          /**
           * Current state
           * @type {T|null}
           */
          _this.s = null;
          _this.count = 0;
          return _this;
        }
        _createClass(_RleDecoder, [{
          key: "read",
          value: function read() {
            if (this.count === 0) {
              this.s = this.reader(this);
              if (_hasContent(this)) {
                this.count = _readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented
              } else {
                this.count = -1; // read the current value forever
              }
            }

            this.count--;
            return (/** @type {T} */this.s
            );
          }
        }]);
        return _RleDecoder;
      }(_Decoder);
      var _IntDiffDecoder = /*#__PURE__*/function (_Decoder3) {
        _inherits(_IntDiffDecoder, _Decoder3);
        var _super2 = _createSuper(_IntDiffDecoder);
        /**
         * @param {Uint8Array} uint8Array
         * @param {number} start
         */
        function _IntDiffDecoder(uint8Array, start) {
          var _this2;
          _classCallCheck(this, _IntDiffDecoder);
          _this2 = _super2.call(this, uint8Array);
          /**
           * Current state
           * @type {number}
           */
          _this2.s = start;
          return _this2;
        }

        /**
         * @return {number}
         */
        _createClass(_IntDiffDecoder, [{
          key: "read",
          value: function read() {
            this.s += _readVarInt(this);
            return this.s;
          }
        }]);
        return _IntDiffDecoder;
      }(_Decoder);
      var _RleIntDiffDecoder = /*#__PURE__*/function (_Decoder4) {
        _inherits(_RleIntDiffDecoder, _Decoder4);
        var _super3 = _createSuper(_RleIntDiffDecoder);
        /**
         * @param {Uint8Array} uint8Array
         * @param {number} start
         */
        function _RleIntDiffDecoder(uint8Array, start) {
          var _this3;
          _classCallCheck(this, _RleIntDiffDecoder);
          _this3 = _super3.call(this, uint8Array);
          /**
           * Current state
           * @type {number}
           */
          _this3.s = start;
          _this3.count = 0;
          return _this3;
        }

        /**
         * @return {number}
         */
        _createClass(_RleIntDiffDecoder, [{
          key: "read",
          value: function read() {
            if (this.count === 0) {
              this.s += _readVarInt(this);
              if (_hasContent(this)) {
                this.count = _readVarUint(this) + 1; // see encoder implementation for the reason why this is incremented
              } else {
                this.count = -1; // read the current value forever
              }
            }

            this.count--;
            return (/** @type {number} */this.s
            );
          }
        }]);
        return _RleIntDiffDecoder;
      }(_Decoder);
      var _UintOptRleDecoder = /*#__PURE__*/function (_Decoder5) {
        _inherits(_UintOptRleDecoder, _Decoder5);
        var _super4 = _createSuper(_UintOptRleDecoder);
        /**
         * @param {Uint8Array} uint8Array
         */
        function _UintOptRleDecoder(uint8Array) {
          var _this4;
          _classCallCheck(this, _UintOptRleDecoder);
          _this4 = _super4.call(this, uint8Array);
          /**
           * @type {number}
           */
          _this4.s = 0;
          _this4.count = 0;
          return _this4;
        }
        _createClass(_UintOptRleDecoder, [{
          key: "read",
          value: function read() {
            if (this.count === 0) {
              this.s = _readVarInt(this);
              // if the sign is negative, we read the count too, otherwise count is 1
              var isNegative = _math_js__WEBPACK_IMPORTED_MODULE_6__.isNegativeZero(this.s);
              this.count = 1;
              if (isNegative) {
                this.s = -this.s;
                this.count = _readVarUint(this) + 2;
              }
            }
            this.count--;
            return (/** @type {number} */this.s
            );
          }
        }]);
        return _UintOptRleDecoder;
      }(_Decoder);
      var _IncUintOptRleDecoder = /*#__PURE__*/function (_Decoder6) {
        _inherits(_IncUintOptRleDecoder, _Decoder6);
        var _super5 = _createSuper(_IncUintOptRleDecoder);
        /**
         * @param {Uint8Array} uint8Array
         */
        function _IncUintOptRleDecoder(uint8Array) {
          var _this5;
          _classCallCheck(this, _IncUintOptRleDecoder);
          _this5 = _super5.call(this, uint8Array);
          /**
           * @type {number}
           */
          _this5.s = 0;
          _this5.count = 0;
          return _this5;
        }
        _createClass(_IncUintOptRleDecoder, [{
          key: "read",
          value: function read() {
            if (this.count === 0) {
              this.s = _readVarInt(this);
              // if the sign is negative, we read the count too, otherwise count is 1
              var isNegative = _math_js__WEBPACK_IMPORTED_MODULE_6__.isNegativeZero(this.s);
              this.count = 1;
              if (isNegative) {
                this.s = -this.s;
                this.count = _readVarUint(this) + 2;
              }
            }
            this.count--;
            return (/** @type {number} */this.s++
            );
          }
        }]);
        return _IncUintOptRleDecoder;
      }(_Decoder);
      var _IntDiffOptRleDecoder = /*#__PURE__*/function (_Decoder7) {
        _inherits(_IntDiffOptRleDecoder, _Decoder7);
        var _super6 = _createSuper(_IntDiffOptRleDecoder);
        /**
         * @param {Uint8Array} uint8Array
         */
        function _IntDiffOptRleDecoder(uint8Array) {
          var _this6;
          _classCallCheck(this, _IntDiffOptRleDecoder);
          _this6 = _super6.call(this, uint8Array);
          /**
           * @type {number}
           */
          _this6.s = 0;
          _this6.count = 0;
          _this6.diff = 0;
          return _this6;
        }

        /**
         * @return {number}
         */
        _createClass(_IntDiffOptRleDecoder, [{
          key: "read",
          value: function read() {
            if (this.count === 0) {
              var diff = _readVarInt(this);
              // if the first bit is set, we read more data
              var hasCount = diff & 1;
              this.diff = _math_js__WEBPACK_IMPORTED_MODULE_6__.floor(diff / 2); // shift >> 1
              this.count = 1;
              if (hasCount) {
                this.count = _readVarUint(this) + 2;
              }
            }
            this.s += this.diff;
            this.count--;
            return this.s;
          }
        }]);
        return _IntDiffOptRleDecoder;
      }(_Decoder);
      var _StringDecoder = /*#__PURE__*/function () {
        /**
         * @param {Uint8Array} uint8Array
         */
        function _StringDecoder(uint8Array) {
          _classCallCheck(this, _StringDecoder);
          this.decoder = new _UintOptRleDecoder(uint8Array);
          this.str = _readVarString(this.decoder);
          /**
           * @type {number}
           */
          this.spos = 0;
        }

        /**
         * @return {string}
         */
        _createClass(_StringDecoder, [{
          key: "read",
          value: function read() {
            var end = this.spos + this.decoder.read();
            var res = this.str.slice(this.spos, end);
            this.spos = end;
            return res;
          }
        }]);
        return _StringDecoder;
      }();
      /***/
    },
    /***/"./node_modules/lib0/dom.js":
    /*!**********************************!*\
      !*** ./node_modules/lib0/dom.js ***!
      \**********************************/
    /***/
    function node_modulesLib0DomJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */CDATA_SECTION_NODE: function CDATA_SECTION_NODE() {
          return (/* binding */_CDATA_SECTION_NODE
          );
        },
        /* harmony export */COMMENT_NODE: function COMMENT_NODE() {
          return (/* binding */_COMMENT_NODE
          );
        },
        /* harmony export */DOCUMENT_FRAGMENT_NODE: function DOCUMENT_FRAGMENT_NODE() {
          return (/* binding */_DOCUMENT_FRAGMENT_NODE
          );
        },
        /* harmony export */DOCUMENT_NODE: function DOCUMENT_NODE() {
          return (/* binding */_DOCUMENT_NODE
          );
        },
        /* harmony export */DOCUMENT_TYPE_NODE: function DOCUMENT_TYPE_NODE() {
          return (/* binding */_DOCUMENT_TYPE_NODE
          );
        },
        /* harmony export */ELEMENT_NODE: function ELEMENT_NODE() {
          return (/* binding */_ELEMENT_NODE
          );
        },
        /* harmony export */TEXT_NODE: function TEXT_NODE() {
          return (/* binding */_TEXT_NODE
          );
        },
        /* harmony export */addEventListener: function (_addEventListener) {
          function addEventListener() {
            return _addEventListener.apply(this, arguments);
          }
          addEventListener.toString = function () {
            return _addEventListener.toString();
          };
          return addEventListener;
        }(function () {
          return (/* binding */addEventListener
          );
        }),
        /* harmony export */addEventListeners: function addEventListeners() {
          return (/* binding */_addEventListeners
          );
        },
        /* harmony export */append: function append() {
          return (/* binding */_append
          );
        },
        /* harmony export */appendChild: function appendChild() {
          return (/* binding */_appendChild
          );
        },
        /* harmony export */canvas: function canvas() {
          return (/* binding */_canvas
          );
        },
        /* harmony export */checkNodeType: function checkNodeType() {
          return (/* binding */_checkNodeType
          );
        },
        /* harmony export */createDocumentFragment: function createDocumentFragment() {
          return (/* binding */_createDocumentFragment
          );
        },
        /* harmony export */createElement: function createElement() {
          return (/* binding */_createElement
          );
        },
        /* harmony export */createTextNode: function createTextNode() {
          return (/* binding */_createTextNode
          );
        },
        /* harmony export */doc: function doc() {
          return (/* binding */_doc
          );
        },
        /* harmony export */domParser: function domParser() {
          return (/* binding */_domParser
          );
        },
        /* harmony export */element: function element() {
          return (/* binding */_element
          );
        },
        /* harmony export */emitCustomEvent: function emitCustomEvent() {
          return (/* binding */_emitCustomEvent
          );
        },
        /* harmony export */fragment: function fragment() {
          return (/* binding */_fragment
          );
        },
        /* harmony export */getElementById: function getElementById() {
          return (/* binding */_getElementById
          );
        },
        /* harmony export */insertBefore: function insertBefore() {
          return (/* binding */_insertBefore
          );
        },
        /* harmony export */isParentOf: function isParentOf() {
          return (/* binding */_isParentOf
          );
        },
        /* harmony export */mapToStyleString: function mapToStyleString() {
          return (/* binding */_mapToStyleString
          );
        },
        /* harmony export */pairToStyleString: function pairToStyleString() {
          return (/* binding */_pairToStyleString
          );
        },
        /* harmony export */pairsToStyleString: function pairsToStyleString() {
          return (/* binding */_pairsToStyleString
          );
        },
        /* harmony export */parseElement: function parseElement() {
          return (/* binding */_parseElement
          );
        },
        /* harmony export */parseFragment: function parseFragment() {
          return (/* binding */_parseFragment
          );
        },
        /* harmony export */querySelector: function querySelector() {
          return (/* binding */_querySelector
          );
        },
        /* harmony export */querySelectorAll: function querySelectorAll() {
          return (/* binding */_querySelectorAll
          );
        },
        /* harmony export */remove: function remove() {
          return (/* binding */_remove
          );
        },
        /* harmony export */removeEventListener: function (_removeEventListener) {
          function removeEventListener() {
            return _removeEventListener.apply(this, arguments);
          }
          removeEventListener.toString = function () {
            return _removeEventListener.toString();
          };
          return removeEventListener;
        }(function () {
          return (/* binding */removeEventListener
          );
        }),
        /* harmony export */removeEventListeners: function removeEventListeners() {
          return (/* binding */_removeEventListeners
          );
        },
        /* harmony export */replaceWith: function replaceWith() {
          return (/* binding */_replaceWith
          );
        },
        /* harmony export */setAttributes: function setAttributes() {
          return (/* binding */_setAttributes
          );
        },
        /* harmony export */setAttributesMap: function setAttributesMap() {
          return (/* binding */_setAttributesMap
          );
        },
        /* harmony export */text: function text() {
          return (/* binding */_text
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _pair_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./pair.js */"./node_modules/lib0/pair.js");
      /* harmony import */
      var _map_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./map.js */"./node_modules/lib0/map.js");
      /* eslint-env browser */

      /**
       * Utility module to work with the DOM.
       *
       * @module dom
       */

      /* c8 ignore start */
      /**
       * @type {Document}
       */
      var _doc = /** @type {Document} */typeof document !== 'undefined' ? document : {};

      /**
       * @param {string} name
       * @return {HTMLElement}
       */
      var _createElement = function _createElement(name) {
        return _doc.createElement(name);
      };

      /**
       * @return {DocumentFragment}
       */
      var _createDocumentFragment = function _createDocumentFragment() {
        return _doc.createDocumentFragment();
      };

      /**
       * @param {string} text
       * @return {Text}
       */
      var _createTextNode = function _createTextNode(text) {
        return _doc.createTextNode(text);
      };
      var _domParser = /** @type {DOMParser} */typeof DOMParser !== 'undefined' ? new DOMParser() : null;

      /**
       * @param {HTMLElement} el
       * @param {string} name
       * @param {Object} opts
       */
      var _emitCustomEvent = function _emitCustomEvent(el, name, opts) {
        return el.dispatchEvent(new CustomEvent(name, opts));
      };

      /**
       * @param {Element} el
       * @param {Array<pair.Pair<string,string|boolean>>} attrs Array of key-value pairs
       * @return {Element}
       */
      var _setAttributes = function _setAttributes(el, attrs) {
        _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(attrs, function (key, value) {
          if (value === false) {
            el.removeAttribute(key);
          } else if (value === true) {
            el.setAttribute(key, '');
          } else {
            // @ts-ignore
            el.setAttribute(key, value);
          }
        });
        return el;
      };

      /**
       * @param {Element} el
       * @param {Map<string, string>} attrs Array of key-value pairs
       * @return {Element}
       */
      var _setAttributesMap = function _setAttributesMap(el, attrs) {
        attrs.forEach(function (value, key) {
          el.setAttribute(key, value);
        });
        return el;
      };

      /**
       * @param {Array<Node>|HTMLCollection} children
       * @return {DocumentFragment}
       */
      var _fragment = function _fragment(children) {
        var fragment = _createDocumentFragment();
        for (var i = 0; i < children.length; i++) {
          _appendChild(fragment, children[i]);
        }
        return fragment;
      };

      /**
       * @param {Element} parent
       * @param {Array<Node>} nodes
       * @return {Element}
       */
      var _append = function _append(parent, nodes) {
        _appendChild(parent, _fragment(nodes));
        return parent;
      };

      /**
       * @param {HTMLElement} el
       */
      var _remove = function _remove(el) {
        return el.remove();
      };

      /**
       * @param {EventTarget} el
       * @param {string} name
       * @param {EventListener} f
       */
      var addEventListener = function addEventListener(el, name, f) {
        return el.addEventListener(name, f);
      };

      /**
       * @param {EventTarget} el
       * @param {string} name
       * @param {EventListener} f
       */
      var removeEventListener = function removeEventListener(el, name, f) {
        return el.removeEventListener(name, f);
      };

      /**
       * @param {Node} node
       * @param {Array<pair.Pair<string,EventListener>>} listeners
       * @return {Node}
       */
      var _addEventListeners = function _addEventListeners(node, listeners) {
        _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, function (name, f) {
          return addEventListener(node, name, f);
        });
        return node;
      };

      /**
       * @param {Node} node
       * @param {Array<pair.Pair<string,EventListener>>} listeners
       * @return {Node}
       */
      var _removeEventListeners = function _removeEventListeners(node, listeners) {
        _pair_js__WEBPACK_IMPORTED_MODULE_0__.forEach(listeners, function (name, f) {
          return removeEventListener(node, name, f);
        });
        return node;
      };

      /**
       * @param {string} name
       * @param {Array<pair.Pair<string,string>|pair.Pair<string,boolean>>} attrs Array of key-value pairs
       * @param {Array<Node>} children
       * @return {Element}
       */
      var _element = function _element(name) {
        var attrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        var children = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
        return _append(_setAttributes(_createElement(name), attrs), children);
      };

      /**
       * @param {number} width
       * @param {number} height
       */
      var _canvas = function _canvas(width, height) {
        var c = /** @type {HTMLCanvasElement} */_createElement('canvas');
        c.height = height;
        c.width = width;
        return c;
      };

      /**
       * @param {string} t
       * @return {Text}
       */
      var _text = _createTextNode;

      /**
       * @param {pair.Pair<string,string>} pair
       */
      var _pairToStyleString = function _pairToStyleString(pair) {
        return "".concat(pair.left, ":").concat(pair.right, ";");
      };

      /**
       * @param {Array<pair.Pair<string,string>>} pairs
       * @return {string}
       */
      var _pairsToStyleString = function _pairsToStyleString(pairs) {
        return pairs.map(_pairToStyleString).join('');
      };

      /**
       * @param {Map<string,string>} m
       * @return {string}
       */
      var _mapToStyleString = function _mapToStyleString(m) {
        return _map_js__WEBPACK_IMPORTED_MODULE_1__.map(m, function (value, key) {
          return "".concat(key, ":").concat(value, ";");
        }).join('');
      };

      /**
       * @todo should always query on a dom element
       *
       * @param {HTMLElement|ShadowRoot} el
       * @param {string} query
       * @return {HTMLElement | null}
       */
      var _querySelector = function _querySelector(el, query) {
        return el.querySelector(query);
      };

      /**
       * @param {HTMLElement|ShadowRoot} el
       * @param {string} query
       * @return {NodeListOf<HTMLElement>}
       */
      var _querySelectorAll = function _querySelectorAll(el, query) {
        return el.querySelectorAll(query);
      };

      /**
       * @param {string} id
       * @return {HTMLElement}
       */
      var _getElementById = function _getElementById(id) {
        return (/** @type {HTMLElement} */_doc.getElementById(id)
        );
      };

      /**
       * @param {string} html
       * @return {HTMLElement}
       */
      var _parse = function _parse(html) {
        return _domParser.parseFromString("<html><body>".concat(html, "</body></html>"), 'text/html').body;
      };

      /**
       * @param {string} html
       * @return {DocumentFragment}
       */
      var _parseFragment = function _parseFragment(html) {
        return _fragment( /** @type {any} */_parse(html).childNodes);
      };

      /**
       * @param {string} html
       * @return {HTMLElement}
       */
      var _parseElement = function _parseElement(html) {
        return (/** @type HTMLElement */_parse(html).firstElementChild
        );
      };

      /**
       * @param {HTMLElement} oldEl
       * @param {HTMLElement|DocumentFragment} newEl
       */
      var _replaceWith = function _replaceWith(oldEl, newEl) {
        return oldEl.replaceWith(newEl);
      };

      /**
       * @param {HTMLElement} parent
       * @param {HTMLElement} el
       * @param {Node|null} ref
       * @return {HTMLElement}
       */
      var _insertBefore = function _insertBefore(parent, el, ref) {
        return parent.insertBefore(el, ref);
      };

      /**
       * @param {Node} parent
       * @param {Node} child
       * @return {Node}
       */
      var _appendChild = function _appendChild(parent, child) {
        return parent.appendChild(child);
      };
      var _ELEMENT_NODE = _doc.ELEMENT_NODE;
      var _TEXT_NODE = _doc.TEXT_NODE;
      var _CDATA_SECTION_NODE = _doc.CDATA_SECTION_NODE;
      var _COMMENT_NODE = _doc.COMMENT_NODE;
      var _DOCUMENT_NODE = _doc.DOCUMENT_NODE;
      var _DOCUMENT_TYPE_NODE = _doc.DOCUMENT_TYPE_NODE;
      var _DOCUMENT_FRAGMENT_NODE = _doc.DOCUMENT_FRAGMENT_NODE;

      /**
       * @param {any} node
       * @param {number} type
       */
      var _checkNodeType = function _checkNodeType(node, type) {
        return node.nodeType === type;
      };

      /**
       * @param {Node} parent
       * @param {HTMLElement} child
       */
      var _isParentOf = function _isParentOf(parent, child) {
        var p = child.parentNode;
        while (p && p !== parent) {
          p = p.parentNode;
        }
        return p === parent;
      };
      /* c8 ignore stop */

      /***/
    },

    /***/"./node_modules/lib0/encoding.js":
    /*!***************************************!*\
      !*** ./node_modules/lib0/encoding.js ***!
      \***************************************/
    /***/
    function node_modulesLib0EncodingJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Encoder: function Encoder() {
          return (/* binding */_Encoder
          );
        },
        /* harmony export */IncUintOptRleEncoder: function IncUintOptRleEncoder() {
          return (/* binding */_IncUintOptRleEncoder
          );
        },
        /* harmony export */IntDiffEncoder: function IntDiffEncoder() {
          return (/* binding */_IntDiffEncoder
          );
        },
        /* harmony export */IntDiffOptRleEncoder: function IntDiffOptRleEncoder() {
          return (/* binding */_IntDiffOptRleEncoder
          );
        },
        /* harmony export */RleEncoder: function RleEncoder() {
          return (/* binding */_RleEncoder
          );
        },
        /* harmony export */RleIntDiffEncoder: function RleIntDiffEncoder() {
          return (/* binding */_RleIntDiffEncoder
          );
        },
        /* harmony export */StringEncoder: function StringEncoder() {
          return (/* binding */_StringEncoder
          );
        },
        /* harmony export */UintOptRleEncoder: function UintOptRleEncoder() {
          return (/* binding */_UintOptRleEncoder
          );
        },
        /* harmony export */_writeVarStringNative: function _writeVarStringNative() {
          return (/* binding */_writeVarStringNative2
          );
        },
        /* harmony export */_writeVarStringPolyfill: function _writeVarStringPolyfill() {
          return (/* binding */_writeVarStringPolyfill2
          );
        },
        /* harmony export */createEncoder: function createEncoder() {
          return (/* binding */_createEncoder
          );
        },
        /* harmony export */encode: function encode() {
          return (/* binding */_encode
          );
        },
        /* harmony export */hasContent: function hasContent() {
          return (/* binding */_hasContent2
          );
        },
        /* harmony export */length: function length() {
          return (/* binding */_length
          );
        },
        /* harmony export */set: function set() {
          return (/* binding */_set
          );
        },
        /* harmony export */setUint16: function setUint16() {
          return (/* binding */_setUint
          );
        },
        /* harmony export */setUint32: function setUint32() {
          return (/* binding */_setUint2
          );
        },
        /* harmony export */setUint8: function setUint8() {
          return (/* binding */_setUint3
          );
        },
        /* harmony export */toUint8Array: function toUint8Array() {
          return (/* binding */_toUint8Array
          );
        },
        /* harmony export */verifyLen: function verifyLen() {
          return (/* binding */_verifyLen
          );
        },
        /* harmony export */write: function write() {
          return (/* binding */_write
          );
        },
        /* harmony export */writeAny: function writeAny() {
          return (/* binding */_writeAny
          );
        },
        /* harmony export */writeBigInt64: function writeBigInt64() {
          return (/* binding */_writeBigInt
          );
        },
        /* harmony export */writeBigUint64: function writeBigUint64() {
          return (/* binding */_writeBigUint
          );
        },
        /* harmony export */writeBinaryEncoder: function writeBinaryEncoder() {
          return (/* binding */_writeBinaryEncoder
          );
        },
        /* harmony export */writeFloat32: function writeFloat32() {
          return (/* binding */_writeFloat
          );
        },
        /* harmony export */writeFloat64: function writeFloat64() {
          return (/* binding */_writeFloat2
          );
        },
        /* harmony export */writeOnDataView: function writeOnDataView() {
          return (/* binding */_writeOnDataView
          );
        },
        /* harmony export */writeTerminatedString: function writeTerminatedString() {
          return (/* binding */_writeTerminatedString
          );
        },
        /* harmony export */writeTerminatedUint8Array: function writeTerminatedUint8Array() {
          return (/* binding */_writeTerminatedUint8Array
          );
        },
        /* harmony export */writeUint16: function writeUint16() {
          return (/* binding */_writeUint
          );
        },
        /* harmony export */writeUint32: function writeUint32() {
          return (/* binding */_writeUint2
          );
        },
        /* harmony export */writeUint32BigEndian: function writeUint32BigEndian() {
          return (/* binding */_writeUint32BigEndian
          );
        },
        /* harmony export */writeUint8: function writeUint8() {
          return (/* binding */_writeUint3
          );
        },
        /* harmony export */writeUint8Array: function writeUint8Array() {
          return (/* binding */_writeUint8Array
          );
        },
        /* harmony export */writeVarInt: function writeVarInt() {
          return (/* binding */_writeVarInt
          );
        },
        /* harmony export */writeVarString: function writeVarString() {
          return (/* binding */_writeVarString
          );
        },
        /* harmony export */writeVarUint: function writeVarUint() {
          return (/* binding */_writeVarUint
          );
        },
        /* harmony export */writeVarUint8Array: function writeVarUint8Array() {
          return (/* binding */_writeVarUint8Array
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _buffer_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./buffer.js */"./node_modules/lib0/buffer.js");
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _number_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./number.js */"./node_modules/lib0/number.js");
      /* harmony import */
      var _binary_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./binary.js */"./node_modules/lib0/binary.js");
      /* harmony import */
      var _string_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./string.js */"./node_modules/lib0/string.js");
      /* harmony import */
      var _array_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./array.js */"./node_modules/lib0/array.js");
      /**
       * Efficient schema-less binary encoding with support for variable length encoding.
       *
       * Use [lib0/encoding] with [lib0/decoding]. Every encoding function has a corresponding decoding function.
       *
       * Encodes numbers in little-endian order (least to most significant byte order)
       * and is compatible with Golang's binary encoding (https://golang.org/pkg/encoding/binary/)
       * which is also used in Protocol Buffers.
       *
       * ```js
       * // encoding step
       * const encoder = encoding.createEncoder()
       * encoding.writeVarUint(encoder, 256)
       * encoding.writeVarString(encoder, 'Hello world!')
       * const buf = encoding.toUint8Array(encoder)
       * ```
       *
       * ```js
       * // decoding step
       * const decoder = decoding.createDecoder(buf)
       * decoding.readVarUint(decoder) // => 256
       * decoding.readVarString(decoder) // => 'Hello world!'
       * decoding.hasContent(decoder) // => false - all data is read
       * ```
       *
       * @module encoding
       */

      /**
       * A BinaryEncoder handles the encoding to an Uint8Array.
       */
      var _Encoder = /*#__PURE__*/_createClass(function _Encoder() {
        _classCallCheck(this, _Encoder);
        this.cpos = 0;
        this.cbuf = new Uint8Array(100);
        /**
         * @type {Array<Uint8Array>}
         */
        this.bufs = [];
      });
      /**
       * @function
       * @return {Encoder}
       */
      var _createEncoder = function _createEncoder() {
        return new _Encoder();
      };

      /**
       * @param {function(Encoder):void} f
       */
      var _encode = function _encode(f) {
        var encoder = _createEncoder();
        f(encoder);
        return _toUint8Array(encoder);
      };

      /**
       * The current length of the encoded data.
       *
       * @function
       * @param {Encoder} encoder
       * @return {number}
       */
      var _length = function _length(encoder) {
        var len = encoder.cpos;
        for (var i = 0; i < encoder.bufs.length; i++) {
          len += encoder.bufs[i].length;
        }
        return len;
      };

      /**
       * Check whether encoder is empty.
       *
       * @function
       * @param {Encoder} encoder
       * @return {boolean}
       */
      var _hasContent2 = function _hasContent2(encoder) {
        return encoder.cpos > 0 || encoder.bufs.length > 0;
      };

      /**
       * Transform to Uint8Array.
       *
       * @function
       * @param {Encoder} encoder
       * @return {Uint8Array} The created ArrayBuffer.
       */
      var _toUint8Array = function _toUint8Array(encoder) {
        var uint8arr = new Uint8Array(_length(encoder));
        var curPos = 0;
        for (var i = 0; i < encoder.bufs.length; i++) {
          var d = encoder.bufs[i];
          uint8arr.set(d, curPos);
          curPos += d.length;
        }
        uint8arr.set(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos), curPos);
        return uint8arr;
      };

      /**
       * Verify that it is possible to write `len` bytes wtihout checking. If
       * necessary, a new Buffer with the required length is attached.
       *
       * @param {Encoder} encoder
       * @param {number} len
       */
      var _verifyLen = function _verifyLen(encoder, len) {
        var bufferLen = encoder.cbuf.length;
        if (bufferLen - encoder.cpos < len) {
          encoder.bufs.push(_buffer_js__WEBPACK_IMPORTED_MODULE_0__.createUint8ArrayViewFromArrayBuffer(encoder.cbuf.buffer, 0, encoder.cpos));
          encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen, len) * 2);
          encoder.cpos = 0;
        }
      };

      /**
       * Write one byte to the encoder.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The byte that is to be encoded.
       */
      var _write = function _write(encoder, num) {
        var bufferLen = encoder.cbuf.length;
        if (encoder.cpos === bufferLen) {
          encoder.bufs.push(encoder.cbuf);
          encoder.cbuf = new Uint8Array(bufferLen * 2);
          encoder.cpos = 0;
        }
        encoder.cbuf[encoder.cpos++] = num;
      };

      /**
       * Write one byte at a specific position.
       * Position must already be written (i.e. encoder.length > pos)
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} pos Position to which to write data
       * @param {number} num Unsigned 8-bit integer
       */
      var _set = function _set(encoder, pos, num) {
        var buffer = null;
        // iterate all buffers and adjust position
        for (var i = 0; i < encoder.bufs.length && buffer === null; i++) {
          var b = encoder.bufs[i];
          if (pos < b.length) {
            buffer = b; // found buffer
          } else {
            pos -= b.length;
          }
        }
        if (buffer === null) {
          // use current buffer
          buffer = encoder.cbuf;
        }
        buffer[pos] = num;
      };

      /**
       * Write one byte as an unsigned integer.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeUint3 = _write;

      /**
       * Write one byte as an unsigned Integer at a specific location.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */
      var _setUint3 = _set;

      /**
       * Write two bytes as an unsigned integer.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeUint = function _writeUint(encoder, num) {
        _write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
        _write(encoder, num >>> 8 & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
      };
      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */
      var _setUint = function _setUint(encoder, pos, num) {
        _set(encoder, pos, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
        _set(encoder, pos + 1, num >>> 8 & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
      };

      /**
       * Write two bytes as an unsigned integer
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeUint2 = function _writeUint2(encoder, num) {
        for (var i = 0; i < 4; i++) {
          _write(encoder, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
          num >>>= 8;
        }
      };

      /**
       * Write two bytes as an unsigned integer in big endian order.
       * (most significant byte first)
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeUint32BigEndian = function _writeUint32BigEndian(encoder, num) {
        for (var i = 3; i >= 0; i--) {
          _write(encoder, num >>> 8 * i & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
        }
      };

      /**
       * Write two bytes as an unsigned integer at a specific location.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} pos The location where the data will be written.
       * @param {number} num The number that is to be encoded.
       */
      var _setUint2 = function _setUint2(encoder, pos, num) {
        for (var i = 0; i < 4; i++) {
          _set(encoder, pos + i, num & _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS8);
          num >>>= 8;
        }
      };

      /**
       * Write a variable length unsigned integer. Max encodable integer is 2^53.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeVarUint = function _writeVarUint(encoder, num) {
        while (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7) {
          _write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 | _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num);
          num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 128); // shift >>> 7
        }

        _write(encoder, _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num);
      };

      /**
       * Write a variable length integer.
       *
       * We use the 7th bit instead for signaling that this is a negative number.
       *
       * @function
       * @param {Encoder} encoder
       * @param {number} num The number that is to be encoded.
       */
      var _writeVarInt = function _writeVarInt(encoder, num) {
        var isNegative = _math_js__WEBPACK_IMPORTED_MODULE_1__.isNegativeZero(num);
        if (isNegative) {
          num = -num;
        }
        //             |- whether to continue reading         |- whether is negative     |- number
        _write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | (isNegative ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT7 : 0) | _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS6 & num);
        num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 64); // shift >>> 6
        // We don't need to consider the case of num === 0 so we can use a different
        // pattern here than above.
        while (num > 0) {
          _write(encoder, (num > _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 ? _binary_js__WEBPACK_IMPORTED_MODULE_2__.BIT8 : 0) | _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS7 & num);
          num = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num / 128); // shift >>> 7
        }
      };

      /**
       * A cache to store strings temporarily
       */
      var _strBuffer = new Uint8Array(30000);
      var _maxStrBSize = _strBuffer.length / 3;

      /**
       * Write a variable length string.
       *
       * @function
       * @param {Encoder} encoder
       * @param {String} str The string that is to be encoded.
       */
      var _writeVarStringNative2 = function _writeVarStringNative2(encoder, str) {
        if (str.length < _maxStrBSize) {
          // We can encode the string into the existing buffer
          /* c8 ignore next */
          var written = _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder.encodeInto(str, _strBuffer).written || 0;
          _writeVarUint(encoder, written);
          for (var i = 0; i < written; i++) {
            _write(encoder, _strBuffer[i]);
          }
        } else {
          _writeVarUint8Array(encoder, _string_js__WEBPACK_IMPORTED_MODULE_3__.encodeUtf8(str));
        }
      };

      /**
       * Write a variable length string.
       *
       * @function
       * @param {Encoder} encoder
       * @param {String} str The string that is to be encoded.
       */
      var _writeVarStringPolyfill2 = function _writeVarStringPolyfill2(encoder, str) {
        var encodedString = unescape(encodeURIComponent(str));
        var len = encodedString.length;
        _writeVarUint(encoder, len);
        for (var i = 0; i < len; i++) {
          _write(encoder, /** @type {number} */encodedString.codePointAt(i));
        }
      };

      /**
       * Write a variable length string.
       *
       * @function
       * @param {Encoder} encoder
       * @param {String} str The string that is to be encoded.
       */
      /* c8 ignore next */
      var _writeVarString = _string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder && /** @type {any} */_string_js__WEBPACK_IMPORTED_MODULE_3__.utf8TextEncoder.encodeInto ? _writeVarStringNative2 : _writeVarStringPolyfill2;

      /**
       * Write a string terminated by a special byte sequence. This is not very performant and is
       * generally discouraged. However, the resulting byte arrays are lexiographically ordered which
       * makes this a nice feature for databases.
       *
       * The string will be encoded using utf8 and then terminated and escaped using writeTerminatingUint8Array.
       *
       * @function
       * @param {Encoder} encoder
       * @param {String} str The string that is to be encoded.
       */
      var _writeTerminatedString = function _writeTerminatedString(encoder, str) {
        return _writeTerminatedUint8Array(encoder, _string_js__WEBPACK_IMPORTED_MODULE_3__.encodeUtf8(str));
      };

      /**
       * Write a terminating Uint8Array. Note that this is not performant and is generally
       * discouraged. There are few situations when this is needed.
       *
       * We use 0x0 as a terminating character. 0x1 serves as an escape character for 0x0 and 0x1.
       *
       * Example: [0,1,2] is encoded to [1,0,1,1,2,0]. 0x0, and 0x1 needed to be escaped using 0x1. Then
       * the result is terminated using the 0x0 character.
       *
       * This is basically how many systems implement null terminated strings. However, we use an escape
       * character 0x1 to avoid issues and potenial attacks on our database (if this is used as a key
       * encoder for NoSql databases).
       *
       * @function
       * @param {Encoder} encoder
       * @param {Uint8Array} buf The string that is to be encoded.
       */
      var _writeTerminatedUint8Array = function _writeTerminatedUint8Array(encoder, buf) {
        for (var i = 0; i < buf.length; i++) {
          var b = buf[i];
          if (b === 0 || b === 1) {
            _write(encoder, 1);
          }
          _write(encoder, buf[i]);
        }
        _write(encoder, 0);
      };

      /**
       * Write the content of another Encoder.
       *
       * @TODO: can be improved!
       *        - Note: Should consider that when appending a lot of small Encoders, we should rather clone than referencing the old structure.
       *                Encoders start with a rather big initial buffer.
       *
       * @function
       * @param {Encoder} encoder The enUint8Arr
       * @param {Encoder} append The BinaryEncoder to be written.
       */
      var _writeBinaryEncoder = function _writeBinaryEncoder(encoder, append) {
        return _writeUint8Array(encoder, _toUint8Array(append));
      };

      /**
       * Append fixed-length Uint8Array to the encoder.
       *
       * @function
       * @param {Encoder} encoder
       * @param {Uint8Array} uint8Array
       */
      var _writeUint8Array = function _writeUint8Array(encoder, uint8Array) {
        var bufferLen = encoder.cbuf.length;
        var cpos = encoder.cpos;
        var leftCopyLen = _math_js__WEBPACK_IMPORTED_MODULE_1__.min(bufferLen - cpos, uint8Array.length);
        var rightCopyLen = uint8Array.length - leftCopyLen;
        encoder.cbuf.set(uint8Array.subarray(0, leftCopyLen), cpos);
        encoder.cpos += leftCopyLen;
        if (rightCopyLen > 0) {
          // Still something to write, write right half..
          // Append new buffer
          encoder.bufs.push(encoder.cbuf);
          // must have at least size of remaining buffer
          encoder.cbuf = new Uint8Array(_math_js__WEBPACK_IMPORTED_MODULE_1__.max(bufferLen * 2, rightCopyLen));
          // copy array
          encoder.cbuf.set(uint8Array.subarray(leftCopyLen));
          encoder.cpos = rightCopyLen;
        }
      };

      /**
       * Append an Uint8Array to Encoder.
       *
       * @function
       * @param {Encoder} encoder
       * @param {Uint8Array} uint8Array
       */
      var _writeVarUint8Array = function _writeVarUint8Array(encoder, uint8Array) {
        _writeVarUint(encoder, uint8Array.byteLength);
        _writeUint8Array(encoder, uint8Array);
      };

      /**
       * Create an DataView of the next `len` bytes. Use it to write data after
       * calling this function.
       *
       * ```js
       * // write float32 using DataView
       * const dv = writeOnDataView(encoder, 4)
       * dv.setFloat32(0, 1.1)
       * // read float32 using DataView
       * const dv = readFromDataView(encoder, 4)
       * dv.getFloat32(0) // => 1.100000023841858 (leaving it to the reader to find out why this is the correct result)
       * ```
       *
       * @param {Encoder} encoder
       * @param {number} len
       * @return {DataView}
       */
      var _writeOnDataView = function _writeOnDataView(encoder, len) {
        _verifyLen(encoder, len);
        var dview = new DataView(encoder.cbuf.buffer, encoder.cpos, len);
        encoder.cpos += len;
        return dview;
      };

      /**
       * @param {Encoder} encoder
       * @param {number} num
       */
      var _writeFloat = function _writeFloat(encoder, num) {
        return _writeOnDataView(encoder, 4).setFloat32(0, num, false);
      };

      /**
       * @param {Encoder} encoder
       * @param {number} num
       */
      var _writeFloat2 = function _writeFloat2(encoder, num) {
        return _writeOnDataView(encoder, 8).setFloat64(0, num, false);
      };

      /**
       * @param {Encoder} encoder
       * @param {bigint} num
       */
      var _writeBigInt = function _writeBigInt(encoder, num) {
        return (/** @type {any} */_writeOnDataView(encoder, 8).setBigInt64(0, num, false)
        );
      };

      /**
       * @param {Encoder} encoder
       * @param {bigint} num
       */
      var _writeBigUint = function _writeBigUint(encoder, num) {
        return (/** @type {any} */_writeOnDataView(encoder, 8).setBigUint64(0, num, false)
        );
      };
      var floatTestBed = new DataView(new ArrayBuffer(4));
      /**
       * Check if a number can be encoded as a 32 bit float.
       *
       * @param {number} num
       * @return {boolean}
       */
      var isFloat32 = function isFloat32(num) {
        floatTestBed.setFloat32(0, num);
        return floatTestBed.getFloat32(0) === num;
      };

      /**
       * Encode data with efficient binary format.
       *
       * Differences to JSON:
       *  Transforms data to a binary format (not to a string)
       *  Encodes undefined, NaN, and ArrayBuffer (these can't be represented in JSON)
       *  Numbers are efficiently encoded either as a variable length integer, as a
       *   32 bit float, as a 64 bit float, or as a 64 bit bigint.
       *
       * Encoding table:
       *
       * | Data Type           | Prefix   | Encoding Method    | Comment |
       * | ------------------- | -------- | ------------------ | ------- |
       * | undefined           | 127      |                    | Functions, symbol, and everything that cannot be identified is encoded as undefined |
       * | null                | 126      |                    | |
       * | integer             | 125      | writeVarInt        | Only encodes 32 bit signed integers |
       * | float32             | 124      | writeFloat32       | |
       * | float64             | 123      | writeFloat64       | |
       * | bigint              | 122      | writeBigInt64      | |
       * | boolean (false)     | 121      |                    | True and false are different data types so we save the following byte |
       * | boolean (true)      | 120      |                    | - 0b01111000 so the last bit determines whether true or false |
       * | string              | 119      | writeVarString     | |
       * | object<string,any>  | 118      | custom             | Writes {length} then {length} key-value pairs |
       * | array<any>          | 117      | custom             | Writes {length} then {length} json values |
       * | Uint8Array          | 116      | writeVarUint8Array | We use Uint8Array for any kind of binary data |
       *
       * Reasons for the decreasing prefix:
       * We need the first bit for extendability (later we may want to encode the
       * prefix with writeVarUint). The remaining 7 bits are divided as follows:
       * [0-30]   the beginning of the data range is used for custom purposes
       *          (defined by the function that uses this library)
       * [31-127] the end of the data range is used for data encoding by
       *          lib0/encoding.js
       *
       * @param {Encoder} encoder
       * @param {undefined|null|number|bigint|boolean|string|Object<string,any>|Array<any>|Uint8Array} data
       */
      var _writeAny = function _writeAny(encoder, data) {
        switch (typeof data) {
          case 'string':
            // TYPE 119: STRING
            _write(encoder, 119);
            _writeVarString(encoder, data);
            break;
          case 'number':
            if (_number_js__WEBPACK_IMPORTED_MODULE_4__.isInteger(data) && _math_js__WEBPACK_IMPORTED_MODULE_1__.abs(data) <= _binary_js__WEBPACK_IMPORTED_MODULE_2__.BITS31) {
              // TYPE 125: INTEGER
              _write(encoder, 125);
              _writeVarInt(encoder, data);
            } else if (isFloat32(data)) {
              // TYPE 124: FLOAT32
              _write(encoder, 124);
              _writeFloat(encoder, data);
            } else {
              // TYPE 123: FLOAT64
              _write(encoder, 123);
              _writeFloat2(encoder, data);
            }
            break;
          case 'bigint':
            // TYPE 122: BigInt
            _write(encoder, 122);
            _writeBigInt(encoder, data);
            break;
          case 'object':
            if (data === null) {
              // TYPE 126: null
              _write(encoder, 126);
            } else if (_array_js__WEBPACK_IMPORTED_MODULE_5__.isArray(data)) {
              // TYPE 117: Array
              _write(encoder, 117);
              _writeVarUint(encoder, data.length);
              for (var i = 0; i < data.length; i++) {
                _writeAny(encoder, data[i]);
              }
            } else if (data instanceof Uint8Array) {
              // TYPE 116: ArrayBuffer
              _write(encoder, 116);
              _writeVarUint8Array(encoder, data);
            } else {
              // TYPE 118: Object
              _write(encoder, 118);
              var keys = Object.keys(data);
              _writeVarUint(encoder, keys.length);
              for (var _i = 0; _i < keys.length; _i++) {
                var key = keys[_i];
                _writeVarString(encoder, key);
                _writeAny(encoder, data[key]);
              }
            }
            break;
          case 'boolean':
            // TYPE 120/121: boolean (true/false)
            _write(encoder, data ? 120 : 121);
            break;
          default:
            // TYPE 127: undefined
            _write(encoder, 127);
        }
      };

      /**
       * Now come a few stateful encoder that have their own classes.
       */

      /**
       * Basic Run Length Encoder - a basic compression implementation.
       *
       * Encodes [1,1,1,7] to [1,3,7,1] (3 times 1, 1 time 7). This encoder might do more harm than good if there are a lot of values that are not repeated.
       *
       * It was originally used for image compression. Cool .. article http://csbruce.com/cbm/transactor/pdfs/trans_v7_i06.pdf
       *
       * @note T must not be null!
       *
       * @template T
       */
      var _RleEncoder = /*#__PURE__*/function (_Encoder2) {
        _inherits(_RleEncoder, _Encoder2);
        var _super7 = _createSuper(_RleEncoder);
        /**
         * @param {function(Encoder, T):void} writer
         */
        function _RleEncoder(writer) {
          var _this7;
          _classCallCheck(this, _RleEncoder);
          _this7 = _super7.call(this);
          /**
           * The writer
           */
          _this7.w = writer;
          /**
           * Current state
           * @type {T|null}
           */
          _this7.s = null;
          _this7.count = 0;
          return _this7;
        }

        /**
         * @param {T} v
         */
        _createClass(_RleEncoder, [{
          key: "write",
          value: function write(v) {
            if (this.s === v) {
              this.count++;
            } else {
              if (this.count > 0) {
                // flush counter, unless this is the first value (count = 0)
                _writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw
              }

              this.count = 1;
              // write first value
              this.w(this, v);
              this.s = v;
            }
          }
        }]);
        return _RleEncoder;
      }(_Encoder);
      /**
       * Basic diff decoder using variable length encoding.
       *
       * Encodes the values [3, 1100, 1101, 1050, 0] to [3, 1097, 1, -51, -1050] using writeVarInt.
       */
      var _IntDiffEncoder = /*#__PURE__*/function (_Encoder3) {
        _inherits(_IntDiffEncoder, _Encoder3);
        var _super8 = _createSuper(_IntDiffEncoder);
        /**
         * @param {number} start
         */
        function _IntDiffEncoder(start) {
          var _this8;
          _classCallCheck(this, _IntDiffEncoder);
          _this8 = _super8.call(this);
          /**
           * Current state
           * @type {number}
           */
          _this8.s = start;
          return _this8;
        }

        /**
         * @param {number} v
         */
        _createClass(_IntDiffEncoder, [{
          key: "write",
          value: function write(v) {
            _writeVarInt(this, v - this.s);
            this.s = v;
          }
        }]);
        return _IntDiffEncoder;
      }(_Encoder);
      /**
       * A combination of IntDiffEncoder and RleEncoder.
       *
       * Basically first writes the IntDiffEncoder and then counts duplicate diffs using RleEncoding.
       *
       * Encodes the values [1,1,1,2,3,4,5,6] as [1,1,0,2,1,5] (RLE([1,0,0,1,1,1,1,1])  RleIntDiff[1,1,0,2,1,5])
       */
      var _RleIntDiffEncoder = /*#__PURE__*/function (_Encoder4) {
        _inherits(_RleIntDiffEncoder, _Encoder4);
        var _super9 = _createSuper(_RleIntDiffEncoder);
        /**
         * @param {number} start
         */
        function _RleIntDiffEncoder(start) {
          var _this9;
          _classCallCheck(this, _RleIntDiffEncoder);
          _this9 = _super9.call(this);
          /**
           * Current state
           * @type {number}
           */
          _this9.s = start;
          _this9.count = 0;
          return _this9;
        }

        /**
         * @param {number} v
         */
        _createClass(_RleIntDiffEncoder, [{
          key: "write",
          value: function write(v) {
            if (this.s === v && this.count > 0) {
              this.count++;
            } else {
              if (this.count > 0) {
                // flush counter, unless this is the first value (count = 0)
                _writeVarUint(this, this.count - 1); // since count is always > 0, we can decrement by one. non-standard encoding ftw
              }

              this.count = 1;
              // write first value
              _writeVarInt(this, v - this.s);
              this.s = v;
            }
          }
        }]);
        return _RleIntDiffEncoder;
      }(_Encoder);
      /**
       * @param {UintOptRleEncoder} encoder
       */
      var flushUintOptRleEncoder = function flushUintOptRleEncoder(encoder) {
        if (encoder.count > 0) {
          // flush counter, unless this is the first value (count = 0)
          // case 1: just a single value. set sign to positive
          // case 2: write several values. set sign to negative to indicate that there is a length coming
          _writeVarInt(encoder.encoder, encoder.count === 1 ? encoder.s : -encoder.s);
          if (encoder.count > 1) {
            _writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw
          }
        }
      };

      /**
       * Optimized Rle encoder that does not suffer from the mentioned problem of the basic Rle encoder.
       *
       * Internally uses VarInt encoder to write unsigned integers. If the input occurs multiple times, we write
       * write it as a negative number. The UintOptRleDecoder then understands that it needs to read a count.
       *
       * Encodes [1,2,3,3,3] as [1,2,-3,3] (once 1, once 2, three times 3)
       */
      var _UintOptRleEncoder = /*#__PURE__*/function () {
        function _UintOptRleEncoder() {
          _classCallCheck(this, _UintOptRleEncoder);
          this.encoder = new _Encoder();
          /**
           * @type {number}
           */
          this.s = 0;
          this.count = 0;
        }

        /**
         * @param {number} v
         */
        _createClass(_UintOptRleEncoder, [{
          key: "write",
          value: function write(v) {
            if (this.s === v) {
              this.count++;
            } else {
              flushUintOptRleEncoder(this);
              this.count = 1;
              this.s = v;
            }
          }
        }, {
          key: "toUint8Array",
          value: function toUint8Array() {
            flushUintOptRleEncoder(this);
            return _toUint8Array(this.encoder);
          }
        }]);
        return _UintOptRleEncoder;
      }();
      /**
       * Increasing Uint Optimized RLE Encoder
       *
       * The RLE encoder counts the number of same occurences of the same value.
       * The IncUintOptRle encoder counts if the value increases.
       * I.e. 7, 8, 9, 10 will be encoded as [-7, 4]. 1, 3, 5 will be encoded
       * as [1, 3, 5].
       */
      var _IncUintOptRleEncoder = /*#__PURE__*/function () {
        function _IncUintOptRleEncoder() {
          _classCallCheck(this, _IncUintOptRleEncoder);
          this.encoder = new _Encoder();
          /**
           * @type {number}
           */
          this.s = 0;
          this.count = 0;
        }

        /**
         * @param {number} v
         */
        _createClass(_IncUintOptRleEncoder, [{
          key: "write",
          value: function write(v) {
            if (this.s + this.count === v) {
              this.count++;
            } else {
              flushUintOptRleEncoder(this);
              this.count = 1;
              this.s = v;
            }
          }
        }, {
          key: "toUint8Array",
          value: function toUint8Array() {
            flushUintOptRleEncoder(this);
            return _toUint8Array(this.encoder);
          }
        }]);
        return _IncUintOptRleEncoder;
      }();
      /**
       * @param {IntDiffOptRleEncoder} encoder
       */
      var flushIntDiffOptRleEncoder = function flushIntDiffOptRleEncoder(encoder) {
        if (encoder.count > 0) {
          //          31 bit making up the diff | wether to write the counter
          // const encodedDiff = encoder.diff << 1 | (encoder.count === 1 ? 0 : 1)
          var encodedDiff = encoder.diff * 2 + (encoder.count === 1 ? 0 : 1);
          // flush counter, unless this is the first value (count = 0)
          // case 1: just a single value. set first bit to positive
          // case 2: write several values. set first bit to negative to indicate that there is a length coming
          _writeVarInt(encoder.encoder, encodedDiff);
          if (encoder.count > 1) {
            _writeVarUint(encoder.encoder, encoder.count - 2); // since count is always > 1, we can decrement by one. non-standard encoding ftw
          }
        }
      };

      /**
       * A combination of the IntDiffEncoder and the UintOptRleEncoder.
       *
       * The count approach is similar to the UintDiffOptRleEncoder, but instead of using the negative bitflag, it encodes
       * in the LSB whether a count is to be read. Therefore this Encoder only supports 31 bit integers!
       *
       * Encodes [1, 2, 3, 2] as [3, 1, 6, -1] (more specifically [(1 << 1) | 1, (3 << 0) | 0, -1])
       *
       * Internally uses variable length encoding. Contrary to normal UintVar encoding, the first byte contains:
       * * 1 bit that denotes whether the next value is a count (LSB)
       * * 1 bit that denotes whether this value is negative (MSB - 1)
       * * 1 bit that denotes whether to continue reading the variable length integer (MSB)
       *
       * Therefore, only five bits remain to encode diff ranges.
       *
       * Use this Encoder only when appropriate. In most cases, this is probably a bad idea.
       */
      var _IntDiffOptRleEncoder = /*#__PURE__*/function () {
        function _IntDiffOptRleEncoder() {
          _classCallCheck(this, _IntDiffOptRleEncoder);
          this.encoder = new _Encoder();
          /**
           * @type {number}
           */
          this.s = 0;
          this.count = 0;
          this.diff = 0;
        }

        /**
         * @param {number} v
         */
        _createClass(_IntDiffOptRleEncoder, [{
          key: "write",
          value: function write(v) {
            if (this.diff === v - this.s) {
              this.s = v;
              this.count++;
            } else {
              flushIntDiffOptRleEncoder(this);
              this.count = 1;
              this.diff = v - this.s;
              this.s = v;
            }
          }
        }, {
          key: "toUint8Array",
          value: function toUint8Array() {
            flushIntDiffOptRleEncoder(this);
            return _toUint8Array(this.encoder);
          }
        }]);
        return _IntDiffOptRleEncoder;
      }();
      /**
       * Optimized String Encoder.
       *
       * Encoding many small strings in a simple Encoder is not very efficient. The function call to decode a string takes some time and creates references that must be eventually deleted.
       * In practice, when decoding several million small strings, the GC will kick in more and more often to collect orphaned string objects (or maybe there is another reason?).
       *
       * This string encoder solves the above problem. All strings are concatenated and written as a single string using a single encoding call.
       *
       * The lengths are encoded using a UintOptRleEncoder.
       */
      var _StringEncoder = /*#__PURE__*/function () {
        function _StringEncoder() {
          _classCallCheck(this, _StringEncoder);
          /**
           * @type {Array<string>}
           */
          this.sarr = [];
          this.s = '';
          this.lensE = new _UintOptRleEncoder();
        }

        /**
         * @param {string} string
         */
        _createClass(_StringEncoder, [{
          key: "write",
          value: function write(string) {
            this.s += string;
            if (this.s.length > 19) {
              this.sarr.push(this.s);
              this.s = '';
            }
            this.lensE.write(string.length);
          }
        }, {
          key: "toUint8Array",
          value: function toUint8Array() {
            var encoder = new _Encoder();
            this.sarr.push(this.s);
            this.s = '';
            _writeVarString(encoder, this.sarr.join(''));
            _writeUint8Array(encoder, this.lensE.toUint8Array());
            return _toUint8Array(encoder);
          }
        }]);
        return _StringEncoder;
      }();
      /***/
    },
    /***/"./node_modules/lib0/environment.js":
    /*!******************************************!*\
      !*** ./node_modules/lib0/environment.js ***!
      \******************************************/
    /***/
    function node_modulesLib0EnvironmentJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */getConf: function getConf() {
          return (/* binding */_getConf
          );
        },
        /* harmony export */getParam: function getParam() {
          return (/* binding */_getParam
          );
        },
        /* harmony export */getVariable: function getVariable() {
          return (/* binding */_getVariable
          );
        },
        /* harmony export */hasConf: function hasConf() {
          return (/* binding */_hasConf
          );
        },
        /* harmony export */hasParam: function hasParam() {
          return (/* binding */_hasParam
          );
        },
        /* harmony export */isBrowser: function isBrowser() {
          return (/* binding */_isBrowser
          );
        },
        /* harmony export */isMac: function isMac() {
          return (/* binding */_isMac
          );
        },
        /* harmony export */isNode: function isNode() {
          return (/* binding */_isNode
          );
        },
        /* harmony export */production: function production() {
          return (/* binding */_production
          );
        },
        /* harmony export */supportsColor: function supportsColor() {
          return (/* binding */_supportsColor
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./map.js */"./node_modules/lib0/map.js");
      /* harmony import */
      var _string_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./string.js */"./node_modules/lib0/string.js");
      /* harmony import */
      var _conditions_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./conditions.js */"./node_modules/lib0/conditions.js");
      /* harmony import */
      var _storage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./storage.js */"./node_modules/lib0/storage.js");
      /* harmony import */
      var _function_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./function.js */"./node_modules/lib0/function.js");
      /**
       * Isomorphic module to work access the environment (query params, env variables).
       *
       * @module map
       */

      /* c8 ignore next */
      // @ts-ignore
      var _isNode = typeof process !== 'undefined' && process.release && /node|io\.js/.test(process.release.name);
      /* c8 ignore next */
      var _isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && !_isNode;
      /* c8 ignore next 3 */
      var _isMac = typeof navigator !== 'undefined' ? /Mac/.test(navigator.platform) : false;

      /**
       * @type {Map<string,string>}
       */
      var params;
      var args = [];

      /* c8 ignore start */
      var computeParams = function computeParams() {
        if (params === undefined) {
          if (_isNode) {
            params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
            var pargs = process.argv;
            var currParamName = null;
            for (var i = 0; i < pargs.length; i++) {
              var parg = pargs[i];
              if (parg[0] === '-') {
                if (currParamName !== null) {
                  params.set(currParamName, '');
                }
                currParamName = parg;
              } else {
                if (currParamName !== null) {
                  params.set(currParamName, parg);
                  currParamName = null;
                } else {
                  args.push(parg);
                }
              }
            }
            if (currParamName !== null) {
              params.set(currParamName, '');
            }
            // in ReactNative for example this would not be true (unless connected to the Remote Debugger)
          } else if (typeof location === 'object') {
            params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create(); // eslint-disable-next-line no-undef
            (location.search || '?').slice(1).split('&').forEach(function (kv) {
              if (kv.length !== 0) {
                var _kv$split = kv.split('='),
                  _kv$split2 = _slicedToArray(_kv$split, 2),
                  key = _kv$split2[0],
                  value = _kv$split2[1];
                params.set("--".concat(_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')), value);
                params.set("-".concat(_string_js__WEBPACK_IMPORTED_MODULE_1__.fromCamelCase(key, '-')), value);
              }
            });
          } else {
            params = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
          }
        }
        return params;
      };
      /* c8 ignore stop */

      /**
       * @param {string} name
       * @return {boolean}
       */
      /* c8 ignore next */
      var _hasParam = function _hasParam(name) {
        return computeParams().has(name);
      };

      /**
       * @param {string} name
       * @param {string} defaultVal
       * @return {string}
       */
      /* c8 ignore next 2 */
      var _getParam = function _getParam(name, defaultVal) {
        return computeParams().get(name) || defaultVal;
      };

      /**
       * @param {string} name
       * @return {string|null}
       */
      /* c8 ignore next 4 */
      var _getVariable = function _getVariable(name) {
        return _isNode ? _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(process.env[name.toUpperCase()]) : _conditions_js__WEBPACK_IMPORTED_MODULE_2__.undefinedToNull(_storage_js__WEBPACK_IMPORTED_MODULE_3__.varStorage.getItem(name));
      };

      /**
       * @param {string} name
       * @return {string|null}
       */
      /* c8 ignore next 2 */
      var _getConf = function _getConf(name) {
        return computeParams().get('--' + name) || _getVariable(name);
      };

      /**
       * @param {string} name
       * @return {boolean}
       */
      /* c8 ignore next 2 */
      var _hasConf = function _hasConf(name) {
        return _hasParam('--' + name) || _getVariable(name) !== null;
      };

      /* c8 ignore next */
      var _production = _hasConf('production');

      /* c8 ignore next 2 */
      var forceColor = _isNode && _function_js__WEBPACK_IMPORTED_MODULE_4__.isOneOf(process.env.FORCE_COLOR, ['true', '1', '2']);

      /* c8 ignore start */
      var _supportsColor = !_hasParam('no-colors') && (!_isNode || process.stdout.isTTY || forceColor) && (!_isNode || _hasParam('color') || forceColor || _getVariable('COLORTERM') !== null || (_getVariable('TERM') || '').includes('color'));
      /* c8 ignore stop */

      /***/
    },

    /***/"./node_modules/lib0/error.js":
    /*!************************************!*\
      !*** ./node_modules/lib0/error.js ***!
      \************************************/
    /***/
    function node_modulesLib0ErrorJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */create: function create() {
          return (/* binding */_create2
          );
        },
        /* harmony export */methodUnimplemented: function methodUnimplemented() {
          return (/* binding */_methodUnimplemented
          );
        },
        /* harmony export */unexpectedCase: function unexpectedCase() {
          return (/* binding */_unexpectedCase
          );
        }
        /* harmony export */
      });
      /**
       * Error helpers.
       *
       * @module error
       */

      /**
       * @param {string} s
       * @return {Error}
       */
      /* c8 ignore next */
      var _create2 = function _create2(s) {
        return new Error(s);
      };

      /**
       * @throws {Error}
       * @return {never}
       */
      /* c8 ignore next 3 */
      var _methodUnimplemented = function _methodUnimplemented() {
        throw _create2('Method unimplemented');
      };

      /**
       * @throws {Error}
       * @return {never}
       */
      /* c8 ignore next 3 */
      var _unexpectedCase = function _unexpectedCase() {
        throw _create2('Unexpected case');
      };

      /***/
    },

    /***/"./node_modules/lib0/eventloop.js":
    /*!****************************************!*\
      !*** ./node_modules/lib0/eventloop.js ***!
      \****************************************/
    /***/
    function node_modulesLib0EventloopJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Animation: function Animation() {
          return (/* binding */_Animation
          );
        },
        /* harmony export */animationFrame: function animationFrame() {
          return (/* binding */_animationFrame
          );
        },
        /* harmony export */createDebouncer: function createDebouncer() {
          return (/* binding */_createDebouncer
          );
        },
        /* harmony export */enqueue: function enqueue() {
          return (/* binding */_enqueue
          );
        },
        /* harmony export */idleCallback: function idleCallback() {
          return (/* binding */_idleCallback
          );
        },
        /* harmony export */interval: function interval() {
          return (/* binding */_interval
          );
        },
        /* harmony export */timeout: function timeout() {
          return (/* binding */_timeout
          );
        }
        /* harmony export */
      });
      /* global requestIdleCallback, requestAnimationFrame, cancelIdleCallback, cancelAnimationFrame */

      /**
       * Utility module to work with EcmaScript's event loop.
       *
       * @module eventloop
       */

      /**
       * @type {Array<function>}
       */
      var queue = [];
      var _runQueue = function _runQueue() {
        for (var i = 0; i < queue.length; i++) {
          queue[i]();
        }
        queue = [];
      };

      /**
       * @param {function():void} f
       */
      var _enqueue = function _enqueue(f) {
        queue.push(f);
        if (queue.length === 1) {
          setTimeout(_runQueue, 0);
        }
      };

      /**
       * @typedef {Object} TimeoutObject
       * @property {function} TimeoutObject.destroy
       */

      /**
       * @param {function(number):void} clearFunction
       */
      var createTimeoutClass = function createTimeoutClass(clearFunction) {
        return /*#__PURE__*/function () {
          /**
           * @param {number} timeoutId
           */
          function TT(timeoutId) {
            _classCallCheck(this, TT);
            this._ = timeoutId;
          }
          _createClass(TT, [{
            key: "destroy",
            value: function destroy() {
              clearFunction(this._);
            }
          }]);
          return TT;
        }();
      };
      var Timeout = createTimeoutClass(clearTimeout);

      /**
       * @param {number} timeout
       * @param {function} callback
       * @return {TimeoutObject}
       */
      var _timeout = function _timeout(timeout, callback) {
        return new Timeout(setTimeout(callback, timeout));
      };
      var Interval = createTimeoutClass(clearInterval);

      /**
       * @param {number} timeout
       * @param {function} callback
       * @return {TimeoutObject}
       */
      var _interval = function _interval(timeout, callback) {
        return new Interval(setInterval(callback, timeout));
      };

      /* c8 ignore next */
      var _Animation = createTimeoutClass(function (arg) {
        return typeof requestAnimationFrame !== 'undefined' && cancelAnimationFrame(arg);
      });

      /**
       * @param {function(number):void} cb
       * @return {TimeoutObject}
       */
      /* c8 ignore next */
      var _animationFrame = function _animationFrame(cb) {
        return typeof requestAnimationFrame === 'undefined' ? _timeout(0, cb) : new _Animation(requestAnimationFrame(cb));
      };

      /* c8 ignore next */
      // @ts-ignore
      var Idle = createTimeoutClass(function (arg) {
        return typeof cancelIdleCallback !== 'undefined' && cancelIdleCallback(arg);
      });

      /**
       * Note: this is experimental and is probably only useful in browsers.
       *
       * @param {function} cb
       * @return {TimeoutObject}
       */
      /* c8 ignore next 2 */
      // @ts-ignore
      var _idleCallback = function _idleCallback(cb) {
        return typeof requestIdleCallback !== 'undefined' ? new Idle(requestIdleCallback(cb)) : _timeout(1000, cb);
      };

      /**
       * @param {number} timeout Timeout of the debounce action
       * @return {function(function():void):void}
       */
      var _createDebouncer = function _createDebouncer(timeout) {
        var timer = -1;
        return function (f) {
          clearTimeout(timer);
          if (f) {
            timer = /** @type {any} */setTimeout(f, timeout);
          }
        };
      };

      /***/
    },

    /***/"./node_modules/lib0/function.js":
    /*!***************************************!*\
      !*** ./node_modules/lib0/function.js ***!
      \***************************************/
    /***/
    function node_modulesLib0FunctionJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */apply: function apply() {
          return (/* binding */_apply
          );
        },
        /* harmony export */callAll: function callAll() {
          return (/* binding */_callAll
          );
        },
        /* harmony export */equalityDeep: function equalityDeep() {
          return (/* binding */_equalityDeep
          );
        },
        /* harmony export */equalityFlat: function equalityFlat() {
          return (/* binding */_equalityFlat
          );
        },
        /* harmony export */equalityStrict: function equalityStrict() {
          return (/* binding */_equalityStrict
          );
        },
        /* harmony export */id: function id() {
          return (/* binding */_id
          );
        },
        /* harmony export */is: function is() {
          return (/* binding */_is
          );
        },
        /* harmony export */isArray: function isArray() {
          return (/* binding */_isArray2
          );
        },
        /* harmony export */isNumber: function isNumber() {
          return (/* binding */_isNumber
          );
        },
        /* harmony export */isOneOf: function isOneOf() {
          return (/* binding */_isOneOf
          );
        },
        /* harmony export */isString: function isString() {
          return (/* binding */_isString
          );
        },
        /* harmony export */isTemplate: function isTemplate() {
          return (/* binding */_isTemplate
          );
        },
        /* harmony export */nop: function nop() {
          return (/* binding */_nop
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./array.js */"./node_modules/lib0/array.js");
      /* harmony import */
      var _object_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./object.js */"./node_modules/lib0/object.js");
      /**
       * Common functions and function call helpers.
       *
       * @module function
       */

      /**
       * Calls all functions in `fs` with args. Only throws after all functions were called.
       *
       * @param {Array<function>} fs
       * @param {Array<any>} args
       */
      var _callAll = function _callAll(fs, args) {
        var i = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        try {
          for (; i < fs.length; i++) {
            fs[i].apply(fs, _toConsumableArray(args));
          }
        } finally {
          if (i < fs.length) {
            _callAll(fs, args, i + 1);
          }
        }
      };
      var _nop = function _nop() {};

      /**
       * @template T
       * @param {function():T} f
       * @return {T}
       */
      var _apply = function _apply(f) {
        return f();
      };

      /**
       * @template A
       *
       * @param {A} a
       * @return {A}
       */
      var _id = function _id(a) {
        return a;
      };

      /**
       * @template T
       *
       * @param {T} a
       * @param {T} b
       * @return {boolean}
       */
      var _equalityStrict = function _equalityStrict(a, b) {
        return a === b;
      };

      /**
       * @template T
       *
       * @param {Array<T>|object} a
       * @param {Array<T>|object} b
       * @return {boolean}
       */
      var _equalityFlat = function _equalityFlat(a, b) {
        return a === b || a != null && b != null && a.constructor === b.constructor && (_array_js__WEBPACK_IMPORTED_MODULE_0__.isArray(a) && _array_js__WEBPACK_IMPORTED_MODULE_0__.equalFlat(a, /** @type {Array<T>} */b) || typeof a === 'object' && _object_js__WEBPACK_IMPORTED_MODULE_1__.equalFlat(a, b));
      };

      /* c8 ignore start */

      /**
       * @param {any} a
       * @param {any} b
       * @return {boolean}
       */
      var _equalityDeep = function _equalityDeep(a, b) {
        if (a == null || b == null) {
          return _equalityStrict(a, b);
        }
        if (a.constructor !== b.constructor) {
          return false;
        }
        if (a === b) {
          return true;
        }
        switch (a.constructor) {
          case ArrayBuffer:
            a = new Uint8Array(a);
            b = new Uint8Array(b);
          // eslint-disable-next-line no-fallthrough
          case Uint8Array:
            {
              if (a.byteLength !== b.byteLength) {
                return false;
              }
              for (var i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                  return false;
                }
              }
              break;
            }
          case Set:
            {
              if (a.size !== b.size) {
                return false;
              }
              var _iterator = _createForOfIteratorHelper(a),
                _step;
              try {
                for (_iterator.s(); !(_step = _iterator.n()).done;) {
                  var value = _step.value;
                  if (!b.has(value)) {
                    return false;
                  }
                }
              } catch (err) {
                _iterator.e(err);
              } finally {
                _iterator.f();
              }
              break;
            }
          case Map:
            {
              if (a.size !== b.size) {
                return false;
              }
              var _iterator2 = _createForOfIteratorHelper(a.keys()),
                _step2;
              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var key = _step2.value;
                  if (!b.has(key) || !_equalityDeep(a.get(key), b.get(key))) {
                    return false;
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
              break;
            }
          case Object:
            if (_object_js__WEBPACK_IMPORTED_MODULE_1__.length(a) !== _object_js__WEBPACK_IMPORTED_MODULE_1__.length(b)) {
              return false;
            }
            for (var _key in a) {
              if (!_object_js__WEBPACK_IMPORTED_MODULE_1__.hasProperty(a, _key) || !_equalityDeep(a[_key], b[_key])) {
                return false;
              }
            }
            break;
          case Array:
            if (a.length !== b.length) {
              return false;
            }
            for (var _i2 = 0; _i2 < a.length; _i2++) {
              if (!_equalityDeep(a[_i2], b[_i2])) {
                return false;
              }
            }
            break;
          default:
            return false;
        }
        return true;
      };

      /**
       * @template V
       * @template {V} OPTS
       *
       * @param {V} value
       * @param {Array<OPTS>} options
       */
      // @ts-ignore
      var _isOneOf = function _isOneOf(value, options) {
        return options.includes(value);
      };
      /* c8 ignore stop */

      var _isArray2 = _array_js__WEBPACK_IMPORTED_MODULE_0__.isArray;

      /**
       * @param {any} s
       * @return {s is String}
       */
      var _isString = function _isString(s) {
        return s && s.constructor === String;
      };

      /**
       * @param {any} n
       * @return {n is Number}
       */
      var _isNumber = function _isNumber(n) {
        return n != null && n.constructor === Number;
      };

      /**
       * @template {abstract new (...args: any) => any} TYPE
       * @param {any} n
       * @param {TYPE} T
       * @return {n is InstanceType<TYPE>}
       */
      var _is = function _is(n, T) {
        return n && n.constructor === T;
      };

      /**
       * @template {abstract new (...args: any) => any} TYPE
       * @param {TYPE} T
       */
      var _isTemplate = function _isTemplate(T) {
        return (
          /**
           * @param {any} n
           * @return {n is InstanceType<TYPE>}
           **/
          function (n) {
            return n && n.constructor === T;
          }
        );
      };

      /***/
    },

    /***/"./node_modules/lib0/iterator.js":
    /*!***************************************!*\
      !*** ./node_modules/lib0/iterator.js ***!
      \***************************************/
    /***/
    function node_modulesLib0IteratorJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */createIterator: function createIterator() {
          return (/* binding */_createIterator
          );
        },
        /* harmony export */iteratorFilter: function iteratorFilter() {
          return (/* binding */_iteratorFilter
          );
        },
        /* harmony export */iteratorMap: function iteratorMap() {
          return (/* binding */_iteratorMap
          );
        },
        /* harmony export */mapIterator: function mapIterator() {
          return (/* binding */_mapIterator
          );
        }
        /* harmony export */
      });
      /**
       * Utility module to create and manipulate Iterators.
       *
       * @module iterator
       */

      /**
       * @template T,R
       * @param {Iterator<T>} iterator
       * @param {function(T):R} f
       * @return {IterableIterator<R>}
       */
      var _mapIterator = function _mapIterator(iterator, f) {
        var _ref;
        return _ref = {}, _defineProperty(_ref, Symbol.iterator, function () {
          return this;
        }), _defineProperty(_ref, "next", function next() {
          var r = iterator.next();
          return {
            value: r.done ? undefined : f(r.value),
            done: r.done
          };
        }), _ref;
      };

      /**
       * @template T
       * @param {function():IteratorResult<T>} next
       * @return {IterableIterator<T>}
       */
      var _createIterator = function _createIterator(next) {
        var _ref2;
        return _ref2 = {}, _defineProperty(_ref2, Symbol.iterator, function () {
          return this;
        }), _defineProperty(_ref2, "next", next), _ref2;
      };

      /**
       * @template T
       * @param {Iterator<T>} iterator
       * @param {function(T):boolean} filter
       */
      var _iteratorFilter = function _iteratorFilter(iterator, filter) {
        return _createIterator(function () {
          var res;
          do {
            res = iterator.next();
          } while (!res.done && !filter(res.value));
          return res;
        });
      };

      /**
       * @template T,M
       * @param {Iterator<T>} iterator
       * @param {function(T):M} fmap
       */
      var _iteratorMap = function _iteratorMap(iterator, fmap) {
        return _createIterator(function () {
          var _iterator$next = iterator.next(),
            done = _iterator$next.done,
            value = _iterator$next.value;
          return {
            done: done,
            value: done ? undefined : fmap(value)
          };
        });
      };

      /***/
    },

    /***/"./node_modules/lib0/json.js":
    /*!***********************************!*\
      !*** ./node_modules/lib0/json.js ***!
      \***********************************/
    /***/
    function node_modulesLib0JsonJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */parse: function parse() {
          return (/* binding */_parse2
          );
        },
        /* harmony export */stringify: function stringify() {
          return (/* binding */_stringify
          );
        }
        /* harmony export */
      });
      /**
       * JSON utility functions.
       *
       * @module json
       */

      /**
       * Transform JavaScript object to JSON.
       *
       * @param {any} object
       * @return {string}
       */
      var _stringify = JSON.stringify;

      /**
       * Parse JSON object.
       *
       * @param {string} json
       * @return {any}
       */
      var _parse2 = JSON.parse;

      /***/
    },

    /***/"./node_modules/lib0/logging.common.js":
    /*!*********************************************!*\
      !*** ./node_modules/lib0/logging.common.js ***!
      \*********************************************/
    /***/
    function node_modulesLib0LoggingCommonJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */BLUE: function BLUE() {
          return (/* binding */_BLUE
          );
        },
        /* harmony export */BOLD: function BOLD() {
          return (/* binding */_BOLD
          );
        },
        /* harmony export */GREEN: function GREEN() {
          return (/* binding */_GREEN
          );
        },
        /* harmony export */GREY: function GREY() {
          return (/* binding */_GREY
          );
        },
        /* harmony export */ORANGE: function ORANGE() {
          return (/* binding */_ORANGE
          );
        },
        /* harmony export */PURPLE: function PURPLE() {
          return (/* binding */_PURPLE
          );
        },
        /* harmony export */RED: function RED() {
          return (/* binding */_RED
          );
        },
        /* harmony export */UNBOLD: function UNBOLD() {
          return (/* binding */_UNBOLD
          );
        },
        /* harmony export */UNCOLOR: function UNCOLOR() {
          return (/* binding */_UNCOLOR
          );
        },
        /* harmony export */computeNoColorLoggingArgs: function computeNoColorLoggingArgs() {
          return (/* binding */_computeNoColorLoggingArgs
          );
        },
        /* harmony export */createModuleLogger: function createModuleLogger() {
          return (/* binding */_createModuleLogger
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _symbol_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./symbol.js */"./node_modules/lib0/symbol.js");
      /* harmony import */
      var _time_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./time.js */"./node_modules/lib0/time.js");
      /* harmony import */
      var _environment_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./environment.js */"./node_modules/lib0/environment.js");
      /* harmony import */
      var _function_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./function.js */"./node_modules/lib0/function.js");
      var _BOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _UNBOLD = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _BLUE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _GREY = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _GREEN = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _RED = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _PURPLE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _ORANGE = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();
      var _UNCOLOR = _symbol_js__WEBPACK_IMPORTED_MODULE_0__.create();

      /* c8 ignore start */
      /**
       * @param {Array<string|Symbol|Object|number>} args
       * @return {Array<string|object|number>}
       */
      var _computeNoColorLoggingArgs = function _computeNoColorLoggingArgs(args) {
        var strBuilder = [];
        var logArgs = [];
        // try with formatting until we find something unsupported
        var i = 0;
        for (; i < args.length; i++) {
          var arg = args[i];
          if (arg.constructor === String || arg.constructor === Number) {
            strBuilder.push(arg);
          } else if (arg.constructor === Object) {
            logArgs.push(JSON.stringify(arg));
          }
        }
        return logArgs;
      };
      /* c8 ignore stop */

      var loggingColors = [_GREEN, _PURPLE, _ORANGE, _BLUE];
      var nextColor = 0;
      var lastLoggingTime = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime();

      /* c8 ignore start */
      /**
       * @param {function(...any):void} _print
       * @param {string} moduleName
       * @return {function(...any):void}
       */
      var _createModuleLogger = function _createModuleLogger(_print, moduleName) {
        var color = loggingColors[nextColor];
        var debugRegexVar = _environment_js__WEBPACK_IMPORTED_MODULE_2__.getVariable('log');
        var doLogging = debugRegexVar !== null && (debugRegexVar === '*' || debugRegexVar === 'true' || new RegExp(debugRegexVar, 'gi').test(moduleName));
        nextColor = (nextColor + 1) % loggingColors.length;
        moduleName += ': ';
        return !doLogging ? _function_js__WEBPACK_IMPORTED_MODULE_3__.nop : function () {
          var timeNow = _time_js__WEBPACK_IMPORTED_MODULE_1__.getUnixTime();
          var timeDiff = timeNow - lastLoggingTime;
          lastLoggingTime = timeNow;
          for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
            args[_key2] = arguments[_key2];
          }
          _print.apply(void 0, [color, moduleName, _UNCOLOR].concat(_toConsumableArray(args.map(function (arg) {
            return typeof arg === 'string' || typeof arg === 'symbol' ? arg : JSON.stringify(arg);
          })), [color, ' +' + timeDiff + 'ms']));
        };
      };
      /* c8 ignore stop */

      /***/
    },

    /***/"./node_modules/lib0/logging.js":
    /*!**************************************!*\
      !*** ./node_modules/lib0/logging.js ***!
      \**************************************/
    /***/
    function node_modulesLib0LoggingJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      var _browserStyleMap2;
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */BLUE: function BLUE() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BLUE
          );
        },
        /* harmony export */BOLD: function BOLD() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD
          );
        },
        /* harmony export */GREEN: function GREEN() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREEN
          );
        },
        /* harmony export */GREY: function GREY() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREY
          );
        },
        /* harmony export */ORANGE: function ORANGE() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE
          );
        },
        /* harmony export */PURPLE: function PURPLE() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.PURPLE
          );
        },
        /* harmony export */RED: function RED() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED
          );
        },
        /* harmony export */UNBOLD: function UNBOLD() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNBOLD
          );
        },
        /* harmony export */UNCOLOR: function UNCOLOR() {
          return (/* reexport safe */_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNCOLOR
          );
        },
        /* harmony export */VConsole: function VConsole() {
          return (/* binding */_VConsole
          );
        },
        /* harmony export */createModuleLogger: function createModuleLogger() {
          return (/* binding */_createModuleLogger2
          );
        },
        /* harmony export */createVConsole: function createVConsole() {
          return (/* binding */_createVConsole
          );
        },
        /* harmony export */group: function group() {
          return (/* binding */_group
          );
        },
        /* harmony export */groupCollapsed: function groupCollapsed() {
          return (/* binding */_groupCollapsed
          );
        },
        /* harmony export */groupEnd: function groupEnd() {
          return (/* binding */_groupEnd
          );
        },
        /* harmony export */print: function print() {
          return (/* binding */_print2
          );
        },
        /* harmony export */printCanvas: function printCanvas() {
          return (/* binding */_printCanvas
          );
        },
        /* harmony export */printDom: function printDom() {
          return (/* binding */_printDom
          );
        },
        /* harmony export */printError: function printError() {
          return (/* binding */_printError
          );
        },
        /* harmony export */printImg: function printImg() {
          return (/* binding */_printImg
          );
        },
        /* harmony export */printImgBase64: function printImgBase64() {
          return (/* binding */_printImgBase
          );
        },
        /* harmony export */vconsoles: function vconsoles() {
          return (/* binding */_vconsoles
          );
        },
        /* harmony export */warn: function warn() {
          return (/* binding */_warn
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _environment_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! ./environment.js */"./node_modules/lib0/environment.js");
      /* harmony import */
      var _set_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! ./set.js */"./node_modules/lib0/set.js");
      /* harmony import */
      var _pair_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./pair.js */"./node_modules/lib0/pair.js");
      /* harmony import */
      var _dom_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! ./dom.js */"./node_modules/lib0/dom.js");
      /* harmony import */
      var _json_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! ./json.js */"./node_modules/lib0/json.js");
      /* harmony import */
      var _map_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./map.js */"./node_modules/lib0/map.js");
      /* harmony import */
      var _eventloop_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! ./eventloop.js */"./node_modules/lib0/eventloop.js");
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _logging_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./logging.common.js */"./node_modules/lib0/logging.common.js");
      /**
       * Isomorphic logging module with support for colors!
       *
       * @module logging
       */

      /**
       * @type {Object<Symbol,pair.Pair<string,string>>}
       */
      var _browserStyleMap = (_browserStyleMap2 = {}, _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'bold')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNBOLD, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('font-weight', 'normal')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BLUE, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'blue')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREEN, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'green')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.GREY, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'grey')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'red')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.PURPLE, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'purple')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'orange')), _defineProperty(_browserStyleMap2, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.UNCOLOR, _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('color', 'black')), _browserStyleMap2);

      /**
       * @param {Array<string|Symbol|Object|number>} args
       * @return {Array<string|object|number>}
       */
      /* c8 ignore start */
      var computeBrowserLoggingArgs = function computeBrowserLoggingArgs(args) {
        var strBuilder = [];
        var styles = [];
        var currentStyle = _map_js__WEBPACK_IMPORTED_MODULE_2__.create();
        /**
         * @type {Array<string|Object|number>}
         */
        var logArgs = [];
        // try with formatting until we find something unsupported
        var i = 0;
        for (; i < args.length; i++) {
          var arg = args[i];
          // @ts-ignore
          var style = _browserStyleMap[arg];
          if (style !== undefined) {
            currentStyle.set(style.left, style.right);
          } else {
            if (arg.constructor === String || arg.constructor === Number) {
              var _style = _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle);
              if (i > 0 || _style.length > 0) {
                strBuilder.push('%c' + arg);
                styles.push(_style);
              } else {
                strBuilder.push(arg);
              }
            } else {
              break;
            }
          }
        }
        if (i > 0) {
          // create logArgs with what we have so far
          logArgs = styles;
          logArgs.unshift(strBuilder.join(''));
        }
        // append the rest
        for (; i < args.length; i++) {
          var _arg = args[i];
          if (!(_arg instanceof Symbol)) {
            logArgs.push(_arg);
          }
        }
        return logArgs;
      };
      /* c8 ignore stop */

      /* c8 ignore start */
      var computeLoggingArgs = _environment_js__WEBPACK_IMPORTED_MODULE_4__.supportsColor ? computeBrowserLoggingArgs : _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.computeNoColorLoggingArgs;
      /* c8 ignore stop */

      /**
       * @param {Array<string|Symbol|Object|number>} args
       */
      var _print2 = function _print2() {
        var _console;
        for (var _len2 = arguments.length, args = new Array(_len2), _key3 = 0; _key3 < _len2; _key3++) {
          args[_key3] = arguments[_key3];
        }
        (_console = console).log.apply(_console, _toConsumableArray(computeLoggingArgs(args)));
        /* c8 ignore next */
        _vconsoles.forEach(function (vc) {
          return vc.print(args);
        });
      };

      /* c8 ignore start */
      /**
       * @param {Array<string|Symbol|Object|number>} args
       */
      var _warn = function _warn() {
        var _console2;
        for (var _len3 = arguments.length, args = new Array(_len3), _key4 = 0; _key4 < _len3; _key4++) {
          args[_key4] = arguments[_key4];
        }
        (_console2 = console).warn.apply(_console2, _toConsumableArray(computeLoggingArgs(args)));
        args.unshift(_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.ORANGE);
        _vconsoles.forEach(function (vc) {
          return vc.print(args);
        });
      };
      /* c8 ignore stop */

      /**
       * @param {Error} err
       */
      /* c8 ignore start */
      var _printError = function _printError(err) {
        console.error(err);
        _vconsoles.forEach(function (vc) {
          return vc.printError(err);
        });
      };
      /* c8 ignore stop */

      /**
       * @param {string} url image location
       * @param {number} height height of the image in pixel
       */
      /* c8 ignore start */
      var _printImg = function _printImg(url, height) {
        if (_environment_js__WEBPACK_IMPORTED_MODULE_4__.isBrowser) {
          console.log('%c                      ', "font-size: ".concat(height, "px; background-size: contain; background-repeat: no-repeat; background-image: url(").concat(url, ")"));
          // console.log('%c                ', `font-size: ${height}x; background: url(${url}) no-repeat;`)
        }

        _vconsoles.forEach(function (vc) {
          return vc.printImg(url, height);
        });
      };
      /* c8 ignore stop */

      /**
       * @param {string} base64
       * @param {number} height
       */
      /* c8 ignore next 2 */
      var _printImgBase = function _printImgBase(base64, height) {
        return _printImg("data:image/gif;base64,".concat(base64), height);
      };

      /**
       * @param {Array<string|Symbol|Object|number>} args
       */
      var _group = function _group() {
        var _console3;
        for (var _len4 = arguments.length, args = new Array(_len4), _key5 = 0; _key5 < _len4; _key5++) {
          args[_key5] = arguments[_key5];
        }
        (_console3 = console).group.apply(_console3, _toConsumableArray(computeLoggingArgs(args)));
        /* c8 ignore next */
        _vconsoles.forEach(function (vc) {
          return vc.group(args);
        });
      };

      /**
       * @param {Array<string|Symbol|Object|number>} args
       */
      var _groupCollapsed = function _groupCollapsed() {
        var _console4;
        for (var _len5 = arguments.length, args = new Array(_len5), _key6 = 0; _key6 < _len5; _key6++) {
          args[_key6] = arguments[_key6];
        }
        (_console4 = console).groupCollapsed.apply(_console4, _toConsumableArray(computeLoggingArgs(args)));
        /* c8 ignore next */
        _vconsoles.forEach(function (vc) {
          return vc.groupCollapsed(args);
        });
      };
      var _groupEnd = function _groupEnd() {
        console.groupEnd();
        /* c8 ignore next */
        _vconsoles.forEach(function (vc) {
          return vc.groupEnd();
        });
      };

      /**
       * @param {function():Node} createNode
       */
      /* c8 ignore next 2 */
      var _printDom = function _printDom(createNode) {
        return _vconsoles.forEach(function (vc) {
          return vc.printDom(createNode());
        });
      };

      /**
       * @param {HTMLCanvasElement} canvas
       * @param {number} height
       */
      /* c8 ignore next 2 */
      var _printCanvas = function _printCanvas(canvas, height) {
        return _printImg(canvas.toDataURL(), height);
      };
      var _vconsoles = _set_js__WEBPACK_IMPORTED_MODULE_5__.create();

      /**
       * @param {Array<string|Symbol|Object|number>} args
       * @return {Array<Element>}
       */
      /* c8 ignore start */
      var _computeLineSpans = function _computeLineSpans(args) {
        var spans = [];
        var currentStyle = new Map();
        // try with formatting until we find something unsupported
        var i = 0;
        for (; i < args.length; i++) {
          var arg = args[i];
          // @ts-ignore
          var style = _browserStyleMap[arg];
          if (style !== undefined) {
            currentStyle.set(style.left, style.right);
          } else {
            if (arg.constructor === String || arg.constructor === Number) {
              // @ts-ignore
              var span = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', _dom_js__WEBPACK_IMPORTED_MODULE_3__.mapToStyleString(currentStyle))], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text(arg.toString())]);
              if (span.innerHTML === '') {
                span.innerHTML = '&nbsp;';
              }
              spans.push(span);
            } else {
              break;
            }
          }
        }
        // append the rest
        for (; i < args.length; i++) {
          var content = args[i];
          if (!(content instanceof Symbol)) {
            if (content.constructor !== String && content.constructor !== Number) {
              content = ' ' + _json_js__WEBPACK_IMPORTED_MODULE_6__.stringify(content) + ' ';
            }
            spans.push(_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text( /** @type {string} */content)]));
          }
        }
        return spans;
      };
      /* c8 ignore stop */

      var lineStyle = 'font-family:monospace;border-bottom:1px solid #e2e2e2;padding:2px;';

      /* c8 ignore start */
      var _VConsole = /*#__PURE__*/function () {
        /**
         * @param {Element} dom
         */
        function _VConsole(dom) {
          _classCallCheck(this, _VConsole);
          this.dom = dom;
          /**
           * @type {Element}
           */
          this.ccontainer = this.dom;
          this.depth = 0;
          _vconsoles.add(this);
        }

        /**
         * @param {Array<string|Symbol|Object|number>} args
         * @param {boolean} collapsed
         */
        _createClass(_VConsole, [{
          key: "group",
          value: function group(args) {
            var _this10 = this;
            var collapsed = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              var triangleDown = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:120%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')]);
              var triangleRight = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('span', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', !collapsed), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', 'color:grey;font-size:125%;')], [_dom_js__WEBPACK_IMPORTED_MODULE_3__.text('')]);
              var content = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', "".concat(lineStyle, ";padding-left:").concat(_this10.depth * 10, "px"))], [triangleDown, triangleRight, _dom_js__WEBPACK_IMPORTED_MODULE_3__.text(' ')].concat(_computeLineSpans(args)));
              var nextContainer = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('hidden', collapsed)]);
              var nextLine = _dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [], [content, nextContainer]);
              _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(_this10.ccontainer, [nextLine]);
              _this10.ccontainer = nextContainer;
              _this10.depth++;
              // when header is clicked, collapse/uncollapse container
              _dom_js__WEBPACK_IMPORTED_MODULE_3__.addEventListener(content, 'click', function (_event) {
                nextContainer.toggleAttribute('hidden');
                triangleDown.toggleAttribute('hidden');
                triangleRight.toggleAttribute('hidden');
              });
            });
          }

          /**
           * @param {Array<string|Symbol|Object|number>} args
           */
        }, {
          key: "groupCollapsed",
          value: function groupCollapsed(args) {
            this.group(args, true);
          }
        }, {
          key: "groupEnd",
          value: function groupEnd() {
            var _this11 = this;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              if (_this11.depth > 0) {
                _this11.depth--;
                // @ts-ignore
                _this11.ccontainer = _this11.ccontainer.parentElement.parentElement;
              }
            });
          }

          /**
           * @param {Array<string|Symbol|Object|number>} args
           */
        }, {
          key: "print",
          value: function print(args) {
            var _this12 = this;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(_this12.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('div', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('style', "".concat(lineStyle, ";padding-left:").concat(_this12.depth * 10, "px"))], _computeLineSpans(args))]);
            });
          }

          /**
           * @param {Error} err
           */
        }, {
          key: "printError",
          value: function printError(err) {
            this.print([_logging_common_js__WEBPACK_IMPORTED_MODULE_0__.RED, _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.BOLD, err.toString()]);
          }

          /**
           * @param {string} url
           * @param {number} height
           */
        }, {
          key: "printImg",
          value: function printImg(url, height) {
            var _this13 = this;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(_this13.ccontainer, [_dom_js__WEBPACK_IMPORTED_MODULE_3__.element('img', [_pair_js__WEBPACK_IMPORTED_MODULE_1__.create('src', url), _pair_js__WEBPACK_IMPORTED_MODULE_1__.create('height', "".concat(_math_js__WEBPACK_IMPORTED_MODULE_8__.round(height * 1.5), "px"))])]);
            });
          }

          /**
           * @param {Node} node
           */
        }, {
          key: "printDom",
          value: function printDom(node) {
            var _this14 = this;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              _dom_js__WEBPACK_IMPORTED_MODULE_3__.append(_this14.ccontainer, [node]);
            });
          }
        }, {
          key: "destroy",
          value: function destroy() {
            var _this15 = this;
            _eventloop_js__WEBPACK_IMPORTED_MODULE_7__.enqueue(function () {
              _vconsoles.delete(_this15);
            });
          }
        }]);
        return _VConsole;
      }();
      /* c8 ignore stop */
      /**
       * @param {Element} dom
       */
      /* c8 ignore next */
      var _createVConsole = function _createVConsole(dom) {
        return new _VConsole(dom);
      };

      /**
       * @param {string} moduleName
       * @return {function(...any):void}
       */
      var _createModuleLogger2 = function _createModuleLogger2(moduleName) {
        return _logging_common_js__WEBPACK_IMPORTED_MODULE_0__.createModuleLogger(_print2, moduleName);
      };

      /***/
    },

    /***/"./node_modules/lib0/map.js":
    /*!**********************************!*\
      !*** ./node_modules/lib0/map.js ***!
      \**********************************/
    /***/
    function node_modulesLib0MapJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */all: function all() {
          return (/* binding */_all
          );
        },
        /* harmony export */any: function any() {
          return (/* binding */_any
          );
        },
        /* harmony export */copy: function copy() {
          return (/* binding */_copy2
          );
        },
        /* harmony export */create: function create() {
          return (/* binding */_create3
          );
        },
        /* harmony export */map: function map() {
          return (/* binding */_map2
          );
        },
        /* harmony export */setIfUndefined: function setIfUndefined() {
          return (/* binding */_setIfUndefined
          );
        }
        /* harmony export */
      });
      /**
       * Utility module to work with key-value stores.
       *
       * @module map
       */

      /**
       * Creates a new Map instance.
       *
       * @function
       * @return {Map<any, any>}
       *
       * @function
       */
      var _create3 = function _create3() {
        return new Map();
      };

      /**
       * Copy a Map object into a fresh Map object.
       *
       * @function
       * @template X,Y
       * @param {Map<X,Y>} m
       * @return {Map<X,Y>}
       */
      var _copy2 = function _copy2(m) {
        var r = _create3();
        m.forEach(function (v, k) {
          r.set(k, v);
        });
        return r;
      };

      /**
       * Get map property. Create T if property is undefined and set T on map.
       *
       * ```js
       * const listeners = map.setIfUndefined(events, 'eventName', set.create)
       * listeners.add(listener)
       * ```
       *
       * @function
       * @template V,K
       * @template {Map<K,V>} MAP
       * @param {MAP} map
       * @param {K} key
       * @param {function():V} createT
       * @return {V}
       */
      var _setIfUndefined = function _setIfUndefined(map, key, createT) {
        var set = map.get(key);
        if (set === undefined) {
          map.set(key, set = createT());
        }
        return set;
      };

      /**
       * Creates an Array and populates it with the content of all key-value pairs using the `f(value, key)` function.
       *
       * @function
       * @template K
       * @template V
       * @template R
       * @param {Map<K,V>} m
       * @param {function(V,K):R} f
       * @return {Array<R>}
       */
      var _map2 = function _map2(m, f) {
        var res = [];
        var _iterator3 = _createForOfIteratorHelper(m),
          _step3;
        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var _step3$value = _slicedToArray(_step3.value, 2),
              key = _step3$value[0],
              value = _step3$value[1];
            res.push(f(value, key));
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
        return res;
      };

      /**
       * Tests whether any key-value pairs pass the test implemented by `f(value, key)`.
       *
       * @todo should rename to some - similarly to Array.some
       *
       * @function
       * @template K
       * @template V
       * @param {Map<K,V>} m
       * @param {function(V,K):boolean} f
       * @return {boolean}
       */
      var _any = function _any(m, f) {
        var _iterator4 = _createForOfIteratorHelper(m),
          _step4;
        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _step4$value = _slicedToArray(_step4.value, 2),
              key = _step4$value[0],
              value = _step4$value[1];
            if (f(value, key)) {
              return true;
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
        return false;
      };

      /**
       * Tests whether all key-value pairs pass the test implemented by `f(value, key)`.
       *
       * @function
       * @template K
       * @template V
       * @param {Map<K,V>} m
       * @param {function(V,K):boolean} f
       * @return {boolean}
       */
      var _all = function _all(m, f) {
        var _iterator5 = _createForOfIteratorHelper(m),
          _step5;
        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 2),
              key = _step5$value[0],
              value = _step5$value[1];
            if (!f(value, key)) {
              return false;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
        return true;
      };

      /***/
    },

    /***/"./node_modules/lib0/math.js":
    /*!***********************************!*\
      !*** ./node_modules/lib0/math.js ***!
      \***********************************/
    /***/
    function node_modulesLib0MathJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */abs: function abs() {
          return (/* binding */_abs
          );
        },
        /* harmony export */add: function add() {
          return (/* binding */_add
          );
        },
        /* harmony export */ceil: function ceil() {
          return (/* binding */_ceil
          );
        },
        /* harmony export */exp10: function exp10() {
          return (/* binding */_exp
          );
        },
        /* harmony export */floor: function floor() {
          return (/* binding */_floor
          );
        },
        /* harmony export */imul: function imul() {
          return (/* binding */_imul
          );
        },
        /* harmony export */isNaN: function isNaN() {
          return (/* binding */_isNaN
          );
        },
        /* harmony export */isNegativeZero: function isNegativeZero() {
          return (/* binding */_isNegativeZero
          );
        },
        /* harmony export */log: function log() {
          return (/* binding */_log
          );
        },
        /* harmony export */log10: function log10() {
          return (/* binding */_log2
          );
        },
        /* harmony export */log2: function log2() {
          return (/* binding */_log3
          );
        },
        /* harmony export */max: function max() {
          return (/* binding */_max
          );
        },
        /* harmony export */min: function min() {
          return (/* binding */_min
          );
        },
        /* harmony export */pow: function pow() {
          return (/* binding */_pow
          );
        },
        /* harmony export */round: function round() {
          return (/* binding */_round
          );
        },
        /* harmony export */sign: function sign() {
          return (/* binding */_sign
          );
        },
        /* harmony export */sqrt: function sqrt() {
          return (/* binding */_sqrt
          );
        }
        /* harmony export */
      });
      /**
       * Common Math expressions.
       *
       * @module math
       */

      var _floor = Math.floor;
      var _ceil = Math.ceil;
      var _abs = Math.abs;
      var _imul = Math.imul;
      var _round = Math.round;
      var _log2 = Math.log10;
      var _log3 = Math.log2;
      var _log = Math.log;
      var _sqrt = Math.sqrt;

      /**
       * @function
       * @param {number} a
       * @param {number} b
       * @return {number} The sum of a and b
       */
      var _add = function _add(a, b) {
        return a + b;
      };

      /**
       * @function
       * @param {number} a
       * @param {number} b
       * @return {number} The smaller element of a and b
       */
      var _min = function _min(a, b) {
        return a < b ? a : b;
      };

      /**
       * @function
       * @param {number} a
       * @param {number} b
       * @return {number} The bigger element of a and b
       */
      var _max = function _max(a, b) {
        return a > b ? a : b;
      };
      var _isNaN = Number.isNaN;
      var _pow = Math.pow;
      /**
       * Base 10 exponential function. Returns the value of 10 raised to the power of pow.
       *
       * @param {number} exp
       * @return {number}
       */
      var _exp = function _exp(exp) {
        return Math.pow(10, exp);
      };
      var _sign = Math.sign;

      /**
       * @param {number} n
       * @return {boolean} Wether n is negative. This function also differentiates between -0 and +0
       */
      var _isNegativeZero = function _isNegativeZero(n) {
        return n !== 0 ? n < 0 : 1 / n < 0;
      };

      /***/
    },

    /***/"./node_modules/lib0/metric.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/metric.js ***!
      \*************************************/
    /***/
    function node_modulesLib0MetricJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */atto: function atto() {
          return (/* binding */_atto
          );
        },
        /* harmony export */centi: function centi() {
          return (/* binding */_centi
          );
        },
        /* harmony export */deca: function deca() {
          return (/* binding */_deca
          );
        },
        /* harmony export */deci: function deci() {
          return (/* binding */_deci
          );
        },
        /* harmony export */exa: function exa() {
          return (/* binding */_exa
          );
        },
        /* harmony export */femto: function femto() {
          return (/* binding */_femto
          );
        },
        /* harmony export */giga: function giga() {
          return (/* binding */_giga
          );
        },
        /* harmony export */hecto: function hecto() {
          return (/* binding */_hecto
          );
        },
        /* harmony export */kilo: function kilo() {
          return (/* binding */_kilo
          );
        },
        /* harmony export */mega: function mega() {
          return (/* binding */_mega
          );
        },
        /* harmony export */micro: function micro() {
          return (/* binding */_micro
          );
        },
        /* harmony export */milli: function milli() {
          return (/* binding */_milli
          );
        },
        /* harmony export */nano: function nano() {
          return (/* binding */_nano
          );
        },
        /* harmony export */peta: function peta() {
          return (/* binding */_peta
          );
        },
        /* harmony export */pico: function pico() {
          return (/* binding */_pico
          );
        },
        /* harmony export */prefix: function prefix() {
          return (/* binding */_prefix
          );
        },
        /* harmony export */tera: function tera() {
          return (/* binding */_tera
          );
        },
        /* harmony export */yocto: function yocto() {
          return (/* binding */_yocto
          );
        },
        /* harmony export */yotta: function yotta() {
          return (/* binding */_yotta
          );
        },
        /* harmony export */zepto: function zepto() {
          return (/* binding */_zepto
          );
        },
        /* harmony export */zetta: function zetta() {
          return (/* binding */_zetta
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /**
       * Utility module to convert metric values.
       *
       * @module metric
       */

      var _yotta = 1e24;
      var _zetta = 1e21;
      var _exa = 1e18;
      var _peta = 1e15;
      var _tera = 1e12;
      var _giga = 1e9;
      var _mega = 1e6;
      var _kilo = 1e3;
      var _hecto = 1e2;
      var _deca = 10;
      var _deci = 0.1;
      var _centi = 0.01;
      var _milli = 1e-3;
      var _micro = 1e-6;
      var _nano = 1e-9;
      var _pico = 1e-12;
      var _femto = 1e-15;
      var _atto = 1e-18;
      var _zepto = 1e-21;
      var _yocto = 1e-24;
      var prefixUp = ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'];
      var prefixDown = ['', 'm', '', 'n', 'p', 'f', 'a', 'z', 'y'];

      /**
       * Calculate the metric prefix for a number. Assumes E.g. `prefix(1000) = { n: 1, prefix: 'k' }`
       *
       * @param {number} n
       * @param {number} [baseMultiplier] Multiplier of the base (10^(3*baseMultiplier)). E.g. `convert(time, -3)` if time is already in milli seconds
       * @return {{n:number,prefix:string}}
       */
      var _prefix = function _prefix(n) {
        var baseMultiplier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        var nPow = n === 0 ? 0 : _math_js__WEBPACK_IMPORTED_MODULE_0__.log10(n);
        var mult = 0;
        while (nPow < mult * 3 && baseMultiplier > -8) {
          baseMultiplier--;
          mult--;
        }
        while (nPow >= 3 + mult * 3 && baseMultiplier < 8) {
          baseMultiplier++;
          mult++;
        }
        var prefix = baseMultiplier < 0 ? prefixDown[-baseMultiplier] : prefixUp[baseMultiplier];
        return {
          n: _math_js__WEBPACK_IMPORTED_MODULE_0__.round((mult > 0 ? n / _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * 3) : n * _math_js__WEBPACK_IMPORTED_MODULE_0__.exp10(mult * -3)) * 1e12) / 1e12,
          prefix: prefix
        };
      };

      /***/
    },

    /***/"./node_modules/lib0/number.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/number.js ***!
      \*************************************/
    /***/
    function node_modulesLib0NumberJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */HIGHEST_INT32: function HIGHEST_INT32() {
          return (/* binding */_HIGHEST_INT
          );
        },
        /* harmony export */HIGHEST_UINT32: function HIGHEST_UINT32() {
          return (/* binding */_HIGHEST_UINT
          );
        },
        /* harmony export */LOWEST_INT32: function LOWEST_INT32() {
          return (/* binding */_LOWEST_INT
          );
        },
        /* harmony export */MAX_SAFE_INTEGER: function MAX_SAFE_INTEGER() {
          return (/* binding */_MAX_SAFE_INTEGER
          );
        },
        /* harmony export */MIN_SAFE_INTEGER: function MIN_SAFE_INTEGER() {
          return (/* binding */_MIN_SAFE_INTEGER
          );
        },
        /* harmony export */countBits: function countBits() {
          return (/* binding */_countBits
          );
        },
        /* harmony export */isInteger: function isInteger() {
          return (/* binding */_isInteger
          );
        },
        /* harmony export */isNaN: function isNaN() {
          return (/* binding */_isNaN2
          );
        },
        /* harmony export */parseInt: function (_parseInt) {
          function parseInt() {
            return _parseInt.apply(this, arguments);
          }
          parseInt.toString = function () {
            return _parseInt.toString();
          };
          return parseInt;
        }(function () {
          return (/* binding */parseInt
          );
        })
        /* harmony export */
      });
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _binary_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./binary.js */"./node_modules/lib0/binary.js");
      /**
       * Utility helpers for working with numbers.
       *
       * @module number
       */

      var _MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER;
      var _MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER;
      var _LOWEST_INT = 1 << 31;
      var _HIGHEST_INT = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS31;
      var _HIGHEST_UINT = _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS32;

      /* c8 ignore next */
      var _isInteger = Number.isInteger || function (num) {
        return typeof num === 'number' && isFinite(num) && _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(num) === num;
      };
      var _isNaN2 = Number.isNaN;
      var parseInt = Number.parseInt;

      /**
       * Count the number of "1" bits in an unsigned 32bit number.
       *
       * Super fun bitcount algorithm by Brian Kernighan.
       *
       * @param {number} n
       */
      var _countBits = function _countBits(n) {
        n &= _binary_js__WEBPACK_IMPORTED_MODULE_0__.BITS32;
        var count = 0;
        while (n) {
          n &= n - 1;
          count++;
        }
        return count;
      };

      /***/
    },

    /***/"./node_modules/lib0/object.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/object.js ***!
      \*************************************/
    /***/
    function node_modulesLib0ObjectJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */assign: function assign() {
          return (/* binding */_assign
          );
        },
        /* harmony export */create: function create() {
          return (/* binding */_create4
          );
        },
        /* harmony export */equalFlat: function equalFlat() {
          return (/* binding */_equalFlat2
          );
        },
        /* harmony export */every: function every() {
          return (/* binding */_every2
          );
        },
        /* harmony export */forEach: function forEach() {
          return (/* binding */_forEach
          );
        },
        /* harmony export */hasProperty: function hasProperty() {
          return (/* binding */_hasProperty
          );
        },
        /* harmony export */isEmpty: function isEmpty() {
          return (/* binding */_isEmpty
          );
        },
        /* harmony export */keys: function keys() {
          return (/* binding */_keys
          );
        },
        /* harmony export */length: function length() {
          return (/* binding */_length2
          );
        },
        /* harmony export */map: function map() {
          return (/* binding */_map3
          );
        },
        /* harmony export */some: function some() {
          return (/* binding */_some2
          );
        }
        /* harmony export */
      });
      /**
       * Utility functions for working with EcmaScript objects.
       *
       * @module object
       */

      /**
       * @return {Object<string,any>} obj
       */
      var _create4 = function _create4() {
        return Object.create(null);
      };

      /**
       * Object.assign
       */
      var _assign = Object.assign;

      /**
       * @param {Object<string,any>} obj
       */
      var _keys = Object.keys;

      /**
       * @template V
       * @param {{[k:string]:V}} obj
       * @param {function(V,string):any} f
       */
      var _forEach = function _forEach(obj, f) {
        for (var key in obj) {
          f(obj[key], key);
        }
      };

      /**
       * @todo implement mapToArray & map
       *
       * @template R
       * @param {Object<string,any>} obj
       * @param {function(any,string):R} f
       * @return {Array<R>}
       */
      var _map3 = function _map3(obj, f) {
        var results = [];
        for (var key in obj) {
          results.push(f(obj[key], key));
        }
        return results;
      };

      /**
       * @param {Object<string,any>} obj
       * @return {number}
       */
      var _length2 = function _length2(obj) {
        return _keys(obj).length;
      };

      /**
       * @param {Object<string,any>} obj
       * @param {function(any,string):boolean} f
       * @return {boolean}
       */
      var _some2 = function _some2(obj, f) {
        for (var key in obj) {
          if (f(obj[key], key)) {
            return true;
          }
        }
        return false;
      };

      /**
       * @param {Object|undefined} obj
       */
      var _isEmpty = function _isEmpty(obj) {
        // eslint-disable-next-line
        for (var _k in obj) {
          return false;
        }
        return true;
      };

      /**
       * @param {Object<string,any>} obj
       * @param {function(any,string):boolean} f
       * @return {boolean}
       */
      var _every2 = function _every2(obj, f) {
        for (var key in obj) {
          if (!f(obj[key], key)) {
            return false;
          }
        }
        return true;
      };

      /**
       * Calls `Object.prototype.hasOwnProperty`.
       *
       * @param {any} obj
       * @param {string|symbol} key
       * @return {boolean}
       */
      var _hasProperty = function _hasProperty(obj, key) {
        return Object.prototype.hasOwnProperty.call(obj, key);
      };

      /**
       * @param {Object<string,any>} a
       * @param {Object<string,any>} b
       * @return {boolean}
       */
      var _equalFlat2 = function _equalFlat2(a, b) {
        return a === b || _length2(a) === _length2(b) && _every2(a, function (val, key) {
          return (val !== undefined || _hasProperty(b, key)) && b[key] === val;
        });
      };

      /***/
    },

    /***/"./node_modules/lib0/observable.js":
    /*!*****************************************!*\
      !*** ./node_modules/lib0/observable.js ***!
      \*****************************************/
    /***/
    function node_modulesLib0ObservableJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Observable: function Observable() {
          return (/* binding */_Observable
          );
        },
        /* harmony export */ObservableV2: function ObservableV2() {
          return (/* binding */_ObservableV
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _map_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./map.js */"./node_modules/lib0/map.js");
      /* harmony import */
      var _set_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./set.js */"./node_modules/lib0/set.js");
      /* harmony import */
      var _array_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./array.js */"./node_modules/lib0/array.js");
      /**
       * Observable class prototype.
       *
       * @module observable
       */

      /**
       * Handles named events.
       * @experimental
       *
       * This is basically a (better typed) duplicate of Observable, which will replace Observable in the
       * next release.
       *
       * @template {{[key: string]: function(...any):void}} EVENTS
       */
      var _ObservableV = /*#__PURE__*/function () {
        function _ObservableV() {
          _classCallCheck(this, _ObservableV);
          /**
           * Some desc.
           * @type {Map<string, Set<any>>}
           */
          this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
        }

        /**
         * @template {string} NAME
         * @param {NAME} name
         * @param {EVENTS[NAME]} f
         */
        _createClass(_ObservableV, [{
          key: "on",
          value: function on(name, f) {
            _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, /** @type {string} */name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f);
            return f;
          }

          /**
           * @template {string} NAME
           * @param {NAME} name
           * @param {EVENTS[NAME]} f
           */
        }, {
          key: "once",
          value: function once(name, f) {
            var _this16 = this;
            /**
             * @param  {...any} args
             */
            var _f = function _f() {
              _this16.off(name, /** @type {any} */_f);
              f.apply(void 0, arguments);
            };
            this.on(name, /** @type {any} */_f);
          }

          /**
           * @template {string} NAME
           * @param {NAME} name
           * @param {EVENTS[NAME]} f
           */
        }, {
          key: "off",
          value: function off(name, f) {
            var observers = this._observers.get(name);
            if (observers !== undefined) {
              observers.delete(f);
              if (observers.size === 0) {
                this._observers.delete(name);
              }
            }
          }

          /**
           * Emit a named event. All registered event listeners that listen to the
           * specified name will receive the event.
           *
           * @todo This should catch exceptions
           *
           * @template {string} NAME
           * @param {NAME} name The event name.
           * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
           */
        }, {
          key: "emit",
          value: function emit(name, args) {
            // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
            return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(function (f) {
              return f.apply(void 0, _toConsumableArray(args));
            });
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
          }
        }]);
        return _ObservableV;
      }();
      /* c8 ignore start */
      /**
       * Handles named events.
       *
       * @deprecated
       * @template N
       */
      var _Observable = /*#__PURE__*/function () {
        function _Observable() {
          _classCallCheck(this, _Observable);
          /**
           * Some desc.
           * @type {Map<N, any>}
           */
          this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
        }

        /**
         * @param {N} name
         * @param {function} f
         */
        _createClass(_Observable, [{
          key: "on",
          value: function on(name, f) {
            _map_js__WEBPACK_IMPORTED_MODULE_0__.setIfUndefined(this._observers, name, _set_js__WEBPACK_IMPORTED_MODULE_1__.create).add(f);
          }

          /**
           * @param {N} name
           * @param {function} f
           */
        }, {
          key: "once",
          value: function once(name, f) {
            var _this17 = this;
            /**
             * @param  {...any} args
             */
            var _f = function _f() {
              _this17.off(name, _f);
              f.apply(void 0, arguments);
            };
            this.on(name, _f);
          }

          /**
           * @param {N} name
           * @param {function} f
           */
        }, {
          key: "off",
          value: function off(name, f) {
            var observers = this._observers.get(name);
            if (observers !== undefined) {
              observers.delete(f);
              if (observers.size === 0) {
                this._observers.delete(name);
              }
            }
          }

          /**
           * Emit a named event. All registered event listeners that listen to the
           * specified name will receive the event.
           *
           * @todo This should catch exceptions
           *
           * @param {N} name The event name.
           * @param {Array<any>} args The arguments that are applied to the event listener.
           */
        }, {
          key: "emit",
          value: function emit(name, args) {
            // copy all listeners to an array first to make sure that no event is emitted to listeners that are subscribed while the event handler is called.
            return _array_js__WEBPACK_IMPORTED_MODULE_2__.from((this._observers.get(name) || _map_js__WEBPACK_IMPORTED_MODULE_0__.create()).values()).forEach(function (f) {
              return f.apply(void 0, _toConsumableArray(args));
            });
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this._observers = _map_js__WEBPACK_IMPORTED_MODULE_0__.create();
          }
        }]);
        return _Observable;
      }();
      /* c8 ignore end */
      /***/
    },
    /***/"./node_modules/lib0/pair.js":
    /*!***********************************!*\
      !*** ./node_modules/lib0/pair.js ***!
      \***********************************/
    /***/
    function node_modulesLib0PairJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */Pair: function Pair() {
          return (/* binding */_Pair
          );
        },
        /* harmony export */create: function create() {
          return (/* binding */_create5
          );
        },
        /* harmony export */createReversed: function createReversed() {
          return (/* binding */_createReversed
          );
        },
        /* harmony export */forEach: function forEach() {
          return (/* binding */_forEach2
          );
        },
        /* harmony export */map: function map() {
          return (/* binding */_map4
          );
        }
        /* harmony export */
      });
      /**
       * Working with value pairs.
       *
       * @module pair
       */

      /**
       * @template L,R
       */
      var _Pair = /*#__PURE__*/_createClass(
      /**
       * @param {L} left
       * @param {R} right
       */
      function _Pair(left, right) {
        _classCallCheck(this, _Pair);
        this.left = left;
        this.right = right;
      });
      /**
       * @template L,R
       * @param {L} left
       * @param {R} right
       * @return {Pair<L,R>}
       */
      var _create5 = function _create5(left, right) {
        return new _Pair(left, right);
      };

      /**
       * @template L,R
       * @param {R} right
       * @param {L} left
       * @return {Pair<L,R>}
       */
      var _createReversed = function _createReversed(right, left) {
        return new _Pair(left, right);
      };

      /**
       * @template L,R
       * @param {Array<Pair<L,R>>} arr
       * @param {function(L, R):any} f
       */
      var _forEach2 = function _forEach2(arr, f) {
        return arr.forEach(function (p) {
          return f(p.left, p.right);
        });
      };

      /**
       * @template L,R,X
       * @param {Array<Pair<L,R>>} arr
       * @param {function(L, R):X} f
       * @return {Array<X>}
       */
      var _map4 = function _map4(arr, f) {
        return arr.map(function (p) {
          return f(p.left, p.right);
        });
      };

      /***/
    },

    /***/"./node_modules/lib0/promise.js":
    /*!**************************************!*\
      !*** ./node_modules/lib0/promise.js ***!
      \**************************************/
    /***/
    function node_modulesLib0PromiseJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */all: function all() {
          return (/* binding */_all2
          );
        },
        /* harmony export */create: function create() {
          return (/* binding */_create6
          );
        },
        /* harmony export */createEmpty: function createEmpty() {
          return (/* binding */_createEmpty
          );
        },
        /* harmony export */isPromise: function isPromise() {
          return (/* binding */_isPromise
          );
        },
        /* harmony export */reject: function reject() {
          return (/* binding */_reject
          );
        },
        /* harmony export */resolve: function resolve() {
          return (/* binding */_resolve
          );
        },
        /* harmony export */resolveWith: function resolveWith() {
          return (/* binding */_resolveWith
          );
        },
        /* harmony export */until: function until() {
          return (/* binding */_until
          );
        },
        /* harmony export */wait: function wait() {
          return (/* binding */_wait
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _time_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./time.js */"./node_modules/lib0/time.js");
      /**
       * Utility helpers to work with promises.
       *
       * @module promise
       */

      /**
       * @template T
       * @callback PromiseResolve
       * @param {T|PromiseLike<T>} [result]
       */

      /**
       * @template T
       * @param {function(PromiseResolve<T>,function(Error):void):any} f
       * @return {Promise<T>}
       */
      var _create6 = function _create6(f) {
        return (/** @type {Promise<T>} */new Promise(f)
        );
      };

      /**
       * @param {function(function():void,function(Error):void):void} f
       * @return {Promise<void>}
       */
      var _createEmpty = function _createEmpty(f) {
        return new Promise(f);
      };

      /**
       * `Promise.all` wait for all promises in the array to resolve and return the result
       * @template {unknown[] | []} PS
       *
       * @param {PS} ps
       * @return {Promise<{ -readonly [P in keyof PS]: Awaited<PS[P]> }>}
       */
      var _all2 = Promise.all.bind(Promise);

      /**
       * @param {Error} [reason]
       * @return {Promise<never>}
       */
      var _reject = function _reject(reason) {
        return Promise.reject(reason);
      };

      /**
       * @template T
       * @param {T|void} res
       * @return {Promise<T|void>}
       */
      var _resolve = function _resolve(res) {
        return Promise.resolve(res);
      };

      /**
       * @template T
       * @param {T} res
       * @return {Promise<T>}
       */
      var _resolveWith = function _resolveWith(res) {
        return Promise.resolve(res);
      };

      /**
       * @todo Next version, reorder parameters: check, [timeout, [intervalResolution]]
       *
       * @param {number} timeout
       * @param {function():boolean} check
       * @param {number} [intervalResolution]
       * @return {Promise<void>}
       */
      var _until = function _until(timeout, check) {
        var intervalResolution = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10;
        return _create6(function (resolve, reject) {
          var startTime = _time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime();
          var hasTimeout = timeout > 0;
          var untilInterval = function untilInterval() {
            if (check()) {
              clearInterval(intervalHandle);
              resolve();
            } else if (hasTimeout) {
              /* c8 ignore else */
              if (_time_js__WEBPACK_IMPORTED_MODULE_0__.getUnixTime() - startTime > timeout) {
                clearInterval(intervalHandle);
                reject(new Error('Timeout'));
              }
            }
          };
          var intervalHandle = setInterval(untilInterval, intervalResolution);
        });
      };

      /**
       * @param {number} timeout
       * @return {Promise<undefined>}
       */
      var _wait = function _wait(timeout) {
        return _create6(function (resolve, reject) {
          return setTimeout(resolve, timeout);
        });
      };

      /**
       * Checks if an object is a promise using ducktyping.
       *
       * Promises are often polyfilled, so it makes sense to add some additional guarantees if the user of this
       * library has some insane environment where global Promise objects are overwritten.
       *
       * @param {any} p
       * @return {boolean}
       */
      var _isPromise = function _isPromise(p) {
        return p instanceof Promise || p && p.then && p.catch && p.finally;
      };

      /***/
    },

    /***/"./node_modules/lib0/random.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/random.js ***!
      \*************************************/
    /***/
    function node_modulesLib0RandomJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */oneOf: function oneOf() {
          return (/* binding */_oneOf
          );
        },
        /* harmony export */rand: function rand() {
          return (/* binding */_rand
          );
        },
        /* harmony export */uint32: function uint32() {
          return (/* binding */_uint
          );
        },
        /* harmony export */uint53: function uint53() {
          return (/* binding */_uint2
          );
        },
        /* harmony export */uuidv4: function uuidv4() {
          return (/* binding */_uuidv
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /* harmony import */
      var _binary_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./binary.js */"./node_modules/lib0/binary.js");
      /* harmony import */
      var lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! lib0/webcrypto */"./node_modules/lib0/webcrypto.js");
      /**
       * Isomorphic module for true random numbers / buffers / uuids.
       *
       * Attention: falls back to Math.random if the browser does not support crypto.
       *
       * @module random
       */

      var _rand = Math.random;
      var _uint = function _uint() {
        return (0, lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__.getRandomValues)(new Uint32Array(1))[0];
      };
      var _uint2 = function _uint2() {
        var arr = (0, lib0_webcrypto__WEBPACK_IMPORTED_MODULE_0__.getRandomValues)(new Uint32Array(8));
        return (arr[0] & _binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS21) * (_binary_js__WEBPACK_IMPORTED_MODULE_1__.BITS32 + 1) + (arr[1] >>> 0);
      };

      /**
       * @template T
       * @param {Array<T>} arr
       * @return {T}
       */
      var _oneOf = function _oneOf(arr) {
        return arr[_math_js__WEBPACK_IMPORTED_MODULE_2__.floor(_rand() * arr.length)];
      };

      // @ts-ignore
      var uuidv4Template = [1e7] + -1e3 + -4e3 + -8e3 + -1e11;

      /**
       * @return {string}
       */
      var _uuidv = function _uuidv() {
        return uuidv4Template.replace(/[018]/g, /** @param {number} c */function (c) {
          return (c ^ _uint() & 15 >> c / 4).toString(16);
        });
      };

      /***/
    },

    /***/"./node_modules/lib0/set.js":
    /*!**********************************!*\
      !*** ./node_modules/lib0/set.js ***!
      \**********************************/
    /***/
    function node_modulesLib0SetJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */create: function create() {
          return (/* binding */_create7
          );
        },
        /* harmony export */first: function first() {
          return (/* binding */_first
          );
        },
        /* harmony export */from: function from() {
          return (/* binding */_from2
          );
        },
        /* harmony export */toArray: function toArray() {
          return (/* binding */_toArray
          );
        }
        /* harmony export */
      });
      /**
       * Utility module to work with sets.
       *
       * @module set
       */

      var _create7 = function _create7() {
        return new Set();
      };

      /**
       * @template T
       * @param {Set<T>} set
       * @return {Array<T>}
       */
      var _toArray = function _toArray(set) {
        return Array.from(set);
      };

      /**
       * @template T
       * @param {Set<T>} set
       * @return {T}
       */
      var _first = function _first(set) {
        return set.values().next().value || undefined;
      };

      /**
       * @template T
       * @param {Iterable<T>} entries
       * @return {Set<T>}
       */
      var _from2 = function _from2(entries) {
        return new Set(entries);
      };

      /***/
    },

    /***/"./node_modules/lib0/storage.js":
    /*!**************************************!*\
      !*** ./node_modules/lib0/storage.js ***!
      \**************************************/
    /***/
    function node_modulesLib0StorageJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */offChange: function offChange() {
          return (/* binding */_offChange
          );
        },
        /* harmony export */onChange: function onChange() {
          return (/* binding */_onChange
          );
        },
        /* harmony export */varStorage: function varStorage() {
          return (/* binding */_varStorage
          );
        }
        /* harmony export */
      });
      /* eslint-env browser */

      /**
       * Isomorphic variable storage.
       *
       * Uses LocalStorage in the browser and falls back to in-memory storage.
       *
       * @module storage
       */

      /* c8 ignore start */
      var VarStoragePolyfill = /*#__PURE__*/function () {
        function VarStoragePolyfill() {
          _classCallCheck(this, VarStoragePolyfill);
          this.map = new Map();
        }

        /**
         * @param {string} key
         * @param {any} newValue
         */
        _createClass(VarStoragePolyfill, [{
          key: "setItem",
          value: function setItem(key, newValue) {
            this.map.set(key, newValue);
          }

          /**
           * @param {string} key
           */
        }, {
          key: "getItem",
          value: function getItem(key) {
            return this.map.get(key);
          }
        }]);
        return VarStoragePolyfill;
      }();
      /* c8 ignore stop */
      /**
       * @type {any}
       */
      var _localStorage = new VarStoragePolyfill();
      var usePolyfill = true;

      /* c8 ignore start */
      try {
        // if the same-origin rule is violated, accessing localStorage might thrown an error
        if (typeof localStorage !== 'undefined') {
          _localStorage = localStorage;
          usePolyfill = false;
        }
      } catch (e) {}
      /* c8 ignore stop */

      /**
       * This is basically localStorage in browser, or a polyfill in nodejs
       */
      /* c8 ignore next */
      var _varStorage = _localStorage;

      /**
       * A polyfill for `addEventListener('storage', event => {..})` that does nothing if the polyfill is being used.
       *
       * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler
       * @function
       */
      /* c8 ignore next */
      var _onChange = function _onChange(eventHandler) {
        return usePolyfill || addEventListener('storage', /** @type {any} */eventHandler);
      };

      /**
       * A polyfill for `removeEventListener('storage', event => {..})` that does nothing if the polyfill is being used.
       *
       * @param {function({ key: string, newValue: string, oldValue: string }): void} eventHandler
       * @function
       */
      /* c8 ignore next */
      var _offChange = function _offChange(eventHandler) {
        return usePolyfill || removeEventListener('storage', /** @type {any} */eventHandler);
      };

      /***/
    },

    /***/"./node_modules/lib0/string.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/string.js ***!
      \*************************************/
    /***/
    function node_modulesLib0StringJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */MAX_UTF16_CHARACTER: function MAX_UTF16_CHARACTER() {
          return (/* binding */_MAX_UTF16_CHARACTER
          );
        },
        /* harmony export */_decodeUtf8Native: function _decodeUtf8Native() {
          return (/* binding */_decodeUtf8Native2
          );
        },
        /* harmony export */_decodeUtf8Polyfill: function _decodeUtf8Polyfill() {
          return (/* binding */_decodeUtf8Polyfill2
          );
        },
        /* harmony export */_encodeUtf8Native: function _encodeUtf8Native() {
          return (/* binding */_encodeUtf8Native2
          );
        },
        /* harmony export */_encodeUtf8Polyfill: function _encodeUtf8Polyfill() {
          return (/* binding */_encodeUtf8Polyfill2
          );
        },
        /* harmony export */decodeUtf8: function decodeUtf8() {
          return (/* binding */_decodeUtf
          );
        },
        /* harmony export */encodeUtf8: function encodeUtf8() {
          return (/* binding */_encodeUtf
          );
        },
        /* harmony export */fromCamelCase: function fromCamelCase() {
          return (/* binding */_fromCamelCase
          );
        },
        /* harmony export */fromCharCode: function fromCharCode() {
          return (/* binding */_fromCharCode
          );
        },
        /* harmony export */fromCodePoint: function fromCodePoint() {
          return (/* binding */_fromCodePoint
          );
        },
        /* harmony export */repeat: function repeat() {
          return (/* binding */_repeat
          );
        },
        /* harmony export */splice: function splice() {
          return (/* binding */_splice
          );
        },
        /* harmony export */trimLeft: function trimLeft() {
          return (/* binding */_trimLeft
          );
        },
        /* harmony export */utf8ByteLength: function utf8ByteLength() {
          return (/* binding */_utf8ByteLength
          );
        },
        /* harmony export */utf8TextDecoder: function utf8TextDecoder() {
          return (/* binding */_utf8TextDecoder
          );
        },
        /* harmony export */utf8TextEncoder: function utf8TextEncoder() {
          return (/* binding */_utf8TextEncoder
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _array_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./array.js */"./node_modules/lib0/array.js");

      /**
       * Utility module to work with strings.
       *
       * @module string
       */

      var _fromCharCode = String.fromCharCode;
      var _fromCodePoint = String.fromCodePoint;

      /**
       * The largest utf16 character.
       * Corresponds to Uint8Array([255, 255]) or charcodeof(2x2^8)
       */
      var _MAX_UTF16_CHARACTER = _fromCharCode(65535);

      /**
       * @param {string} s
       * @return {string}
       */
      var toLowerCase = function toLowerCase(s) {
        return s.toLowerCase();
      };
      var trimLeftRegex = /^\s*/g;

      /**
       * @param {string} s
       * @return {string}
       */
      var _trimLeft = function _trimLeft(s) {
        return s.replace(trimLeftRegex, '');
      };
      var fromCamelCaseRegex = /([A-Z])/g;

      /**
       * @param {string} s
       * @param {string} separator
       * @return {string}
       */
      var _fromCamelCase = function _fromCamelCase(s, separator) {
        return _trimLeft(s.replace(fromCamelCaseRegex, function (match) {
          return "".concat(separator).concat(toLowerCase(match));
        }));
      };

      /**
       * Compute the utf8ByteLength
       * @param {string} str
       * @return {number}
       */
      var _utf8ByteLength = function _utf8ByteLength(str) {
        return unescape(encodeURIComponent(str)).length;
      };

      /**
       * @param {string} str
       * @return {Uint8Array}
       */
      var _encodeUtf8Polyfill2 = function _encodeUtf8Polyfill2(str) {
        var encodedString = unescape(encodeURIComponent(str));
        var len = encodedString.length;
        var buf = new Uint8Array(len);
        for (var i = 0; i < len; i++) {
          buf[i] = /** @type {number} */encodedString.codePointAt(i);
        }
        return buf;
      };

      /* c8 ignore next */
      var _utf8TextEncoder = /** @type {TextEncoder} */typeof TextEncoder !== 'undefined' ? new TextEncoder() : null;

      /**
       * @param {string} str
       * @return {Uint8Array}
       */
      var _encodeUtf8Native2 = function _encodeUtf8Native2(str) {
        return _utf8TextEncoder.encode(str);
      };

      /**
       * @param {string} str
       * @return {Uint8Array}
       */
      /* c8 ignore next */
      var _encodeUtf = _utf8TextEncoder ? _encodeUtf8Native2 : _encodeUtf8Polyfill2;

      /**
       * @param {Uint8Array} buf
       * @return {string}
       */
      var _decodeUtf8Polyfill2 = function _decodeUtf8Polyfill2(buf) {
        var remainingLen = buf.length;
        var encodedString = '';
        var bufPos = 0;
        while (remainingLen > 0) {
          var nextLen = remainingLen < 10000 ? remainingLen : 10000;
          var bytes = buf.subarray(bufPos, bufPos + nextLen);
          bufPos += nextLen;
          // Starting with ES5.1 we can supply a generic array-like object as arguments
          encodedString += String.fromCodePoint.apply(null, /** @type {any} */bytes);
          remainingLen -= nextLen;
        }
        return decodeURIComponent(escape(encodedString));
      };

      /* c8 ignore next */
      var _utf8TextDecoder = typeof TextDecoder === 'undefined' ? null : new TextDecoder('utf-8', {
        fatal: true,
        ignoreBOM: true
      });

      /* c8 ignore start */
      if (_utf8TextDecoder && _utf8TextDecoder.decode(new Uint8Array()).length === 1) {
        // Safari doesn't handle BOM correctly.
        // This fixes a bug in Safari 13.0.5 where it produces a BOM the first time it is called.
        // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the first call and
        // utf8TextDecoder.decode(new Uint8Array()).length === 1 on the second call
        // Another issue is that from then on no BOM chars are recognized anymore
        /* c8 ignore next */
        _utf8TextDecoder = null;
      }
      /* c8 ignore stop */

      /**
       * @param {Uint8Array} buf
       * @return {string}
       */
      var _decodeUtf8Native2 = function _decodeUtf8Native2(buf) {
        return (/** @type {TextDecoder} */_utf8TextDecoder.decode(buf)
        );
      };

      /**
       * @param {Uint8Array} buf
       * @return {string}
       */
      /* c8 ignore next */
      var _decodeUtf = _utf8TextDecoder ? _decodeUtf8Native2 : _decodeUtf8Polyfill2;

      /**
       * @param {string} str The initial string
       * @param {number} index Starting position
       * @param {number} remove Number of characters to remove
       * @param {string} insert New content to insert
       */
      var _splice = function _splice(str, index, remove) {
        var insert = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';
        return str.slice(0, index) + insert + str.slice(index + remove);
      };

      /**
       * @param {string} source
       * @param {number} n
       */
      var _repeat = function _repeat(source, n) {
        return _array_js__WEBPACK_IMPORTED_MODULE_0__.unfold(n, function () {
          return source;
        }).join('');
      };

      /***/
    },

    /***/"./node_modules/lib0/symbol.js":
    /*!*************************************!*\
      !*** ./node_modules/lib0/symbol.js ***!
      \*************************************/
    /***/
    function node_modulesLib0SymbolJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */create: function create() {
          return (/* binding */_create8
          );
        },
        /* harmony export */isSymbol: function isSymbol() {
          return (/* binding */_isSymbol
          );
        }
        /* harmony export */
      });
      /**
       * Utility module to work with EcmaScript Symbols.
       *
       * @module symbol
       */

      /**
       * Return fresh symbol.
       *
       * @return {Symbol}
       */
      var _create8 = Symbol;

      /**
       * @param {any} s
       * @return {boolean}
       */
      var _isSymbol = function _isSymbol(s) {
        return typeof s === 'symbol';
      };

      /***/
    },

    /***/"./node_modules/lib0/time.js":
    /*!***********************************!*\
      !*** ./node_modules/lib0/time.js ***!
      \***********************************/
    /***/
    function node_modulesLib0TimeJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */getDate: function getDate() {
          return (/* binding */_getDate
          );
        },
        /* harmony export */getUnixTime: function getUnixTime() {
          return (/* binding */_getUnixTime
          );
        },
        /* harmony export */humanizeDuration: function humanizeDuration() {
          return (/* binding */_humanizeDuration
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var _metric_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! ./metric.js */"./node_modules/lib0/metric.js");
      /* harmony import */
      var _math_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./math.js */"./node_modules/lib0/math.js");
      /**
       * Utility module to work with time.
       *
       * @module time
       */

      /**
       * Return current time.
       *
       * @return {Date}
       */
      var _getDate = function _getDate() {
        return new Date();
      };

      /**
       * Return current unix time.
       *
       * @return {number}
       */
      var _getUnixTime = Date.now;

      /**
       * Transform time (in ms) to a human readable format. E.g. 1100 => 1.1s. 60s => 1min. .001 => 10s.
       *
       * @param {number} d duration in milliseconds
       * @return {string} humanized approximation of time
       */
      var _humanizeDuration = function _humanizeDuration(d) {
        if (d < 60000) {
          var p = _metric_js__WEBPACK_IMPORTED_MODULE_0__.prefix(d, -1);
          return _math_js__WEBPACK_IMPORTED_MODULE_1__.round(p.n * 100) / 100 + p.prefix + 's';
        }
        d = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 1000);
        var seconds = d % 60;
        var minutes = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 60) % 60;
        var hours = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 3600) % 24;
        var days = _math_js__WEBPACK_IMPORTED_MODULE_1__.floor(d / 86400);
        if (days > 0) {
          return days + 'd' + (hours > 0 || minutes > 30 ? ' ' + (minutes > 30 ? hours + 1 : hours) + 'h' : '');
        }
        if (hours > 0) {
          /* c8 ignore next */
          return hours + 'h' + (minutes > 0 || seconds > 30 ? ' ' + (seconds > 30 ? minutes + 1 : minutes) + 'min' : '');
        }
        return minutes + 'min' + (seconds > 0 ? ' ' + seconds + 's' : '');
      };

      /***/
    },

    /***/"./node_modules/lib0/webcrypto.js":
    /*!****************************************!*\
      !*** ./node_modules/lib0/webcrypto.js ***!
      \****************************************/
    /***/
    function node_modulesLib0WebcryptoJs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */getRandomValues: function getRandomValues() {
          return (/* binding */_getRandomValues
          );
        },
        /* harmony export */subtle: function subtle() {
          return (/* binding */_subtle
          );
        }
        /* harmony export */
      });
      /* eslint-env browser */

      var _subtle = crypto.subtle;
      var _getRandomValues = crypto.getRandomValues.bind(crypto);

      /***/
    },

    /***/"./node_modules/yjs/dist/yjs.mjs":
    /*!***************************************!*\
      !*** ./node_modules/yjs/dist/yjs.mjs ***!
      \***************************************/
    /***/
    function node_modulesYjsDistYjsMjs(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {
      "use strict";

      var _marked = /*#__PURE__*/_regeneratorRuntime().mark(lazyStructReaderGenerator);
      __webpack_require__.r(__webpack_exports__);
      /* harmony export */
      __webpack_require__.d(__webpack_exports__, {
        /* harmony export */AbsolutePosition: function AbsolutePosition() {
          return (/* binding */_AbsolutePosition
          );
        },
        /* harmony export */AbstractConnector: function AbstractConnector() {
          return (/* binding */_AbstractConnector
          );
        },
        /* harmony export */AbstractStruct: function AbstractStruct() {
          return (/* binding */_AbstractStruct
          );
        },
        /* harmony export */AbstractType: function AbstractType() {
          return (/* binding */_AbstractType
          );
        },
        /* harmony export */Array: function Array() {
          return (/* binding */YArray
          );
        },
        /* harmony export */ContentAny: function ContentAny() {
          return (/* binding */_ContentAny
          );
        },
        /* harmony export */ContentBinary: function ContentBinary() {
          return (/* binding */_ContentBinary
          );
        },
        /* harmony export */ContentDeleted: function ContentDeleted() {
          return (/* binding */_ContentDeleted
          );
        },
        /* harmony export */ContentEmbed: function ContentEmbed() {
          return (/* binding */_ContentEmbed
          );
        },
        /* harmony export */ContentFormat: function ContentFormat() {
          return (/* binding */_ContentFormat
          );
        },
        /* harmony export */ContentJSON: function ContentJSON() {
          return (/* binding */_ContentJSON
          );
        },
        /* harmony export */ContentString: function ContentString() {
          return (/* binding */_ContentString
          );
        },
        /* harmony export */ContentType: function ContentType() {
          return (/* binding */_ContentType
          );
        },
        /* harmony export */Doc: function Doc() {
          return (/* binding */_Doc
          );
        },
        /* harmony export */GC: function GC() {
          return (/* binding */_GC
          );
        },
        /* harmony export */ID: function ID() {
          return (/* binding */_ID
          );
        },
        /* harmony export */Item: function Item() {
          return (/* binding */_Item
          );
        },
        /* harmony export */Map: function Map() {
          return (/* binding */YMap
          );
        },
        /* harmony export */PermanentUserData: function PermanentUserData() {
          return (/* binding */_PermanentUserData
          );
        },
        /* harmony export */RelativePosition: function RelativePosition() {
          return (/* binding */_RelativePosition
          );
        },
        /* harmony export */Snapshot: function Snapshot() {
          return (/* binding */_Snapshot
          );
        },
        /* harmony export */Text: function Text() {
          return (/* binding */YText
          );
        },
        /* harmony export */Transaction: function Transaction() {
          return (/* binding */_Transaction
          );
        },
        /* harmony export */UndoManager: function UndoManager() {
          return (/* binding */_UndoManager
          );
        },
        /* harmony export */UpdateEncoderV1: function UpdateEncoderV1() {
          return (/* binding */_UpdateEncoderV
          );
        },
        /* harmony export */XmlElement: function XmlElement() {
          return (/* binding */YXmlElement
          );
        },
        /* harmony export */XmlFragment: function XmlFragment() {
          return (/* binding */YXmlFragment
          );
        },
        /* harmony export */XmlHook: function XmlHook() {
          return (/* binding */YXmlHook
          );
        },
        /* harmony export */XmlText: function XmlText() {
          return (/* binding */YXmlText
          );
        },
        /* harmony export */YArrayEvent: function YArrayEvent() {
          return (/* binding */_YArrayEvent
          );
        },
        /* harmony export */YEvent: function YEvent() {
          return (/* binding */_YEvent
          );
        },
        /* harmony export */YMapEvent: function YMapEvent() {
          return (/* binding */_YMapEvent
          );
        },
        /* harmony export */YTextEvent: function YTextEvent() {
          return (/* binding */_YTextEvent
          );
        },
        /* harmony export */YXmlEvent: function YXmlEvent() {
          return (/* binding */_YXmlEvent
          );
        },
        /* harmony export */applyUpdate: function applyUpdate() {
          return (/* binding */_applyUpdate
          );
        },
        /* harmony export */applyUpdateV2: function applyUpdateV2() {
          return (/* binding */_applyUpdateV
          );
        },
        /* harmony export */cleanupYTextFormatting: function cleanupYTextFormatting() {
          return (/* binding */_cleanupYTextFormatting
          );
        },
        /* harmony export */compareIDs: function compareIDs() {
          return (/* binding */_compareIDs
          );
        },
        /* harmony export */compareRelativePositions: function compareRelativePositions() {
          return (/* binding */_compareRelativePositions
          );
        },
        /* harmony export */convertUpdateFormatV1ToV2: function convertUpdateFormatV1ToV2() {
          return (/* binding */_convertUpdateFormatV1ToV
          );
        },
        /* harmony export */convertUpdateFormatV2ToV1: function convertUpdateFormatV2ToV1() {
          return (/* binding */_convertUpdateFormatV2ToV
          );
        },
        /* harmony export */createAbsolutePositionFromRelativePosition: function createAbsolutePositionFromRelativePosition() {
          return (/* binding */_createAbsolutePositionFromRelativePosition
          );
        },
        /* harmony export */createDeleteSet: function createDeleteSet() {
          return (/* binding */_createDeleteSet
          );
        },
        /* harmony export */createDeleteSetFromStructStore: function createDeleteSetFromStructStore() {
          return (/* binding */_createDeleteSetFromStructStore
          );
        },
        /* harmony export */createDocFromSnapshot: function createDocFromSnapshot() {
          return (/* binding */_createDocFromSnapshot
          );
        },
        /* harmony export */createID: function createID() {
          return (/* binding */_createID
          );
        },
        /* harmony export */createRelativePositionFromJSON: function createRelativePositionFromJSON() {
          return (/* binding */_createRelativePositionFromJSON
          );
        },
        /* harmony export */createRelativePositionFromTypeIndex: function createRelativePositionFromTypeIndex() {
          return (/* binding */_createRelativePositionFromTypeIndex
          );
        },
        /* harmony export */createSnapshot: function createSnapshot() {
          return (/* binding */_createSnapshot
          );
        },
        /* harmony export */decodeRelativePosition: function decodeRelativePosition() {
          return (/* binding */_decodeRelativePosition
          );
        },
        /* harmony export */decodeSnapshot: function decodeSnapshot() {
          return (/* binding */_decodeSnapshot
          );
        },
        /* harmony export */decodeSnapshotV2: function decodeSnapshotV2() {
          return (/* binding */_decodeSnapshotV
          );
        },
        /* harmony export */decodeStateVector: function decodeStateVector() {
          return (/* binding */_decodeStateVector
          );
        },
        /* harmony export */decodeUpdate: function decodeUpdate() {
          return (/* binding */_decodeUpdate
          );
        },
        /* harmony export */decodeUpdateV2: function decodeUpdateV2() {
          return (/* binding */_decodeUpdateV
          );
        },
        /* harmony export */diffUpdate: function diffUpdate() {
          return (/* binding */_diffUpdate
          );
        },
        /* harmony export */diffUpdateV2: function diffUpdateV2() {
          return (/* binding */_diffUpdateV
          );
        },
        /* harmony export */emptySnapshot: function emptySnapshot() {
          return (/* binding */_emptySnapshot
          );
        },
        /* harmony export */encodeRelativePosition: function encodeRelativePosition() {
          return (/* binding */_encodeRelativePosition
          );
        },
        /* harmony export */encodeSnapshot: function encodeSnapshot() {
          return (/* binding */_encodeSnapshot
          );
        },
        /* harmony export */encodeSnapshotV2: function encodeSnapshotV2() {
          return (/* binding */_encodeSnapshotV
          );
        },
        /* harmony export */encodeStateAsUpdate: function encodeStateAsUpdate() {
          return (/* binding */_encodeStateAsUpdate
          );
        },
        /* harmony export */encodeStateAsUpdateV2: function encodeStateAsUpdateV2() {
          return (/* binding */_encodeStateAsUpdateV
          );
        },
        /* harmony export */encodeStateVector: function encodeStateVector() {
          return (/* binding */_encodeStateVector
          );
        },
        /* harmony export */encodeStateVectorFromUpdate: function encodeStateVectorFromUpdate() {
          return (/* binding */_encodeStateVectorFromUpdate
          );
        },
        /* harmony export */encodeStateVectorFromUpdateV2: function encodeStateVectorFromUpdateV2() {
          return (/* binding */_encodeStateVectorFromUpdateV
          );
        },
        /* harmony export */equalDeleteSets: function equalDeleteSets() {
          return (/* binding */_equalDeleteSets
          );
        },
        /* harmony export */equalSnapshots: function equalSnapshots() {
          return (/* binding */_equalSnapshots
          );
        },
        /* harmony export */findIndexSS: function findIndexSS() {
          return (/* binding */_findIndexSS
          );
        },
        /* harmony export */findRootTypeKey: function findRootTypeKey() {
          return (/* binding */_findRootTypeKey
          );
        },
        /* harmony export */getItem: function getItem() {
          return (/* binding */_getItem
          );
        },
        /* harmony export */getState: function getState() {
          return (/* binding */_getState
          );
        },
        /* harmony export */getTypeChildren: function getTypeChildren() {
          return (/* binding */_getTypeChildren
          );
        },
        /* harmony export */isDeleted: function isDeleted() {
          return (/* binding */_isDeleted
          );
        },
        /* harmony export */isParentOf: function isParentOf() {
          return (/* binding */_isParentOf2
          );
        },
        /* harmony export */iterateDeletedStructs: function iterateDeletedStructs() {
          return (/* binding */_iterateDeletedStructs
          );
        },
        /* harmony export */logType: function logType() {
          return (/* binding */_logType
          );
        },
        /* harmony export */logUpdate: function logUpdate() {
          return (/* binding */_logUpdate
          );
        },
        /* harmony export */logUpdateV2: function logUpdateV2() {
          return (/* binding */_logUpdateV
          );
        },
        /* harmony export */mergeUpdates: function mergeUpdates() {
          return (/* binding */_mergeUpdates
          );
        },
        /* harmony export */mergeUpdatesV2: function mergeUpdatesV2() {
          return (/* binding */_mergeUpdatesV
          );
        },
        /* harmony export */obfuscateUpdate: function obfuscateUpdate() {
          return (/* binding */_obfuscateUpdate
          );
        },
        /* harmony export */obfuscateUpdateV2: function obfuscateUpdateV2() {
          return (/* binding */_obfuscateUpdateV
          );
        },
        /* harmony export */parseUpdateMeta: function parseUpdateMeta() {
          return (/* binding */_parseUpdateMeta
          );
        },
        /* harmony export */parseUpdateMetaV2: function parseUpdateMetaV2() {
          return (/* binding */_parseUpdateMetaV
          );
        },
        /* harmony export */readUpdate: function readUpdate() {
          return (/* binding */_readUpdate
          );
        },
        /* harmony export */readUpdateV2: function readUpdateV2() {
          return (/* binding */_readUpdateV
          );
        },
        /* harmony export */relativePositionToJSON: function relativePositionToJSON() {
          return (/* binding */_relativePositionToJSON
          );
        },
        /* harmony export */snapshot: function snapshot() {
          return (/* binding */_snapshot
          );
        },
        /* harmony export */snapshotContainsUpdate: function snapshotContainsUpdate() {
          return (/* binding */_snapshotContainsUpdate
          );
        },
        /* harmony export */transact: function transact() {
          return (/* binding */_transact
          );
        },
        /* harmony export */tryGc: function tryGc() {
          return (/* binding */_tryGc
          );
        },
        /* harmony export */typeListToArraySnapshot: function typeListToArraySnapshot() {
          return (/* binding */_typeListToArraySnapshot
          );
        },
        /* harmony export */typeMapGetSnapshot: function typeMapGetSnapshot() {
          return (/* binding */_typeMapGetSnapshot
          );
        }
        /* harmony export */
      });
      /* harmony import */
      var lib0_observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! lib0/observable */"./node_modules/lib0/observable.js");
      /* harmony import */
      var lib0_array__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__( /*! lib0/array */"./node_modules/lib0/array.js");
      /* harmony import */
      var lib0_math__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! lib0/math */"./node_modules/lib0/math.js");
      /* harmony import */
      var lib0_map__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__( /*! lib0/map */"./node_modules/lib0/map.js");
      /* harmony import */
      var lib0_encoding__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__( /*! lib0/encoding */"./node_modules/lib0/encoding.js");
      /* harmony import */
      var lib0_decoding__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__( /*! lib0/decoding */"./node_modules/lib0/decoding.js");
      /* harmony import */
      var lib0_random__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__( /*! lib0/random */"./node_modules/lib0/random.js");
      /* harmony import */
      var lib0_promise__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__( /*! lib0/promise */"./node_modules/lib0/promise.js");
      /* harmony import */
      var lib0_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__( /*! lib0/buffer */"./node_modules/lib0/buffer.js");
      /* harmony import */
      var lib0_error__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__( /*! lib0/error */"./node_modules/lib0/error.js");
      /* harmony import */
      var lib0_binary__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__( /*! lib0/binary */"./node_modules/lib0/binary.js");
      /* harmony import */
      var lib0_function__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__( /*! lib0/function */"./node_modules/lib0/function.js");
      /* harmony import */
      var lib0_set__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__( /*! lib0/set */"./node_modules/lib0/set.js");
      /* harmony import */
      var lib0_logging__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__( /*! lib0/logging */"./node_modules/lib0/logging.js");
      /* harmony import */
      var lib0_logging__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__( /*! lib0/logging */"./node_modules/lib0/logging.common.js");
      /* harmony import */
      var lib0_time__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__( /*! lib0/time */"./node_modules/lib0/time.js");
      /* harmony import */
      var lib0_string__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__( /*! lib0/string */"./node_modules/lib0/string.js");
      /* harmony import */
      var lib0_iterator__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__( /*! lib0/iterator */"./node_modules/lib0/iterator.js");
      /* harmony import */
      var lib0_object__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__( /*! lib0/object */"./node_modules/lib0/object.js");

      /**
       * This is an abstract interface that all Connectors should implement to keep them interchangeable.
       *
       * @note This interface is experimental and it is not advised to actually inherit this class.
       *       It just serves as typing information.
       *
       * @extends {Observable<any>}
       */
      var _AbstractConnector = /*#__PURE__*/function (_lib0_observable__WEB) {
        _inherits(_AbstractConnector, _lib0_observable__WEB);
        var _super10 = _createSuper(_AbstractConnector);
        /**
         * @param {Doc} ydoc
         * @param {any} awareness
         */
        function _AbstractConnector(ydoc, awareness) {
          var _this18;
          _classCallCheck(this, _AbstractConnector);
          _this18 = _super10.call(this);
          _this18.doc = ydoc;
          _this18.awareness = awareness;
          return _this18;
        }
        return _createClass(_AbstractConnector);
      }(lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable);
      var DeleteItem = /*#__PURE__*/_createClass(
      /**
       * @param {number} clock
       * @param {number} len
       */
      function DeleteItem(clock, len) {
        _classCallCheck(this, DeleteItem);
        /**
         * @type {number}
         */
        this.clock = clock;
        /**
         * @type {number}
         */
        this.len = len;
      });
      /**
       * We no longer maintain a DeleteStore. DeleteSet is a temporary object that is created when needed.
       * - When created in a transaction, it must only be accessed after sorting, and merging
       *   - This DeleteSet is send to other clients
       * - We do not create a DeleteSet when we send a sync message. The DeleteSet message is created directly from StructStore
       * - We read a DeleteSet as part of a sync/update message. In this case the DeleteSet is already sorted and merged.
       */
      var DeleteSet = /*#__PURE__*/_createClass(function DeleteSet() {
        _classCallCheck(this, DeleteSet);
        /**
         * @type {Map<number,Array<DeleteItem>>}
         */
        this.clients = new Map();
      });
      /**
       * Iterate over all structs that the DeleteSet gc's.
       *
       * @param {Transaction} transaction
       * @param {DeleteSet} ds
       * @param {function(GC|Item):void} f
       *
       * @function
       */
      var _iterateDeletedStructs = function _iterateDeletedStructs(transaction, ds, f) {
        return ds.clients.forEach(function (deletes, clientid) {
          var structs = /** @type {Array<GC|Item>} */transaction.doc.store.clients.get(clientid);
          for (var i = 0; i < deletes.length; i++) {
            var del = deletes[i];
            iterateStructs(transaction, structs, del.clock, del.len, f);
          }
        });
      };

      /**
       * @param {Array<DeleteItem>} dis
       * @param {number} clock
       * @return {number|null}
       *
       * @private
       * @function
       */
      var findIndexDS = function findIndexDS(dis, clock) {
        var left = 0;
        var right = dis.length - 1;
        while (left <= right) {
          var midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);
          var mid = dis[midindex];
          var midclock = mid.clock;
          if (midclock <= clock) {
            if (clock < midclock + mid.len) {
              return midindex;
            }
            left = midindex + 1;
          } else {
            right = midindex - 1;
          }
        }
        return null;
      };

      /**
       * @param {DeleteSet} ds
       * @param {ID} id
       * @return {boolean}
       *
       * @private
       * @function
       */
      var _isDeleted = function _isDeleted(ds, id) {
        var dis = ds.clients.get(id.client);
        return dis !== undefined && findIndexDS(dis, id.clock) !== null;
      };

      /**
       * @param {DeleteSet} ds
       *
       * @private
       * @function
       */
      var sortAndMergeDeleteSet = function sortAndMergeDeleteSet(ds) {
        ds.clients.forEach(function (dels) {
          dels.sort(function (a, b) {
            return a.clock - b.clock;
          });
          // merge items without filtering or splicing the array
          // i is the current pointer
          // j refers to the current insert position for the pointed item
          // try to merge dels[i] into dels[j-1] or set dels[j]=dels[i]
          var i, j;
          for (i = 1, j = 1; i < dels.length; i++) {
            var left = dels[j - 1];
            var right = dels[i];
            if (left.clock + left.len >= right.clock) {
              left.len = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(left.len, right.clock + right.len - left.clock);
            } else {
              if (j < i) {
                dels[j] = right;
              }
              j++;
            }
          }
          dels.length = j;
        });
      };

      /**
       * @param {Array<DeleteSet>} dss
       * @return {DeleteSet} A fresh DeleteSet
       */
      var mergeDeleteSets = function mergeDeleteSets(dss) {
        var merged = new DeleteSet();
        var _loop = function _loop(dssI) {
          dss[dssI].clients.forEach(function (delsLeft, client) {
            if (!merged.clients.has(client)) {
              // Write all missing keys from current ds and all following.
              // If merged already contains `client` current ds has already been added.
              /**
               * @type {Array<DeleteItem>}
               */
              var dels = delsLeft.slice();
              for (var i = dssI + 1; i < dss.length; i++) {
                lib0_array__WEBPACK_IMPORTED_MODULE_2__.appendTo(dels, dss[i].clients.get(client) || []);
              }
              merged.clients.set(client, dels);
            }
          });
        };
        for (var dssI = 0; dssI < dss.length; dssI++) {
          _loop(dssI);
        }
        sortAndMergeDeleteSet(merged);
        return merged;
      };

      /**
       * @param {DeleteSet} ds
       * @param {number} client
       * @param {number} clock
       * @param {number} length
       *
       * @private
       * @function
       */
      var addToDeleteSet = function addToDeleteSet(ds, client, clock, length) {
        lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, function () {
          return (/** @type {Array<DeleteItem>} */[]
          );
        }).push(new DeleteItem(clock, length));
      };
      var _createDeleteSet = function _createDeleteSet() {
        return new DeleteSet();
      };

      /**
       * @param {StructStore} ss
       * @return {DeleteSet} Merged and sorted DeleteSet
       *
       * @private
       * @function
       */
      var _createDeleteSetFromStructStore = function _createDeleteSetFromStructStore(ss) {
        var ds = _createDeleteSet();
        ss.clients.forEach(function (structs, client) {
          /**
           * @type {Array<DeleteItem>}
           */
          var dsitems = [];
          for (var i = 0; i < structs.length; i++) {
            var struct = structs[i];
            if (struct.deleted) {
              var clock = struct.id.clock;
              var len = struct.length;
              if (i + 1 < structs.length) {
                for (var next = structs[i + 1]; i + 1 < structs.length && next.deleted; next = structs[++i + 1]) {
                  len += next.length;
                }
              }
              dsitems.push(new DeleteItem(clock, len));
            }
          }
          if (dsitems.length > 0) {
            ds.clients.set(client, dsitems);
          }
        });
        return ds;
      };

      /**
       * @param {DSEncoderV1 | DSEncoderV2} encoder
       * @param {DeleteSet} ds
       *
       * @private
       * @function
       */
      var writeDeleteSet = function writeDeleteSet(encoder, ds) {
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, ds.clients.size);

        // Ensure that the delete set is written in a deterministic order
        lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(ds.clients.entries()).sort(function (a, b) {
          return b[0] - a[0];
        }).forEach(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            client = _ref4[0],
            dsitems = _ref4[1];
          encoder.resetDsCurVal();
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client);
          var len = dsitems.length;
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, len);
          for (var i = 0; i < len; i++) {
            var item = dsitems[i];
            encoder.writeDsClock(item.clock);
            encoder.writeDsLen(item.len);
          }
        });
      };

      /**
       * @param {DSDecoderV1 | DSDecoderV2} decoder
       * @return {DeleteSet}
       *
       * @private
       * @function
       */
      var readDeleteSet = function readDeleteSet(decoder) {
        var ds = new DeleteSet();
        var numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
        for (var i = 0; i < numClients; i++) {
          decoder.resetDsCurVal();
          var client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          var numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          if (numberOfDeletes > 0) {
            var dsField = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(ds.clients, client, function () {
              return (/** @type {Array<DeleteItem>} */[]
              );
            });
            for (var _i3 = 0; _i3 < numberOfDeletes; _i3++) {
              dsField.push(new DeleteItem(decoder.readDsClock(), decoder.readDsLen()));
            }
          }
        }
        return ds;
      };

      /**
       * @todo YDecoder also contains references to String and other Decoders. Would make sense to exchange YDecoder.toUint8Array for YDecoder.DsToUint8Array()..
       */

      /**
       * @param {DSDecoderV1 | DSDecoderV2} decoder
       * @param {Transaction} transaction
       * @param {StructStore} store
       * @return {Uint8Array|null} Returns a v2 update containing all deletes that couldn't be applied yet; or null if all deletes were applied successfully.
       *
       * @private
       * @function
       */
      var readAndApplyDeleteSet = function readAndApplyDeleteSet(decoder, transaction, store) {
        var unappliedDS = new DeleteSet();
        var numClients = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
        for (var i = 0; i < numClients; i++) {
          decoder.resetDsCurVal();
          var client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          var numberOfDeletes = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          var structs = store.clients.get(client) || [];
          var state = _getState(store, client);
          for (var _i4 = 0; _i4 < numberOfDeletes; _i4++) {
            var clock = decoder.readDsClock();
            var clockEnd = clock + decoder.readDsLen();
            if (clock < state) {
              if (state < clockEnd) {
                addToDeleteSet(unappliedDS, client, state, clockEnd - state);
              }
              var index = _findIndexSS(structs, clock);
              /**
               * We can ignore the case of GC and Delete structs, because we are going to skip them
               * @type {Item}
               */
              // @ts-ignore
              var struct = structs[index];
              // split the first item if necessary
              if (!struct.deleted && struct.id.clock < clock) {
                structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
                index++; // increase we now want to use the next struct
              }

              while (index < structs.length) {
                // @ts-ignore
                struct = structs[index++];
                if (struct.id.clock < clockEnd) {
                  if (!struct.deleted) {
                    if (clockEnd < struct.id.clock + struct.length) {
                      structs.splice(index, 0, splitItem(transaction, struct, clockEnd - struct.id.clock));
                    }
                    struct.delete(transaction);
                  }
                } else {
                  break;
                }
              }
            } else {
              addToDeleteSet(unappliedDS, client, clock, clockEnd - clock);
            }
          }
        }
        if (unappliedDS.clients.size > 0) {
          var ds = new UpdateEncoderV2();
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(ds.restEncoder, 0); // encode 0 structs
          writeDeleteSet(ds, unappliedDS);
          return ds.toUint8Array();
        }
        return null;
      };

      /**
       * @param {DeleteSet} ds1
       * @param {DeleteSet} ds2
       */
      var _equalDeleteSets = function _equalDeleteSets(ds1, ds2) {
        if (ds1.clients.size !== ds2.clients.size) return false;
        var _iterator6 = _createForOfIteratorHelper(ds1.clients.entries()),
          _step6;
        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var _step6$value = _slicedToArray(_step6.value, 2),
              client = _step6$value[0],
              deleteItems1 = _step6$value[1];
            var deleteItems2 = /** @type {Array<import('../internals.js').DeleteItem>} */ds2.clients.get(client);
            if (deleteItems2 === undefined || deleteItems1.length !== deleteItems2.length) return false;
            for (var i = 0; i < deleteItems1.length; i++) {
              var di1 = deleteItems1[i];
              var di2 = deleteItems2[i];
              if (di1.clock !== di2.clock || di1.len !== di2.len) {
                return false;
              }
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
        return true;
      };

      /**
       * @module Y
       */

      var generateNewClientId = lib0_random__WEBPACK_IMPORTED_MODULE_6__.uint32;

      /**
       * @typedef {Object} DocOpts
       * @property {boolean} [DocOpts.gc=true] Disable garbage collection (default: gc=true)
       * @property {function(Item):boolean} [DocOpts.gcFilter] Will be called before an Item is garbage collected. Return false to keep the Item.
       * @property {string} [DocOpts.guid] Define a globally unique identifier for this document
       * @property {string | null} [DocOpts.collectionid] Associate this document with a collection. This only plays a role if your provider has a concept of collection.
       * @property {any} [DocOpts.meta] Any kind of meta information you want to associate with this document. If this is a subdocument, remote peers will store the meta information as well.
       * @property {boolean} [DocOpts.autoLoad] If a subdocument, automatically load document. If this is a subdocument, remote peers will load the document as well automatically.
       * @property {boolean} [DocOpts.shouldLoad] Whether the document should be synced by the provider now. This is toggled to true when you call ydoc.load()
       */

      /**
       * A Yjs instance handles the state of shared data.
       * @extends Observable<string>
       */
      var _Doc = /*#__PURE__*/function (_lib0_observable__WEB2) {
        _inherits(_Doc, _lib0_observable__WEB2);
        var _super11 = _createSuper(_Doc);
        /**
         * @param {DocOpts} opts configuration
         */
        function _Doc() {
          var _this19;
          var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref5$guid = _ref5.guid,
            guid = _ref5$guid === void 0 ? lib0_random__WEBPACK_IMPORTED_MODULE_6__.uuidv4() : _ref5$guid,
            _ref5$collectionid = _ref5.collectionid,
            collectionid = _ref5$collectionid === void 0 ? null : _ref5$collectionid,
            _ref5$gc = _ref5.gc,
            gc = _ref5$gc === void 0 ? true : _ref5$gc,
            _ref5$gcFilter = _ref5.gcFilter,
            gcFilter = _ref5$gcFilter === void 0 ? function () {
              return true;
            } : _ref5$gcFilter,
            _ref5$meta = _ref5.meta,
            meta = _ref5$meta === void 0 ? null : _ref5$meta,
            _ref5$autoLoad = _ref5.autoLoad,
            autoLoad = _ref5$autoLoad === void 0 ? false : _ref5$autoLoad,
            _ref5$shouldLoad = _ref5.shouldLoad,
            shouldLoad = _ref5$shouldLoad === void 0 ? true : _ref5$shouldLoad;
          _classCallCheck(this, _Doc);
          _this19 = _super11.call(this);
          _this19.gc = gc;
          _this19.gcFilter = gcFilter;
          _this19.clientID = generateNewClientId();
          _this19.guid = guid;
          _this19.collectionid = collectionid;
          /**
           * @type {Map<string, AbstractType<YEvent<any>>>}
           */
          _this19.share = new Map();
          _this19.store = new StructStore();
          /**
           * @type {Transaction | null}
           */
          _this19._transaction = null;
          /**
           * @type {Array<Transaction>}
           */
          _this19._transactionCleanups = [];
          /**
           * @type {Set<Doc>}
           */
          _this19.subdocs = new Set();
          /**
           * If this document is a subdocument - a document integrated into another document - then _item is defined.
           * @type {Item?}
           */
          _this19._item = null;
          _this19.shouldLoad = shouldLoad;
          _this19.autoLoad = autoLoad;
          _this19.meta = meta;
          /**
           * This is set to true when the persistence provider loaded the document from the database or when the `sync` event fires.
           * Note that not all providers implement this feature. Provider authors are encouraged to fire the `load` event when the doc content is loaded from the database.
           *
           * @type {boolean}
           */
          _this19.isLoaded = false;
          /**
           * This is set to true when the connection provider has successfully synced with a backend.
           * Note that when using peer-to-peer providers this event may not provide very useful.
           * Also note that not all providers implement this feature. Provider authors are encouraged to fire
           * the `sync` event when the doc has been synced (with `true` as a parameter) or if connection is
           * lost (with false as a parameter).
           */
          _this19.isSynced = false;
          /**
           * Promise that resolves once the document has been loaded from a presistence provider.
           */
          _this19.whenLoaded = lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(function (resolve) {
            _this19.on('load', function () {
              _this19.isLoaded = true;
              resolve(_assertThisInitialized(_this19));
            });
          });
          var provideSyncedPromise = function provideSyncedPromise() {
            return lib0_promise__WEBPACK_IMPORTED_MODULE_7__.create(function (resolve) {
              /**
               * @param {boolean} isSynced
               */
              var eventHandler = function eventHandler(isSynced) {
                if (isSynced === undefined || isSynced === true) {
                  _this19.off('sync', eventHandler);
                  resolve();
                }
              };
              _this19.on('sync', eventHandler);
            });
          };
          _this19.on('sync', function (isSynced) {
            if (isSynced === false && _this19.isSynced) {
              _this19.whenSynced = provideSyncedPromise();
            }
            _this19.isSynced = isSynced === undefined || isSynced === true;
            if (!_this19.isLoaded) {
              _this19.emit('load', []);
            }
          });
          /**
           * Promise that resolves once the document has been synced with a backend.
           * This promise is recreated when the connection is lost.
           * Note the documentation about the `isSynced` property.
           */
          _this19.whenSynced = provideSyncedPromise();
          return _this19;
        }

        /**
         * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
         *
         * `load()` might be used in the future to request any provider to load the most current data.
         *
         * It is safe to call `load()` multiple times.
         */
        _createClass(_Doc, [{
          key: "load",
          value: function load() {
            var _this20 = this;
            var item = this._item;
            if (item !== null && !this.shouldLoad) {
              _transact( /** @type {any} */item.parent.doc, function (transaction) {
                transaction.subdocsLoaded.add(_this20);
              }, null, true);
            }
            this.shouldLoad = true;
          }
        }, {
          key: "getSubdocs",
          value: function getSubdocs() {
            return this.subdocs;
          }
        }, {
          key: "getSubdocGuids",
          value: function getSubdocGuids() {
            return new Set(lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).map(function (doc) {
              return doc.guid;
            }));
          }

          /**
           * Changes that happen inside of a transaction are bundled. This means that
           * the observer fires _after_ the transaction is finished and that all changes
           * that happened inside of the transaction are sent as one message to the
           * other peers.
           *
           * @template T
           * @param {function(Transaction):T} f The function that should be executed as a transaction
           * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
           * @return T
           *
           * @public
           */
        }, {
          key: "transact",
          value: function transact(f) {
            var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
            return _transact(this, f, origin);
          }

          /**
           * Define a shared data type.
           *
           * Multiple calls of `y.get(name, TypeConstructor)` yield the same result
           * and do not overwrite each other. I.e.
           * `y.define(name, Y.Array) === y.define(name, Y.Array)`
           *
           * After this method is called, the type is also available on `y.share.get(name)`.
           *
           * *Best Practices:*
           * Define all types right after the Yjs instance is created and store them in a separate object.
           * Also use the typed methods `getText(name)`, `getArray(name)`, ..
           *
           * @example
           *   const y = new Y(..)
           *   const appState = {
           *     document: y.getText('document')
           *     comments: y.getArray('comments')
           *   }
           *
           * @param {string} name
           * @param {Function} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
           * @return {AbstractType<any>} The created type. Constructed with TypeConstructor
           *
           * @public
           */
        }, {
          key: "get",
          value: function get(name) {
            var _this21 = this;
            var TypeConstructor = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _AbstractType;
            var type = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(this.share, name, function () {
              // @ts-ignore
              var t = new TypeConstructor();
              t._integrate(_this21, null);
              return t;
            });
            var Constr = type.constructor;
            if (TypeConstructor !== _AbstractType && Constr !== TypeConstructor) {
              if (Constr === _AbstractType) {
                // @ts-ignore
                var t = new TypeConstructor();
                t._map = type._map;
                type._map.forEach( /** @param {Item?} n */function (n) {
                  for (; n !== null; n = n.left) {
                    // @ts-ignore
                    n.parent = t;
                  }
                });
                t._start = type._start;
                for (var n = t._start; n !== null; n = n.right) {
                  n.parent = t;
                }
                t._length = type._length;
                this.share.set(name, t);
                t._integrate(this, null);
                return t;
              } else {
                throw new Error("Type with the name ".concat(name, " has already been defined with a different constructor"));
              }
            }
            return type;
          }

          /**
           * @template T
           * @param {string} [name]
           * @return {YArray<T>}
           *
           * @public
           */
        }, {
          key: "getArray",
          value: function getArray() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // @ts-ignore
            return this.get(name, YArray);
          }

          /**
           * @param {string} [name]
           * @return {YText}
           *
           * @public
           */
        }, {
          key: "getText",
          value: function getText() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // @ts-ignore
            return this.get(name, YText);
          }

          /**
           * @template T
           * @param {string} [name]
           * @return {YMap<T>}
           *
           * @public
           */
        }, {
          key: "getMap",
          value: function getMap() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // @ts-ignore
            return this.get(name, YMap);
          }

          /**
           * @param {string} [name]
           * @return {YXmlFragment}
           *
           * @public
           */
        }, {
          key: "getXmlFragment",
          value: function getXmlFragment() {
            var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
            // @ts-ignore
            return this.get(name, YXmlFragment);
          }

          /**
           * Converts the entire document into a js object, recursively traversing each yjs type
           * Doesn't log types that have not been defined (using ydoc.getType(..)).
           *
           * @deprecated Do not use this method and rather call toJSON directly on the shared types.
           *
           * @return {Object<string, any>}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            /**
             * @type {Object<string, any>}
             */
            var doc = {};
            this.share.forEach(function (value, key) {
              doc[key] = value.toJSON();
            });
            return doc;
          }

          /**
           * Emit `destroy` event and unregister all event handlers.
           */
        }, {
          key: "destroy",
          value: function destroy() {
            var _this22 = this;
            lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(this.subdocs).forEach(function (subdoc) {
              return subdoc.destroy();
            });
            var item = this._item;
            if (item !== null) {
              this._item = null;
              var content = /** @type {ContentDoc} */item.content;
              content.doc = new _Doc(_objectSpread(_objectSpread({
                guid: this.guid
              }, content.opts), {}, {
                shouldLoad: false
              }));
              content.doc._item = item;
              _transact( /** @type {any} */item.parent.doc, function (transaction) {
                var doc = content.doc;
                if (!item.deleted) {
                  transaction.subdocsAdded.add(doc);
                }
                transaction.subdocsRemoved.add(_this22);
              }, null, true);
            }
            this.emit('destroyed', [true]);
            this.emit('destroy', [this]);
            _get(_getPrototypeOf(_Doc.prototype), "destroy", this).call(this);
          }

          /**
           * @param {string} eventName
           * @param {function(...any):any} f
           */
        }, {
          key: "on",
          value: function on(eventName, f) {
            _get(_getPrototypeOf(_Doc.prototype), "on", this).call(this, eventName, f);
          }

          /**
           * @param {string} eventName
           * @param {function} f
           */
        }, {
          key: "off",
          value: function off(eventName, f) {
            _get(_getPrototypeOf(_Doc.prototype), "off", this).call(this, eventName, f);
          }
        }]);
        return _Doc;
      }(lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable);
      var DSDecoderV1 = /*#__PURE__*/function () {
        /**
         * @param {decoding.Decoder} decoder
         */
        function DSDecoderV1(decoder) {
          _classCallCheck(this, DSDecoderV1);
          this.restDecoder = decoder;
        }
        _createClass(DSDecoderV1, [{
          key: "resetDsCurVal",
          value: function resetDsCurVal() {
            // nop
          }

          /**
           * @return {number}
           */
        }, {
          key: "readDsClock",
          value: function readDsClock() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
          }

          /**
           * @return {number}
           */
        }, {
          key: "readDsLen",
          value: function readDsLen() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
          }
        }]);
        return DSDecoderV1;
      }();
      var UpdateDecoderV1 = /*#__PURE__*/function (_DSDecoderV) {
        _inherits(UpdateDecoderV1, _DSDecoderV);
        var _super12 = _createSuper(UpdateDecoderV1);
        function UpdateDecoderV1() {
          _classCallCheck(this, UpdateDecoderV1);
          return _super12.apply(this, arguments);
        }
        _createClass(UpdateDecoderV1, [{
          key: "readLeftID",
          value:
          /**
           * @return {ID}
           */
          function readLeftID() {
            return _createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));
          }

          /**
           * @return {ID}
           */
        }, {
          key: "readRightID",
          value: function readRightID() {
            return _createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder));
          }

          /**
           * Read the next client id.
           * Use this in favor of readID whenever possible to reduce the number of objects created.
           */
        }, {
          key: "readClient",
          value: function readClient() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
          }

          /**
           * @return {number} info An unsigned 8-bit integer
           */
        }, {
          key: "readInfo",
          value: function readInfo() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8(this.restDecoder);
          }

          /**
           * @return {string}
           */
        }, {
          key: "readString",
          value: function readString() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);
          }

          /**
           * @return {boolean} isKey
           */
        }, {
          key: "readParentInfo",
          value: function readParentInfo() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) === 1;
          }

          /**
           * @return {number} info An unsigned 8-bit integer
           */
        }, {
          key: "readTypeRef",
          value: function readTypeRef() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
          }

          /**
           * Write len of a struct - well suited for Opt RLE encoder.
           *
           * @return {number} len
           */
        }, {
          key: "readLen",
          value: function readLen() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
          }

          /**
           * @return {any}
           */
        }, {
          key: "readAny",
          value: function readAny() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);
          }

          /**
           * @return {Uint8Array}
           */
        }, {
          key: "readBuf",
          value: function readBuf() {
            return lib0_buffer__WEBPACK_IMPORTED_MODULE_8__.copyUint8Array(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder));
          }

          /**
           * Legacy implementation uses JSON parse. We use any-decoding in v2.
           *
           * @return {any}
           */
        }, {
          key: "readJSON",
          value: function readJSON() {
            return JSON.parse(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder));
          }

          /**
           * @return {string}
           */
        }, {
          key: "readKey",
          value: function readKey() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(this.restDecoder);
          }
        }]);
        return UpdateDecoderV1;
      }(DSDecoderV1);
      var DSDecoderV2 = /*#__PURE__*/function () {
        /**
         * @param {decoding.Decoder} decoder
         */
        function DSDecoderV2(decoder) {
          _classCallCheck(this, DSDecoderV2);
          /**
           * @private
           */
          this.dsCurrVal = 0;
          this.restDecoder = decoder;
        }
        _createClass(DSDecoderV2, [{
          key: "resetDsCurVal",
          value: function resetDsCurVal() {
            this.dsCurrVal = 0;
          }

          /**
           * @return {number}
           */
        }, {
          key: "readDsClock",
          value: function readDsClock() {
            this.dsCurrVal += lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder);
            return this.dsCurrVal;
          }

          /**
           * @return {number}
           */
        }, {
          key: "readDsLen",
          value: function readDsLen() {
            var diff = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(this.restDecoder) + 1;
            this.dsCurrVal += diff;
            return diff;
          }
        }]);
        return DSDecoderV2;
      }();
      var UpdateDecoderV2 = /*#__PURE__*/function (_DSDecoderV2) {
        _inherits(UpdateDecoderV2, _DSDecoderV2);
        var _super13 = _createSuper(UpdateDecoderV2);
        /**
         * @param {decoding.Decoder} decoder
         */
        function UpdateDecoderV2(decoder) {
          var _this23;
          _classCallCheck(this, UpdateDecoderV2);
          _this23 = _super13.call(this, decoder);
          /**
           * List of cached keys. If the keys[id] does not exist, we read a new key
           * from stringEncoder and push it to keys.
           *
           * @type {Array<string>}
           */
          _this23.keys = [];
          lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder); // read feature flag - currently unused
          _this23.keyClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.clientDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.leftClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.rightClockDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.IntDiffOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.infoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);
          _this23.stringDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.StringDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.parentInfoDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.RleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readUint8);
          _this23.typeRefDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          _this23.lenDecoder = new lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.UintOptRleDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(decoder));
          return _this23;
        }

        /**
         * @return {ID}
         */
        _createClass(UpdateDecoderV2, [{
          key: "readLeftID",
          value: function readLeftID() {
            return new _ID(this.clientDecoder.read(), this.leftClockDecoder.read());
          }

          /**
           * @return {ID}
           */
        }, {
          key: "readRightID",
          value: function readRightID() {
            return new _ID(this.clientDecoder.read(), this.rightClockDecoder.read());
          }

          /**
           * Read the next client id.
           * Use this in favor of readID whenever possible to reduce the number of objects created.
           */
        }, {
          key: "readClient",
          value: function readClient() {
            return this.clientDecoder.read();
          }

          /**
           * @return {number} info An unsigned 8-bit integer
           */
        }, {
          key: "readInfo",
          value: function readInfo() {
            return (/** @type {number} */this.infoDecoder.read()
            );
          }

          /**
           * @return {string}
           */
        }, {
          key: "readString",
          value: function readString() {
            return this.stringDecoder.read();
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "readParentInfo",
          value: function readParentInfo() {
            return this.parentInfoDecoder.read() === 1;
          }

          /**
           * @return {number} An unsigned 8-bit integer
           */
        }, {
          key: "readTypeRef",
          value: function readTypeRef() {
            return this.typeRefDecoder.read();
          }

          /**
           * Write len of a struct - well suited for Opt RLE encoder.
           *
           * @return {number}
           */
        }, {
          key: "readLen",
          value: function readLen() {
            return this.lenDecoder.read();
          }

          /**
           * @return {any}
           */
        }, {
          key: "readAny",
          value: function readAny() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);
          }

          /**
           * @return {Uint8Array}
           */
        }, {
          key: "readBuf",
          value: function readBuf() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint8Array(this.restDecoder);
          }

          /**
           * This is mainly here for legacy purposes.
           *
           * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
           *
           * @return {any}
           */
        }, {
          key: "readJSON",
          value: function readJSON() {
            return lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readAny(this.restDecoder);
          }

          /**
           * @return {string}
           */
        }, {
          key: "readKey",
          value: function readKey() {
            var keyClock = this.keyClockDecoder.read();
            if (keyClock < this.keys.length) {
              return this.keys[keyClock];
            } else {
              var key = this.stringDecoder.read();
              this.keys.push(key);
              return key;
            }
          }
        }]);
        return UpdateDecoderV2;
      }(DSDecoderV2);
      var DSEncoderV1 = /*#__PURE__*/function () {
        function DSEncoderV1() {
          _classCallCheck(this, DSEncoderV1);
          this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
        }
        _createClass(DSEncoderV1, [{
          key: "toUint8Array",
          value: function toUint8Array() {
            return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);
          }
        }, {
          key: "resetDsCurVal",
          value: function resetDsCurVal() {
            // nop
          }

          /**
           * @param {number} clock
           */
        }, {
          key: "writeDsClock",
          value: function writeDsClock(clock) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, clock);
          }

          /**
           * @param {number} len
           */
        }, {
          key: "writeDsLen",
          value: function writeDsLen(len) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);
          }
        }]);
        return DSEncoderV1;
      }();
      var _UpdateEncoderV = /*#__PURE__*/function (_DSEncoderV) {
        _inherits(_UpdateEncoderV, _DSEncoderV);
        var _super14 = _createSuper(_UpdateEncoderV);
        function _UpdateEncoderV() {
          _classCallCheck(this, _UpdateEncoderV);
          return _super14.apply(this, arguments);
        }
        _createClass(_UpdateEncoderV, [{
          key: "writeLeftID",
          value:
          /**
           * @param {ID} id
           */
          function writeLeftID(id) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);
          }

          /**
           * @param {ID} id
           */
        }, {
          key: "writeRightID",
          value: function writeRightID(id) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.client);
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, id.clock);
          }

          /**
           * Use writeClient and writeClock instead of writeID if possible.
           * @param {number} client
           */
        }, {
          key: "writeClient",
          value: function writeClient(client) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, client);
          }

          /**
           * @param {number} info An unsigned 8-bit integer
           */
        }, {
          key: "writeInfo",
          value: function writeInfo(info) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(this.restEncoder, info);
          }

          /**
           * @param {string} s
           */
        }, {
          key: "writeString",
          value: function writeString(s) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, s);
          }

          /**
           * @param {boolean} isYKey
           */
        }, {
          key: "writeParentInfo",
          value: function writeParentInfo(isYKey) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, isYKey ? 1 : 0);
          }

          /**
           * @param {number} info An unsigned 8-bit integer
           */
        }, {
          key: "writeTypeRef",
          value: function writeTypeRef(info) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, info);
          }

          /**
           * Write len of a struct - well suited for Opt RLE encoder.
           *
           * @param {number} len
           */
        }, {
          key: "writeLen",
          value: function writeLen(len) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len);
          }

          /**
           * @param {any} any
           */
        }, {
          key: "writeAny",
          value: function writeAny(any) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);
          }

          /**
           * @param {Uint8Array} buf
           */
        }, {
          key: "writeBuf",
          value: function writeBuf(buf) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);
          }

          /**
           * @param {any} embed
           */
        }, {
          key: "writeJSON",
          value: function writeJSON(embed) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, JSON.stringify(embed));
          }

          /**
           * @param {string} key
           */
        }, {
          key: "writeKey",
          value: function writeKey(key) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(this.restEncoder, key);
          }
        }]);
        return _UpdateEncoderV;
      }(DSEncoderV1);
      var DSEncoderV2 = /*#__PURE__*/function () {
        function DSEncoderV2() {
          _classCallCheck(this, DSEncoderV2);
          this.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder(); // encodes all the rest / non-optimized
          this.dsCurrVal = 0;
        }
        _createClass(DSEncoderV2, [{
          key: "toUint8Array",
          value: function toUint8Array() {
            return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder);
          }
        }, {
          key: "resetDsCurVal",
          value: function resetDsCurVal() {
            this.dsCurrVal = 0;
          }

          /**
           * @param {number} clock
           */
        }, {
          key: "writeDsClock",
          value: function writeDsClock(clock) {
            var diff = clock - this.dsCurrVal;
            this.dsCurrVal = clock;
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, diff);
          }

          /**
           * @param {number} len
           */
        }, {
          key: "writeDsLen",
          value: function writeDsLen(len) {
            if (len === 0) {
              lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
            }
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(this.restEncoder, len - 1);
            this.dsCurrVal += len;
          }
        }]);
        return DSEncoderV2;
      }();
      var UpdateEncoderV2 = /*#__PURE__*/function (_DSEncoderV2) {
        _inherits(UpdateEncoderV2, _DSEncoderV2);
        var _super15 = _createSuper(UpdateEncoderV2);
        function UpdateEncoderV2() {
          var _this24;
          _classCallCheck(this, UpdateEncoderV2);
          _this24 = _super15.call(this);
          /**
           * @type {Map<string,number>}
           */
          _this24.keyMap = new Map();
          /**
           * Refers to the next uniqe key-identifier to me used.
           * See writeKey method for more information.
           *
           * @type {number}
           */
          _this24.keyClock = 0;
          _this24.keyClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();
          _this24.clientEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();
          _this24.leftClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();
          _this24.rightClockEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.IntDiffOptRleEncoder();
          _this24.infoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);
          _this24.stringEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.StringEncoder();
          _this24.parentInfoEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.RleEncoder(lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8);
          _this24.typeRefEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();
          _this24.lenEncoder = new lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.UintOptRleEncoder();
          return _this24;
        }
        _createClass(UpdateEncoderV2, [{
          key: "toUint8Array",
          value: function toUint8Array() {
            var encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0); // this is a feature flag that we might use in the future
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.keyClockEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.clientEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.leftClockEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.rightClockEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.infoEncoder));
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.stringEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.parentInfoEncoder));
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.typeRefEncoder.toUint8Array());
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(encoder, this.lenEncoder.toUint8Array());
            // @note The rest encoder is appended! (note the missing var)
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(encoder, lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(this.restEncoder));
            return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);
          }

          /**
           * @param {ID} id
           */
        }, {
          key: "writeLeftID",
          value: function writeLeftID(id) {
            this.clientEncoder.write(id.client);
            this.leftClockEncoder.write(id.clock);
          }

          /**
           * @param {ID} id
           */
        }, {
          key: "writeRightID",
          value: function writeRightID(id) {
            this.clientEncoder.write(id.client);
            this.rightClockEncoder.write(id.clock);
          }

          /**
           * @param {number} client
           */
        }, {
          key: "writeClient",
          value: function writeClient(client) {
            this.clientEncoder.write(client);
          }

          /**
           * @param {number} info An unsigned 8-bit integer
           */
        }, {
          key: "writeInfo",
          value: function writeInfo(info) {
            this.infoEncoder.write(info);
          }

          /**
           * @param {string} s
           */
        }, {
          key: "writeString",
          value: function writeString(s) {
            this.stringEncoder.write(s);
          }

          /**
           * @param {boolean} isYKey
           */
        }, {
          key: "writeParentInfo",
          value: function writeParentInfo(isYKey) {
            this.parentInfoEncoder.write(isYKey ? 1 : 0);
          }

          /**
           * @param {number} info An unsigned 8-bit integer
           */
        }, {
          key: "writeTypeRef",
          value: function writeTypeRef(info) {
            this.typeRefEncoder.write(info);
          }

          /**
           * Write len of a struct - well suited for Opt RLE encoder.
           *
           * @param {number} len
           */
        }, {
          key: "writeLen",
          value: function writeLen(len) {
            this.lenEncoder.write(len);
          }

          /**
           * @param {any} any
           */
        }, {
          key: "writeAny",
          value: function writeAny(any) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, any);
          }

          /**
           * @param {Uint8Array} buf
           */
        }, {
          key: "writeBuf",
          value: function writeBuf(buf) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint8Array(this.restEncoder, buf);
          }

          /**
           * This is mainly here for legacy purposes.
           *
           * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
           *
           * @param {any} embed
           */
        }, {
          key: "writeJSON",
          value: function writeJSON(embed) {
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeAny(this.restEncoder, embed);
          }

          /**
           * Property keys are often reused. For example, in y-prosemirror the key `bold` might
           * occur very often. For a 3d application, the key `position` might occur very often.
           *
           * We cache these keys in a Map and refer to them via a unique number.
           *
           * @param {string} key
           */
        }, {
          key: "writeKey",
          value: function writeKey(key) {
            var clock = this.keyMap.get(key);
            if (clock === undefined) {
              /**
               * @todo uncomment to introduce this feature finally
               *
               * Background. The ContentFormat object was always encoded using writeKey, but the decoder used to use readString.
               * Furthermore, I forgot to set the keyclock. So everything was working fine.
               *
               * However, this feature here is basically useless as it is not being used (it actually only consumes extra memory).
               *
               * I don't know yet how to reintroduce this feature..
               *
               * Older clients won't be able to read updates when we reintroduce this feature. So this should probably be done using a flag.
               *
               */
              // this.keyMap.set(key, this.keyClock)
              this.keyClockEncoder.write(this.keyClock++);
              this.stringEncoder.write(key);
            } else {
              this.keyClockEncoder.write(clock);
            }
          }
        }]);
        return UpdateEncoderV2;
      }(DSEncoderV2);
      /**
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       * @param {Array<GC|Item>} structs All structs by `client`
       * @param {number} client
       * @param {number} clock write structs starting with `ID(client,clock)`
       *
       * @function
       */
      var writeStructs = function writeStructs(encoder, structs, client, clock) {
        // write first id
        clock = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(clock, structs[0].id.clock); // make sure the first id exists
        var startNewStructs = _findIndexSS(structs, clock);
        // write # encoded structs
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, structs.length - startNewStructs);
        encoder.writeClient(client);
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);
        var firstStruct = structs[startNewStructs];
        // write first struct with an offset
        firstStruct.write(encoder, clock - firstStruct.id.clock);
        for (var i = startNewStructs + 1; i < structs.length; i++) {
          structs[i].write(encoder, 0);
        }
      };

      /**
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       * @param {StructStore} store
       * @param {Map<number,number>} _sm
       *
       * @private
       * @function
       */
      var writeClientsStructs = function writeClientsStructs(encoder, store, _sm) {
        // we filter all valid _sm entries into sm
        var sm = new Map();
        _sm.forEach(function (clock, client) {
          // only write if new structs are available
          if (_getState(store, client) > clock) {
            sm.set(client, clock);
          }
        });
        getStateVector(store).forEach(function (_clock, client) {
          if (!_sm.has(client)) {
            sm.set(client, 0);
          }
        });
        // write # states that were updated
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sm.size);
        // Write items with higher client ids first
        // This heavily improves the conflict algorithm.
        lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sm.entries()).sort(function (a, b) {
          return b[0] - a[0];
        }).forEach(function (_ref6) {
          var _ref7 = _slicedToArray(_ref6, 2),
            client = _ref7[0],
            clock = _ref7[1];
          writeStructs(encoder, /** @type {Array<GC|Item>} */store.clients.get(client), client, clock);
        });
      };

      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder The decoder object to read data from.
       * @param {Doc} doc
       * @return {Map<number, { i: number, refs: Array<Item | GC> }>}
       *
       * @private
       * @function
       */
      var readClientsStructRefs = function readClientsStructRefs(decoder, doc) {
        /**
         * @type {Map<number, { i: number, refs: Array<Item | GC> }>}
         */
        var clientRefs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        var numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
        for (var i = 0; i < numOfStateUpdates; i++) {
          var numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          /**
           * @type {Array<GC|Item>}
           */
          var refs = new Array(numberOfStructs);
          var client = decoder.readClient();
          var clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          // const start = performance.now()
          clientRefs.set(client, {
            i: 0,
            refs: refs
          });
          for (var _i5 = 0; _i5 < numberOfStructs; _i5++) {
            var info = decoder.readInfo();
            switch (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) {
              case 0:
                {
                  // GC
                  var len = decoder.readLen();
                  refs[_i5] = new _GC(_createID(client, clock), len);
                  clock += len;
                  break;
                }
              case 10:
                {
                  // Skip Struct (nothing to apply)
                  // @todo we could reduce the amount of checks by adding Skip struct to clientRefs so we know that something is missing.
                  var _len6 = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
                  refs[_i5] = new Skip(_createID(client, clock), _len6);
                  clock += _len6;
                  break;
                }
              default:
                {
                  // Item with content
                  /**
                   * The optimized implementation doesn't use any variables because inlining variables is faster.
                   * Below a non-optimized version is shown that implements the basic algorithm with
                   * a few comments
                   */
                  var cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0;
                  // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                  // and we read the next string as parentYKey.
                  // It indicates how we store/retrieve parent from `y.share`
                  // @type {string|null}
                  var struct = new _Item(_createID(client, clock), null,
                  // leftd
                  (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null,
                  // origin
                  null,
                  // right
                  (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null,
                  // right origin
                  cantCopyParentInfo ? decoder.readParentInfo() ? doc.get(decoder.readString()) : decoder.readLeftID() : null,
                  // parent
                  cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null,
                  // parentSub
                  readItemContent(decoder, info) // item content
                  );
                  /* A non-optimized implementation of the above algorithm:
                   // The item that was originally to the left of this item.
                  const origin = (info & binary.BIT8) === binary.BIT8 ? decoder.readLeftID() : null
                  // The item that was originally to the right of this item.
                  const rightOrigin = (info & binary.BIT7) === binary.BIT7 ? decoder.readRightID() : null
                  const cantCopyParentInfo = (info & (binary.BIT7 | binary.BIT8)) === 0
                  const hasParentYKey = cantCopyParentInfo ? decoder.readParentInfo() : false
                  // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
                  // and we read the next string as parentYKey.
                  // It indicates how we store/retrieve parent from `y.share`
                  // @type {string|null}
                  const parentYKey = cantCopyParentInfo && hasParentYKey ? decoder.readString() : null
                   const struct = new Item(
                    createID(client, clock),
                    null, // leftd
                    origin, // origin
                    null, // right
                    rightOrigin, // right origin
                    cantCopyParentInfo && !hasParentYKey ? decoder.readLeftID() : (parentYKey !== null ? doc.get(parentYKey) : null), // parent
                    cantCopyParentInfo && (info & binary.BIT6) === binary.BIT6 ? decoder.readString() : null, // parentSub
                    readItemContent(decoder, info) // item content
                  )
                  */
                  refs[_i5] = struct;
                  clock += struct.length;
                }
            }
          }
          // console.log('time to read: ', performance.now() - start) // @todo remove
        }

        return clientRefs;
      };

      /**
       * Resume computing structs generated by struct readers.
       *
       * While there is something to do, we integrate structs in this order
       * 1. top element on stack, if stack is not empty
       * 2. next element from current struct reader (if empty, use next struct reader)
       *
       * If struct causally depends on another struct (ref.missing), we put next reader of
       * `ref.id.client` on top of stack.
       *
       * At some point we find a struct that has no causal dependencies,
       * then we start emptying the stack.
       *
       * It is not possible to have circles: i.e. struct1 (from client1) depends on struct2 (from client2)
       * depends on struct3 (from client1). Therefore the max stack size is eqaul to `structReaders.length`.
       *
       * This method is implemented in a way so that we can resume computation if this update
       * causally depends on another update.
       *
       * @param {Transaction} transaction
       * @param {StructStore} store
       * @param {Map<number, { i: number, refs: (GC | Item)[] }>} clientsStructRefs
       * @return { null | { update: Uint8Array, missing: Map<number,number> } }
       *
       * @private
       * @function
       */
      var integrateStructs = function integrateStructs(transaction, store, clientsStructRefs) {
        /**
         * @type {Array<Item | GC>}
         */
        var stack = [];
        // sort them so that we take the higher id first, in case of conflicts the lower id will probably not conflict with the id from the higher user.
        var clientsStructRefsIds = lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(clientsStructRefs.keys()).sort(function (a, b) {
          return a - b;
        });
        if (clientsStructRefsIds.length === 0) {
          return null;
        }
        var getNextStructTarget = function getNextStructTarget() {
          if (clientsStructRefsIds.length === 0) {
            return null;
          }
          var nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
          while (nextStructsTarget.refs.length === nextStructsTarget.i) {
            clientsStructRefsIds.pop();
            if (clientsStructRefsIds.length > 0) {
              nextStructsTarget = /** @type {{i:number,refs:Array<GC|Item>}} */clientsStructRefs.get(clientsStructRefsIds[clientsStructRefsIds.length - 1]);
            } else {
              return null;
            }
          }
          return nextStructsTarget;
        };
        var curStructsTarget = getNextStructTarget();
        if (curStructsTarget === null && stack.length === 0) {
          return null;
        }

        /**
         * @type {StructStore}
         */
        var restStructs = new StructStore();
        var missingSV = new Map();
        /**
         * @param {number} client
         * @param {number} clock
         */
        var updateMissingSv = function updateMissingSv(client, clock) {
          var mclock = missingSV.get(client);
          if (mclock == null || mclock > clock) {
            missingSV.set(client, clock);
          }
        };
        /**
         * @type {GC|Item}
         */
        var stackHead = /** @type {any} */curStructsTarget.refs[/** @type {any} */curStructsTarget.i++];
        // caching the state because it is used very often
        var state = new Map();
        var addStackToRestSS = function addStackToRestSS() {
          var _loop2 = function _loop2() {
            var item = _stack[_i6];
            var client = item.id.client;
            var unapplicableItems = clientsStructRefs.get(client);
            if (unapplicableItems) {
              // decrement because we weren't able to apply previous operation
              unapplicableItems.i--;
              restStructs.clients.set(client, unapplicableItems.refs.slice(unapplicableItems.i));
              clientsStructRefs.delete(client);
              unapplicableItems.i = 0;
              unapplicableItems.refs = [];
            } else {
              // item was the last item on clientsStructRefs and the field was already cleared. Add item to restStructs and continue
              restStructs.clients.set(client, [item]);
            }
            // remove client from clientsStructRefsIds to prevent users from applying the same update again
            clientsStructRefsIds = clientsStructRefsIds.filter(function (c) {
              return c !== client;
            });
          };
          for (var _i6 = 0, _stack = stack; _i6 < _stack.length; _i6++) {
            _loop2();
          }
          stack.length = 0;
        };

        // iterate over all struct readers until we are done
        while (true) {
          if (stackHead.constructor !== Skip) {
            var localClock = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(state, stackHead.id.client, function () {
              return _getState(store, stackHead.id.client);
            });
            var offset = localClock - stackHead.id.clock;
            if (offset < 0) {
              // update from the same client is missing
              stack.push(stackHead);
              updateMissingSv(stackHead.id.client, stackHead.id.clock - 1);
              // hid a dead wall, add all items from stack to restSS
              addStackToRestSS();
            } else {
              var missing = stackHead.getMissing(transaction, store);
              if (missing !== null) {
                stack.push(stackHead);
                // get the struct reader that has the missing struct
                /**
                 * @type {{ refs: Array<GC|Item>, i: number }}
                 */
                var structRefs = clientsStructRefs.get( /** @type {number} */missing) || {
                  refs: [],
                  i: 0
                };
                if (structRefs.refs.length === structRefs.i) {
                  // This update message causally depends on another update message that doesn't exist yet
                  updateMissingSv( /** @type {number} */missing, _getState(store, missing));
                  addStackToRestSS();
                } else {
                  stackHead = structRefs.refs[structRefs.i++];
                  continue;
                }
              } else if (offset === 0 || offset < stackHead.length) {
                // all fine, apply the stackhead
                stackHead.integrate(transaction, offset);
                state.set(stackHead.id.client, stackHead.id.clock + stackHead.length);
              }
            }
          }
          // iterate to next stackHead
          if (stack.length > 0) {
            stackHead = /** @type {GC|Item} */stack.pop();
          } else if (curStructsTarget !== null && curStructsTarget.i < curStructsTarget.refs.length) {
            stackHead = /** @type {GC|Item} */curStructsTarget.refs[curStructsTarget.i++];
          } else {
            curStructsTarget = getNextStructTarget();
            if (curStructsTarget === null) {
              // we are done!
              break;
            } else {
              stackHead = /** @type {GC|Item} */curStructsTarget.refs[curStructsTarget.i++];
            }
          }
        }
        if (restStructs.clients.size > 0) {
          var encoder = new UpdateEncoderV2();
          writeClientsStructs(encoder, restStructs, new Map());
          // write empty deleteset
          // writeDeleteSet(encoder, new DeleteSet())
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0); // => no need for an extra function call, just write 0 deletes
          return {
            missing: missingSV,
            update: encoder.toUint8Array()
          };
        }
        return null;
      };

      /**
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       * @param {Transaction} transaction
       *
       * @private
       * @function
       */
      var writeStructsFromTransaction = function writeStructsFromTransaction(encoder, transaction) {
        return writeClientsStructs(encoder, transaction.doc.store, transaction.beforeState);
      };

      /**
       * Read and apply a document update.
       *
       * This function has the same effect as `applyUpdate` but accepts an decoder.
       *
       * @param {decoding.Decoder} decoder
       * @param {Doc} ydoc
       * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
       * @param {UpdateDecoderV1 | UpdateDecoderV2} [structDecoder]
       *
       * @function
       */
      var _readUpdateV = function _readUpdateV(decoder, ydoc, transactionOrigin) {
        var structDecoder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new UpdateDecoderV2(decoder);
        return _transact(ydoc, function (transaction) {
          // force that transaction.local is set to non-local
          transaction.local = false;
          var retry = false;
          var doc = transaction.doc;
          var store = doc.store;
          // let start = performance.now()
          var ss = readClientsStructRefs(structDecoder, doc);
          // console.log('time to read structs: ', performance.now() - start) // @todo remove
          // start = performance.now()
          // console.log('time to merge: ', performance.now() - start) // @todo remove
          // start = performance.now()
          var restStructs = integrateStructs(transaction, store, ss);
          var pending = store.pendingStructs;
          if (pending) {
            // check if we can apply something
            var _iterator7 = _createForOfIteratorHelper(pending.missing),
              _step7;
            try {
              for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                var _step7$value = _slicedToArray(_step7.value, 2),
                  _client = _step7$value[0],
                  _clock2 = _step7$value[1];
                if (_clock2 < _getState(store, _client)) {
                  retry = true;
                  break;
                }
              }
            } catch (err) {
              _iterator7.e(err);
            } finally {
              _iterator7.f();
            }
            if (restStructs) {
              // merge restStructs into store.pending
              var _iterator8 = _createForOfIteratorHelper(restStructs.missing),
                _step8;
              try {
                for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
                  var _step8$value = _slicedToArray(_step8.value, 2),
                    client = _step8$value[0],
                    clock = _step8$value[1];
                  var mclock = pending.missing.get(client);
                  if (mclock == null || mclock > clock) {
                    pending.missing.set(client, clock);
                  }
                }
              } catch (err) {
                _iterator8.e(err);
              } finally {
                _iterator8.f();
              }
              pending.update = _mergeUpdatesV([pending.update, restStructs.update]);
            }
          } else {
            store.pendingStructs = restStructs;
          }
          // console.log('time to integrate: ', performance.now() - start) // @todo remove
          // start = performance.now()
          var dsRest = readAndApplyDeleteSet(structDecoder, transaction, store);
          if (store.pendingDs) {
            // @todo we could make a lower-bound state-vector check as we do above
            var pendingDSUpdate = new UpdateDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(store.pendingDs));
            lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(pendingDSUpdate.restDecoder); // read 0 structs, because we only encode deletes in pendingdsupdate
            var dsRest2 = readAndApplyDeleteSet(pendingDSUpdate, transaction, store);
            if (dsRest && dsRest2) {
              // case 1: ds1 != null && ds2 != null
              store.pendingDs = _mergeUpdatesV([dsRest, dsRest2]);
            } else {
              // case 2: ds1 != null
              // case 3: ds2 != null
              // case 4: ds1 == null && ds2 == null
              store.pendingDs = dsRest || dsRest2;
            }
          } else {
            // Either dsRest == null && pendingDs == null OR dsRest != null
            store.pendingDs = dsRest;
          }
          // console.log('time to cleanup: ', performance.now() - start) // @todo remove
          // start = performance.now()

          // console.log('time to resume delete readers: ', performance.now() - start) // @todo remove
          // start = performance.now()
          if (retry) {
            var update = /** @type {{update: Uint8Array}} */store.pendingStructs.update;
            store.pendingStructs = null;
            _applyUpdateV(transaction.doc, update);
          }
        }, transactionOrigin, false);
      };

      /**
       * Read and apply a document update.
       *
       * This function has the same effect as `applyUpdate` but accepts an decoder.
       *
       * @param {decoding.Decoder} decoder
       * @param {Doc} ydoc
       * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
       *
       * @function
       */
      var _readUpdate = function _readUpdate(decoder, ydoc, transactionOrigin) {
        return _readUpdateV(decoder, ydoc, transactionOrigin, new UpdateDecoderV1(decoder));
      };

      /**
       * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
       *
       * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
       *
       * @param {Doc} ydoc
       * @param {Uint8Array} update
       * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
       * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
       *
       * @function
       */
      var _applyUpdateV = function _applyUpdateV(ydoc, update, transactionOrigin) {
        var YDecoder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : UpdateDecoderV2;
        var decoder = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update);
        _readUpdateV(decoder, ydoc, transactionOrigin, new YDecoder(decoder));
      };

      /**
       * Apply a document update created by, for example, `y.on('update', update => ..)` or `update = encodeStateAsUpdate()`.
       *
       * This function has the same effect as `readUpdate` but accepts an Uint8Array instead of a Decoder.
       *
       * @param {Doc} ydoc
       * @param {Uint8Array} update
       * @param {any} [transactionOrigin] This will be stored on `transaction.origin` and `.on('update', (update, origin))`
       *
       * @function
       */
      var _applyUpdate = function _applyUpdate(ydoc, update, transactionOrigin) {
        return _applyUpdateV(ydoc, update, transactionOrigin, UpdateDecoderV1);
      };

      /**
       * Write all the document as a single update message. If you specify the state of the remote client (`targetStateVector`) it will
       * only write the operations that are missing.
       *
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       * @param {Doc} doc
       * @param {Map<number,number>} [targetStateVector] The state of the target that receives the update. Leave empty to write all known structs
       *
       * @function
       */
      var writeStateAsUpdate = function writeStateAsUpdate(encoder, doc) {
        var targetStateVector = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Map();
        writeClientsStructs(encoder, doc.store, targetStateVector);
        writeDeleteSet(encoder, _createDeleteSetFromStructStore(doc.store));
      };

      /**
       * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
       * only write the operations that are missing.
       *
       * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
       *
       * @param {Doc} doc
       * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
       * @param {UpdateEncoderV1 | UpdateEncoderV2} [encoder]
       * @return {Uint8Array}
       *
       * @function
       */
      var _encodeStateAsUpdateV = function _encodeStateAsUpdateV(doc) {
        var encodedTargetStateVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Uint8Array([0]);
        var encoder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new UpdateEncoderV2();
        var targetStateVector = _decodeStateVector(encodedTargetStateVector);
        writeStateAsUpdate(encoder, doc, targetStateVector);
        var updates = [encoder.toUint8Array()];
        // also add the pending updates (if there are any)
        if (doc.store.pendingDs) {
          updates.push(doc.store.pendingDs);
        }
        if (doc.store.pendingStructs) {
          updates.push(_diffUpdateV(doc.store.pendingStructs.update, encodedTargetStateVector));
        }
        if (updates.length > 1) {
          if (encoder.constructor === _UpdateEncoderV) {
            return _mergeUpdates(updates.map(function (update, i) {
              return i === 0 ? update : _convertUpdateFormatV2ToV(update);
            }));
          } else if (encoder.constructor === UpdateEncoderV2) {
            return _mergeUpdatesV(updates);
          }
        }
        return updates[0];
      };

      /**
       * Write all the document as a single update message that can be applied on the remote document. If you specify the state of the remote client (`targetState`) it will
       * only write the operations that are missing.
       *
       * Use `writeStateAsUpdate` instead if you are working with lib0/encoding.js#Encoder
       *
       * @param {Doc} doc
       * @param {Uint8Array} [encodedTargetStateVector] The state of the target that receives the update. Leave empty to write all known structs
       * @return {Uint8Array}
       *
       * @function
       */
      var _encodeStateAsUpdate = function _encodeStateAsUpdate(doc, encodedTargetStateVector) {
        return _encodeStateAsUpdateV(doc, encodedTargetStateVector, new _UpdateEncoderV());
      };

      /**
       * Read state vector from Decoder and return as Map
       *
       * @param {DSDecoderV1 | DSDecoderV2} decoder
       * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
       *
       * @function
       */
      var readStateVector = function readStateVector(decoder) {
        var ss = new Map();
        var ssLength = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
        for (var i = 0; i < ssLength; i++) {
          var client = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          var clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
          ss.set(client, clock);
        }
        return ss;
      };

      /**
       * Read decodedState and return State as Map.
       *
       * @param {Uint8Array} decodedState
       * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
       *
       * @function
       */
      // export const decodeStateVectorV2 = decodedState => readStateVector(new DSDecoderV2(decoding.createDecoder(decodedState)))

      /**
       * Read decodedState and return State as Map.
       *
       * @param {Uint8Array} decodedState
       * @return {Map<number,number>} Maps `client` to the number next expected `clock` from that client.
       *
       * @function
       */
      var _decodeStateVector = function _decodeStateVector(decodedState) {
        return readStateVector(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(decodedState)));
      };

      /**
       * @param {DSEncoderV1 | DSEncoderV2} encoder
       * @param {Map<number,number>} sv
       * @function
       */
      var writeStateVector = function writeStateVector(encoder, sv) {
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, sv.size);
        lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(sv.entries()).sort(function (a, b) {
          return b[0] - a[0];
        }).forEach(function (_ref8) {
          var _ref9 = _slicedToArray(_ref8, 2),
            client = _ref9[0],
            clock = _ref9[1];
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, client); // @todo use a special client decoder that is based on mapping
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, clock);
        });
        return encoder;
      };

      /**
       * @param {DSEncoderV1 | DSEncoderV2} encoder
       * @param {Doc} doc
       *
       * @function
       */
      var writeDocumentStateVector = function writeDocumentStateVector(encoder, doc) {
        return writeStateVector(encoder, getStateVector(doc.store));
      };

      /**
       * Encode State as Uint8Array.
       *
       * @param {Doc|Map<number,number>} doc
       * @param {DSEncoderV1 | DSEncoderV2} [encoder]
       * @return {Uint8Array}
       *
       * @function
       */
      var encodeStateVectorV2 = function encodeStateVectorV2(doc) {
        var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new DSEncoderV2();
        if (doc instanceof Map) {
          writeStateVector(encoder, doc);
        } else {
          writeDocumentStateVector(encoder, doc);
        }
        return encoder.toUint8Array();
      };

      /**
       * Encode State as Uint8Array.
       *
       * @param {Doc|Map<number,number>} doc
       * @return {Uint8Array}
       *
       * @function
       */
      var _encodeStateVector = function _encodeStateVector(doc) {
        return encodeStateVectorV2(doc, new DSEncoderV1());
      };

      /**
       * General event handler implementation.
       *
       * @template ARG0, ARG1
       *
       * @private
       */
      var EventHandler = /*#__PURE__*/_createClass(function EventHandler() {
        _classCallCheck(this, EventHandler);
        /**
         * @type {Array<function(ARG0, ARG1):void>}
         */
        this.l = [];
      });
      /**
       * @template ARG0,ARG1
       * @returns {EventHandler<ARG0,ARG1>}
       *
       * @private
       * @function
       */
      var createEventHandler = function createEventHandler() {
        return new EventHandler();
      };

      /**
       * Adds an event listener that is called when
       * {@link EventHandler#callEventListeners} is called.
       *
       * @template ARG0,ARG1
       * @param {EventHandler<ARG0,ARG1>} eventHandler
       * @param {function(ARG0,ARG1):void} f The event handler.
       *
       * @private
       * @function
       */
      var addEventHandlerListener = function addEventHandlerListener(eventHandler, f) {
        return eventHandler.l.push(f);
      };

      /**
       * Removes an event listener.
       *
       * @template ARG0,ARG1
       * @param {EventHandler<ARG0,ARG1>} eventHandler
       * @param {function(ARG0,ARG1):void} f The event handler that was added with
       *                     {@link EventHandler#addEventListener}
       *
       * @private
       * @function
       */
      var removeEventHandlerListener = function removeEventHandlerListener(eventHandler, f) {
        var l = eventHandler.l;
        var len = l.length;
        eventHandler.l = l.filter(function (g) {
          return f !== g;
        });
        if (len === eventHandler.l.length) {
          console.error('[yjs] Tried to remove event handler that doesn\'t exist.');
        }
      };

      /**
       * Call all event listeners that were added via
       * {@link EventHandler#addEventListener}.
       *
       * @template ARG0,ARG1
       * @param {EventHandler<ARG0,ARG1>} eventHandler
       * @param {ARG0} arg0
       * @param {ARG1} arg1
       *
       * @private
       * @function
       */
      var callEventHandlerListeners = function callEventHandlerListeners(eventHandler, arg0, arg1) {
        return lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll(eventHandler.l, [arg0, arg1]);
      };
      var _ID = /*#__PURE__*/_createClass(
      /**
       * @param {number} client client id
       * @param {number} clock unique per client id, continuous number
       */
      function _ID(client, clock) {
        _classCallCheck(this, _ID);
        /**
         * Client id
         * @type {number}
         */
        this.client = client;
        /**
         * unique per client id, continuous number
         * @type {number}
         */
        this.clock = clock;
      });
      /**
       * @param {ID | null} a
       * @param {ID | null} b
       * @return {boolean}
       *
       * @function
       */
      var _compareIDs = function _compareIDs(a, b) {
        return a === b || a !== null && b !== null && a.client === b.client && a.clock === b.clock;
      };

      /**
       * @param {number} client
       * @param {number} clock
       *
       * @private
       * @function
       */
      var _createID = function _createID(client, clock) {
        return new _ID(client, clock);
      };

      /**
       * @param {encoding.Encoder} encoder
       * @param {ID} id
       *
       * @private
       * @function
       */
      var writeID = function writeID(encoder, id) {
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.client);
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, id.clock);
      };

      /**
       * Read ID.
       * * If first varUint read is 0xFFFFFF a RootID is returned.
       * * Otherwise an ID is returned
       *
       * @param {decoding.Decoder} decoder
       * @return {ID}
       *
       * @private
       * @function
       */
      var readID = function readID(decoder) {
        return _createID(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder), lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder));
      };

      /**
       * The top types are mapped from y.share.get(keyname) => type.
       * `type` does not store any information about the `keyname`.
       * This function finds the correct `keyname` for `type` and throws otherwise.
       *
       * @param {AbstractType<any>} type
       * @return {string}
       *
       * @private
       * @function
       */
      var _findRootTypeKey = function _findRootTypeKey(type) {
        // @ts-ignore _y must be defined, otherwise unexpected case
        var _iterator9 = _createForOfIteratorHelper(type.doc.share.entries()),
          _step9;
        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var _step9$value = _slicedToArray(_step9.value, 2),
              key = _step9$value[0],
              value = _step9$value[1];
            if (value === type) {
              return key;
            }
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
      };

      /**
       * Check if `parent` is a parent of `child`.
       *
       * @param {AbstractType<any>} parent
       * @param {Item|null} child
       * @return {Boolean} Whether `parent` is a parent of `child`.
       *
       * @private
       * @function
       */
      var _isParentOf2 = function _isParentOf2(parent, child) {
        while (child !== null) {
          if (child.parent === parent) {
            return true;
          }
          child = /** @type {AbstractType<any>} */child.parent._item;
        }
        return false;
      };

      /**
       * Convenient helper to log type information.
       *
       * Do not use in productive systems as the output can be immense!
       *
       * @param {AbstractType<any>} type
       */
      var _logType = function _logType(type) {
        var res = [];
        var n = type._start;
        while (n) {
          res.push(n);
          n = n.right;
        }
        console.log('Children: ', res);
        console.log('Children content: ', res.filter(function (m) {
          return !m.deleted;
        }).map(function (m) {
          return m.content;
        }));
      };
      var _PermanentUserData = /*#__PURE__*/function () {
        /**
         * @param {Doc} doc
         * @param {YMap<any>} [storeType]
         */
        function _PermanentUserData(doc) {
          var _this25 = this;
          var storeType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : doc.getMap('users');
          _classCallCheck(this, _PermanentUserData);
          /**
           * @type {Map<string,DeleteSet>}
           */
          var dss = new Map();
          this.yusers = storeType;
          this.doc = doc;
          /**
           * Maps from clientid to userDescription
           *
           * @type {Map<number,string>}
           */
          this.clients = new Map();
          this.dss = dss;
          /**
           * @param {YMap<any>} user
           * @param {string} userDescription
           */
          var initUser = function initUser(user, userDescription) {
            /**
             * @type {YArray<Uint8Array>}
             */
            var ds = user.get('ds');
            var ids = user.get('ids');
            var addClientId = /** @param {number} clientid */function addClientId(clientid) {
              return _this25.clients.set(clientid, userDescription);
            };
            ds.observe( /** @param {YArrayEvent<any>} event */function (event) {
              event.changes.added.forEach(function (item) {
                item.content.getContent().forEach(function (encodedDs) {
                  if (encodedDs instanceof Uint8Array) {
                    _this25.dss.set(userDescription, mergeDeleteSets([_this25.dss.get(userDescription) || _createDeleteSet(), readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)))]));
                  }
                });
              });
            });
            _this25.dss.set(userDescription, mergeDeleteSets(ds.map(function (encodedDs) {
              return readDeleteSet(new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(encodedDs)));
            })));
            ids.observe( /** @param {YArrayEvent<any>} event */function (event) {
              return event.changes.added.forEach(function (item) {
                return item.content.getContent().forEach(addClientId);
              });
            });
            ids.forEach(addClientId);
          };
          // observe users
          storeType.observe(function (event) {
            event.keysChanged.forEach(function (userDescription) {
              return initUser(storeType.get(userDescription), userDescription);
            });
          });
          // add intial data
          storeType.forEach(initUser);
        }

        /**
         * @param {Doc} doc
         * @param {number} clientid
         * @param {string} userDescription
         * @param {Object} conf
         * @param {function(Transaction, DeleteSet):boolean} [conf.filter]
         */
        _createClass(_PermanentUserData, [{
          key: "setUserMapping",
          value: function setUserMapping(doc, clientid, userDescription) {
            var _this26 = this;
            var _ref10 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},
              _ref10$filter = _ref10.filter,
              filter = _ref10$filter === void 0 ? function () {
                return true;
              } : _ref10$filter;
            var users = this.yusers;
            var user = users.get(userDescription);
            if (!user) {
              user = new YMap();
              user.set('ids', new YArray());
              user.set('ds', new YArray());
              users.set(userDescription, user);
            }
            user.get('ids').push([clientid]);
            users.observe(function (_event) {
              setTimeout(function () {
                var userOverwrite = users.get(userDescription);
                if (userOverwrite !== user) {
                  // user was overwritten, port all data over to the next user object
                  // @todo Experiment with Y.Sets here
                  user = userOverwrite;
                  // @todo iterate over old type
                  _this26.clients.forEach(function (_userDescription, clientid) {
                    if (userDescription === _userDescription) {
                      user.get('ids').push([clientid]);
                    }
                  });
                  var encoder = new DSEncoderV1();
                  var ds = _this26.dss.get(userDescription);
                  if (ds) {
                    writeDeleteSet(encoder, ds);
                    user.get('ds').push([encoder.toUint8Array()]);
                  }
                }
              }, 0);
            });
            doc.on('afterTransaction', /** @param {Transaction} transaction */function (transaction) {
              setTimeout(function () {
                var yds = user.get('ds');
                var ds = transaction.deleteSet;
                if (transaction.local && ds.clients.size > 0 && filter(transaction, ds)) {
                  var encoder = new DSEncoderV1();
                  writeDeleteSet(encoder, ds);
                  yds.push([encoder.toUint8Array()]);
                }
              });
            });
          }

          /**
           * @param {number} clientid
           * @return {any}
           */
        }, {
          key: "getUserByClientId",
          value: function getUserByClientId(clientid) {
            return this.clients.get(clientid) || null;
          }

          /**
           * @param {ID} id
           * @return {string | null}
           */
        }, {
          key: "getUserByDeletedId",
          value: function getUserByDeletedId(id) {
            var _iterator10 = _createForOfIteratorHelper(this.dss.entries()),
              _step10;
            try {
              for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
                var _step10$value = _slicedToArray(_step10.value, 2),
                  userDescription = _step10$value[0],
                  ds = _step10$value[1];
                if (_isDeleted(ds, id)) {
                  return userDescription;
                }
              }
            } catch (err) {
              _iterator10.e(err);
            } finally {
              _iterator10.f();
            }
            return null;
          }
        }]);
        return _PermanentUserData;
      }();
      /**
       * A relative position is based on the Yjs model and is not affected by document changes.
       * E.g. If you place a relative position before a certain character, it will always point to this character.
       * If you place a relative position at the end of a type, it will always point to the end of the type.
       *
       * A numeric position is often unsuited for user selections, because it does not change when content is inserted
       * before or after.
       *
       * ```Insert(0, 'x')('a|bc') = 'xa|bc'``` Where | is the relative position.
       *
       * One of the properties must be defined.
       *
       * @example
       *   // Current cursor position is at position 10
       *   const relativePosition = createRelativePositionFromIndex(yText, 10)
       *   // modify yText
       *   yText.insert(0, 'abc')
       *   yText.delete(3, 10)
       *   // Compute the cursor position
       *   const absolutePosition = createAbsolutePositionFromRelativePosition(y, relativePosition)
       *   absolutePosition.type === yText // => true
       *   console.log('cursor location is ' + absolutePosition.index) // => cursor location is 3
       *
       */
      var _RelativePosition = /*#__PURE__*/_createClass(
      /**
       * @param {ID|null} type
       * @param {string|null} tname
       * @param {ID|null} item
       * @param {number} assoc
       */
      function _RelativePosition(type, tname, item) {
        var assoc = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;
        _classCallCheck(this, _RelativePosition);
        /**
         * @type {ID|null}
         */
        this.type = type;
        /**
         * @type {string|null}
         */
        this.tname = tname;
        /**
         * @type {ID | null}
         */
        this.item = item;
        /**
         * A relative position is associated to a specific character. By default
         * assoc >= 0, the relative position is associated to the character
         * after the meant position.
         * I.e. position 1 in 'ab' is associated to character 'b'.
         *
         * If assoc < 0, then the relative position is associated to the caharacter
         * before the meant position.
         *
         * @type {number}
         */
        this.assoc = assoc;
      });
      /**
       * @param {RelativePosition} rpos
       * @return {any}
       */
      var _relativePositionToJSON = function _relativePositionToJSON(rpos) {
        var json = {};
        if (rpos.type) {
          json.type = rpos.type;
        }
        if (rpos.tname) {
          json.tname = rpos.tname;
        }
        if (rpos.item) {
          json.item = rpos.item;
        }
        if (rpos.assoc != null) {
          json.assoc = rpos.assoc;
        }
        return json;
      };

      /**
       * @param {any} json
       * @return {RelativePosition}
       *
       * @function
       */
      var _createRelativePositionFromJSON = function _createRelativePositionFromJSON(json) {
        return new _RelativePosition(json.type == null ? null : _createID(json.type.client, json.type.clock), json.tname || null, json.item == null ? null : _createID(json.item.client, json.item.clock), json.assoc == null ? 0 : json.assoc);
      };
      var _AbsolutePosition = /*#__PURE__*/_createClass(
      /**
       * @param {AbstractType<any>} type
       * @param {number} index
       * @param {number} [assoc]
       */
      function _AbsolutePosition(type, index) {
        var assoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        _classCallCheck(this, _AbsolutePosition);
        /**
         * @type {AbstractType<any>}
         */
        this.type = type;
        /**
         * @type {number}
         */
        this.index = index;
        this.assoc = assoc;
      });
      /**
       * @param {AbstractType<any>} type
       * @param {number} index
       * @param {number} [assoc]
       *
       * @function
       */
      var createAbsolutePosition = function createAbsolutePosition(type, index) {
        var assoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        return new _AbsolutePosition(type, index, assoc);
      };

      /**
       * @param {AbstractType<any>} type
       * @param {ID|null} item
       * @param {number} [assoc]
       *
       * @function
       */
      var createRelativePosition = function createRelativePosition(type, item, assoc) {
        var typeid = null;
        var tname = null;
        if (type._item === null) {
          tname = _findRootTypeKey(type);
        } else {
          typeid = _createID(type._item.id.client, type._item.id.clock);
        }
        return new _RelativePosition(typeid, tname, item, assoc);
      };

      /**
       * Create a relativePosition based on a absolute position.
       *
       * @param {AbstractType<any>} type The base type (e.g. YText or YArray).
       * @param {number} index The absolute position.
       * @param {number} [assoc]
       * @return {RelativePosition}
       *
       * @function
       */
      var _createRelativePositionFromTypeIndex = function _createRelativePositionFromTypeIndex(type, index) {
        var assoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        var t = type._start;
        if (assoc < 0) {
          // associated to the left character or the beginning of a type, increment index if possible.
          if (index === 0) {
            return createRelativePosition(type, null, assoc);
          }
          index--;
        }
        while (t !== null) {
          if (!t.deleted && t.countable) {
            if (t.length > index) {
              // case 1: found position somewhere in the linked list
              return createRelativePosition(type, _createID(t.id.client, t.id.clock + index), assoc);
            }
            index -= t.length;
          }
          if (t.right === null && assoc < 0) {
            // left-associated position, return last available id
            return createRelativePosition(type, t.lastId, assoc);
          }
          t = t.right;
        }
        return createRelativePosition(type, null, assoc);
      };

      /**
       * @param {encoding.Encoder} encoder
       * @param {RelativePosition} rpos
       *
       * @function
       */
      var writeRelativePosition = function writeRelativePosition(encoder, rpos) {
        var type = rpos.type,
          tname = rpos.tname,
          item = rpos.item,
          assoc = rpos.assoc;
        if (item !== null) {
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder, 0);
          writeID(encoder, item);
        } else if (tname !== null) {
          // case 2: found position at the end of the list and type is stored in y.share
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 1);
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarString(encoder, tname);
        } else if (type !== null) {
          // case 3: found position at the end of the list and type is attached to an item
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8(encoder, 2);
          writeID(encoder, type);
        } else {
          throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
        }
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarInt(encoder, assoc);
        return encoder;
      };

      /**
       * @param {RelativePosition} rpos
       * @return {Uint8Array}
       */
      var _encodeRelativePosition = function _encodeRelativePosition(rpos) {
        var encoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
        writeRelativePosition(encoder, rpos);
        return lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(encoder);
      };

      /**
       * @param {decoding.Decoder} decoder
       * @return {RelativePosition}
       *
       * @function
       */
      var readRelativePosition = function readRelativePosition(decoder) {
        var type = null;
        var tname = null;
        var itemID = null;
        switch (lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder)) {
          case 0:
            // case 1: found position somewhere in the linked list
            itemID = readID(decoder);
            break;
          case 1:
            // case 2: found position at the end of the list and type is stored in y.share
            tname = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarString(decoder);
            break;
          case 2:
            {
              // case 3: found position at the end of the list and type is attached to an item
              type = readID(decoder);
            }
        }
        var assoc = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.hasContent(decoder) ? lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarInt(decoder) : 0;
        return new _RelativePosition(type, tname, itemID, assoc);
      };

      /**
       * @param {Uint8Array} uint8Array
       * @return {RelativePosition}
       */
      var _decodeRelativePosition = function _decodeRelativePosition(uint8Array) {
        return readRelativePosition(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(uint8Array));
      };

      /**
       * @param {RelativePosition} rpos
       * @param {Doc} doc
       * @return {AbsolutePosition|null}
       *
       * @function
       */
      var _createAbsolutePositionFromRelativePosition = function _createAbsolutePositionFromRelativePosition(rpos, doc) {
        var store = doc.store;
        var rightID = rpos.item;
        var typeID = rpos.type;
        var tname = rpos.tname;
        var assoc = rpos.assoc;
        var type = null;
        var index = 0;
        if (rightID !== null) {
          if (_getState(store, rightID.client) <= rightID.clock) {
            return null;
          }
          var res = followRedone(store, rightID);
          var right = res.item;
          if (!(right instanceof _Item)) {
            return null;
          }
          type = /** @type {AbstractType<any>} */right.parent;
          if (type._item === null || !type._item.deleted) {
            index = right.deleted || !right.countable ? 0 : res.diff + (assoc >= 0 ? 0 : 1); // adjust position based on left association if necessary
            var n = right.left;
            while (n !== null) {
              if (!n.deleted && n.countable) {
                index += n.length;
              }
              n = n.left;
            }
          }
        } else {
          if (tname !== null) {
            type = doc.get(tname);
          } else if (typeID !== null) {
            if (_getState(store, typeID.client) <= typeID.clock) {
              // type does not exist yet
              return null;
            }
            var _followRedone = followRedone(store, typeID),
              item = _followRedone.item;
            if (item instanceof _Item && item.content instanceof _ContentType) {
              type = item.content.type;
            } else {
              // struct is garbage collected
              return null;
            }
          } else {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
          }
          if (assoc >= 0) {
            index = type._length;
          } else {
            index = 0;
          }
        }
        return createAbsolutePosition(type, index, rpos.assoc);
      };

      /**
       * @param {RelativePosition|null} a
       * @param {RelativePosition|null} b
       * @return {boolean}
       *
       * @function
       */
      var _compareRelativePositions = function _compareRelativePositions(a, b) {
        return a === b || a !== null && b !== null && a.tname === b.tname && _compareIDs(a.item, b.item) && _compareIDs(a.type, b.type) && a.assoc === b.assoc;
      };
      var _Snapshot = /*#__PURE__*/_createClass(
      /**
       * @param {DeleteSet} ds
       * @param {Map<number,number>} sv state map
       */
      function _Snapshot(ds, sv) {
        _classCallCheck(this, _Snapshot);
        /**
         * @type {DeleteSet}
         */
        this.ds = ds;
        /**
         * State Map
         * @type {Map<number,number>}
         */
        this.sv = sv;
      });
      /**
       * @param {Snapshot} snap1
       * @param {Snapshot} snap2
       * @return {boolean}
       */
      var _equalSnapshots = function _equalSnapshots(snap1, snap2) {
        var ds1 = snap1.ds.clients;
        var ds2 = snap2.ds.clients;
        var sv1 = snap1.sv;
        var sv2 = snap2.sv;
        if (sv1.size !== sv2.size || ds1.size !== ds2.size) {
          return false;
        }
        var _iterator11 = _createForOfIteratorHelper(sv1.entries()),
          _step11;
        try {
          for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
            var _step11$value = _slicedToArray(_step11.value, 2),
              key = _step11$value[0],
              value = _step11$value[1];
            if (sv2.get(key) !== value) {
              return false;
            }
          }
        } catch (err) {
          _iterator11.e(err);
        } finally {
          _iterator11.f();
        }
        var _iterator12 = _createForOfIteratorHelper(ds1.entries()),
          _step12;
        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var _step12$value = _slicedToArray(_step12.value, 2),
              client = _step12$value[0],
              dsitems1 = _step12$value[1];
            var dsitems2 = ds2.get(client) || [];
            if (dsitems1.length !== dsitems2.length) {
              return false;
            }
            for (var i = 0; i < dsitems1.length; i++) {
              var dsitem1 = dsitems1[i];
              var dsitem2 = dsitems2[i];
              if (dsitem1.clock !== dsitem2.clock || dsitem1.len !== dsitem2.len) {
                return false;
              }
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
        return true;
      };

      /**
       * @param {Snapshot} snapshot
       * @param {DSEncoderV1 | DSEncoderV2} [encoder]
       * @return {Uint8Array}
       */
      var _encodeSnapshotV = function _encodeSnapshotV(snapshot) {
        var encoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new DSEncoderV2();
        writeDeleteSet(encoder, snapshot.ds);
        writeStateVector(encoder, snapshot.sv);
        return encoder.toUint8Array();
      };

      /**
       * @param {Snapshot} snapshot
       * @return {Uint8Array}
       */
      var _encodeSnapshot = function _encodeSnapshot(snapshot) {
        return _encodeSnapshotV(snapshot, new DSEncoderV1());
      };

      /**
       * @param {Uint8Array} buf
       * @param {DSDecoderV1 | DSDecoderV2} [decoder]
       * @return {Snapshot}
       */
      var _decodeSnapshotV = function _decodeSnapshotV(buf) {
        var decoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new DSDecoderV2(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf));
        return new _Snapshot(readDeleteSet(decoder), readStateVector(decoder));
      };

      /**
       * @param {Uint8Array} buf
       * @return {Snapshot}
       */
      var _decodeSnapshot = function _decodeSnapshot(buf) {
        return _decodeSnapshotV(buf, new DSDecoderV1(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(buf)));
      };

      /**
       * @param {DeleteSet} ds
       * @param {Map<number,number>} sm
       * @return {Snapshot}
       */
      var _createSnapshot = function _createSnapshot(ds, sm) {
        return new _Snapshot(ds, sm);
      };
      var _emptySnapshot = _createSnapshot(_createDeleteSet(), new Map());

      /**
       * @param {Doc} doc
       * @return {Snapshot}
       */
      var _snapshot = function _snapshot(doc) {
        return _createSnapshot(_createDeleteSetFromStructStore(doc.store), getStateVector(doc.store));
      };

      /**
       * @param {Item} item
       * @param {Snapshot|undefined} snapshot
       *
       * @protected
       * @function
       */
      var isVisible = function isVisible(item, snapshot) {
        return snapshot === undefined ? !item.deleted : snapshot.sv.has(item.id.client) && (snapshot.sv.get(item.id.client) || 0) > item.id.clock && !_isDeleted(snapshot.ds, item.id);
      };

      /**
       * @param {Transaction} transaction
       * @param {Snapshot} snapshot
       */
      var splitSnapshotAffectedStructs = function splitSnapshotAffectedStructs(transaction, snapshot) {
        var meta = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.meta, splitSnapshotAffectedStructs, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create);
        var store = transaction.doc.store;
        // check if we already split for this snapshot
        if (!meta.has(snapshot)) {
          snapshot.sv.forEach(function (clock, client) {
            if (clock < _getState(store, client)) {
              getItemCleanStart(transaction, _createID(client, clock));
            }
          });
          _iterateDeletedStructs(transaction, snapshot.ds, function (_item) {});
          meta.add(snapshot);
        }
      };

      /**
       * @example
       *  const ydoc = new Y.Doc({ gc: false })
       *  ydoc.getText().insert(0, 'world!')
       *  const snapshot = Y.snapshot(ydoc)
       *  ydoc.getText().insert(0, 'hello ')
       *  const restored = Y.createDocFromSnapshot(ydoc, snapshot)
       *  assert(restored.getText().toString() === 'world!')
       *
       * @param {Doc} originDoc
       * @param {Snapshot} snapshot
       * @param {Doc} [newDoc] Optionally, you may define the Yjs document that receives the data from originDoc
       * @return {Doc}
       */
      var _createDocFromSnapshot = function _createDocFromSnapshot(originDoc, snapshot) {
        var newDoc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new _Doc();
        if (originDoc.gc) {
          // we should not try to restore a GC-ed document, because some of the restored items might have their content deleted
          throw new Error('Garbage-collection must be disabled in `originDoc`!');
        }
        var sv = snapshot.sv,
          ds = snapshot.ds;
        var encoder = new UpdateEncoderV2();
        originDoc.transact(function (transaction) {
          var size = 0;
          sv.forEach(function (clock) {
            if (clock > 0) {
              size++;
            }
          });
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, size);
          // splitting the structs before writing them to the encoder
          var _iterator13 = _createForOfIteratorHelper(sv),
            _step13;
          try {
            for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
              var _step13$value = _slicedToArray(_step13.value, 2),
                client = _step13$value[0],
                clock = _step13$value[1];
              if (clock === 0) {
                continue;
              }
              if (clock < _getState(originDoc.store, client)) {
                getItemCleanStart(transaction, _createID(client, clock));
              }
              var structs = originDoc.store.clients.get(client) || [];
              var lastStructIndex = _findIndexSS(structs, clock - 1);
              // write # encoded structs
              lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, lastStructIndex + 1);
              encoder.writeClient(client);
              // first clock written is 0
              lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);
              for (var i = 0; i <= lastStructIndex; i++) {
                structs[i].write(encoder, 0);
              }
            }
          } catch (err) {
            _iterator13.e(err);
          } finally {
            _iterator13.f();
          }
          writeDeleteSet(encoder, ds);
        });
        _applyUpdateV(newDoc, encoder.toUint8Array(), 'snapshot');
        return newDoc;
      };

      /**
       * @param {Snapshot} snapshot
       * @param {Uint8Array} update
       * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
       */
      var snapshotContainsUpdateV2 = function snapshotContainsUpdateV2(snapshot, update) {
        var YDecoder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UpdateDecoderV2;
        var updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        var lazyDecoder = new LazyStructReader(updateDecoder, false);
        for (var curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
          if ((snapshot.sv.get(curr.id.client) || 0) < curr.id.clock + curr.length) {
            return false;
          }
        }
        var mergedDS = mergeDeleteSets([snapshot.ds, readDeleteSet(updateDecoder)]);
        return _equalDeleteSets(snapshot.ds, mergedDS);
      };

      /**
       * @param {Snapshot} snapshot
       * @param {Uint8Array} update
       */
      var _snapshotContainsUpdate = function _snapshotContainsUpdate(snapshot, update) {
        return snapshotContainsUpdateV2(snapshot, update, UpdateDecoderV1);
      };
      var StructStore = /*#__PURE__*/_createClass(function StructStore() {
        _classCallCheck(this, StructStore);
        /**
         * @type {Map<number,Array<GC|Item>>}
         */
        this.clients = new Map();
        /**
         * @type {null | { missing: Map<number, number>, update: Uint8Array }}
         */
        this.pendingStructs = null;
        /**
         * @type {null | Uint8Array}
         */
        this.pendingDs = null;
      });
      /**
       * Return the states as a Map<client,clock>.
       * Note that clock refers to the next expected clock id.
       *
       * @param {StructStore} store
       * @return {Map<number,number>}
       *
       * @public
       * @function
       */
      var getStateVector = function getStateVector(store) {
        var sm = new Map();
        store.clients.forEach(function (structs, client) {
          var struct = structs[structs.length - 1];
          sm.set(client, struct.id.clock + struct.length);
        });
        return sm;
      };

      /**
       * @param {StructStore} store
       * @param {number} client
       * @return {number}
       *
       * @public
       * @function
       */
      var _getState = function _getState(store, client) {
        var structs = store.clients.get(client);
        if (structs === undefined) {
          return 0;
        }
        var lastStruct = structs[structs.length - 1];
        return lastStruct.id.clock + lastStruct.length;
      };

      /**
       * @param {StructStore} store
       * @param {GC|Item} struct
       *
       * @private
       * @function
       */
      var addStruct = function addStruct(store, struct) {
        var structs = store.clients.get(struct.id.client);
        if (structs === undefined) {
          structs = [];
          store.clients.set(struct.id.client, structs);
        } else {
          var lastStruct = structs[structs.length - 1];
          if (lastStruct.id.clock + lastStruct.length !== struct.id.clock) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
          }
        }
        structs.push(struct);
      };

      /**
       * Perform a binary search on a sorted array
       * @param {Array<Item|GC>} structs
       * @param {number} clock
       * @return {number}
       *
       * @private
       * @function
       */
      var _findIndexSS = function _findIndexSS(structs, clock) {
        var left = 0;
        var right = structs.length - 1;
        var mid = structs[right];
        var midclock = mid.id.clock;
        if (midclock === clock) {
          return right;
        }
        // @todo does it even make sense to pivot the search?
        // If a good split misses, it might actually increase the time to find the correct item.
        // Currently, the only advantage is that search with pivoting might find the item on the first try.
        var midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor(clock / (midclock + mid.length - 1) * right); // pivoting the search
        while (left <= right) {
          mid = structs[midindex];
          midclock = mid.id.clock;
          if (midclock <= clock) {
            if (clock < midclock + mid.length) {
              return midindex;
            }
            left = midindex + 1;
          } else {
            right = midindex - 1;
          }
          midindex = lib0_math__WEBPACK_IMPORTED_MODULE_1__.floor((left + right) / 2);
        }
        // Always check state before looking for a struct in StructStore
        // Therefore the case of not finding a struct is unexpected
        throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
      };

      /**
       * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
       *
       * @param {StructStore} store
       * @param {ID} id
       * @return {GC|Item}
       *
       * @private
       * @function
       */
      var find = function find(store, id) {
        /**
         * @type {Array<GC|Item>}
         */
        // @ts-ignore
        var structs = store.clients.get(id.client);
        return structs[_findIndexSS(structs, id.clock)];
      };

      /**
       * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
       * @private
       * @function
       */
      var _getItem = /** @type {function(StructStore,ID):Item} */find;

      /**
       * @param {Transaction} transaction
       * @param {Array<Item|GC>} structs
       * @param {number} clock
       */
      var findIndexCleanStart = function findIndexCleanStart(transaction, structs, clock) {
        var index = _findIndexSS(structs, clock);
        var struct = structs[index];
        if (struct.id.clock < clock && struct instanceof _Item) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, clock - struct.id.clock));
          return index + 1;
        }
        return index;
      };

      /**
       * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
       *
       * @param {Transaction} transaction
       * @param {ID} id
       * @return {Item}
       *
       * @private
       * @function
       */
      var getItemCleanStart = function getItemCleanStart(transaction, id) {
        var structs = /** @type {Array<Item>} */transaction.doc.store.clients.get(id.client);
        return structs[findIndexCleanStart(transaction, structs, id.clock)];
      };

      /**
       * Expects that id is actually in store. This function throws or is an infinite loop otherwise.
       *
       * @param {Transaction} transaction
       * @param {StructStore} store
       * @param {ID} id
       * @return {Item}
       *
       * @private
       * @function
       */
      var getItemCleanEnd = function getItemCleanEnd(transaction, store, id) {
        /**
         * @type {Array<Item>}
         */
        // @ts-ignore
        var structs = store.clients.get(id.client);
        var index = _findIndexSS(structs, id.clock);
        var struct = structs[index];
        if (id.clock !== struct.id.clock + struct.length - 1 && struct.constructor !== _GC) {
          structs.splice(index + 1, 0, splitItem(transaction, struct, id.clock - struct.id.clock + 1));
        }
        return struct;
      };

      /**
       * Replace `item` with `newitem` in store
       * @param {StructStore} store
       * @param {GC|Item} struct
       * @param {GC|Item} newStruct
       *
       * @private
       * @function
       */
      var replaceStruct = function replaceStruct(store, struct, newStruct) {
        var structs = /** @type {Array<GC|Item>} */store.clients.get(struct.id.client);
        structs[_findIndexSS(structs, struct.id.clock)] = newStruct;
      };

      /**
       * Iterate over a range of structs
       *
       * @param {Transaction} transaction
       * @param {Array<Item|GC>} structs
       * @param {number} clockStart Inclusive start
       * @param {number} len
       * @param {function(GC|Item):void} f
       *
       * @function
       */
      var iterateStructs = function iterateStructs(transaction, structs, clockStart, len, f) {
        if (len === 0) {
          return;
        }
        var clockEnd = clockStart + len;
        var index = findIndexCleanStart(transaction, structs, clockStart);
        var struct;
        do {
          struct = structs[index++];
          if (clockEnd < struct.id.clock + struct.length) {
            findIndexCleanStart(transaction, structs, clockEnd);
          }
          f(struct);
        } while (index < structs.length && structs[index].id.clock < clockEnd);
      };

      /**
       * A transaction is created for every change on the Yjs model. It is possible
       * to bundle changes on the Yjs model in a single transaction to
       * minimize the number on messages sent and the number of observer calls.
       * If possible the user of this library should bundle as many changes as
       * possible. Here is an example to illustrate the advantages of bundling:
       *
       * @example
       * const map = y.define('map', YMap)
       * // Log content when change is triggered
       * map.observe(() => {
       *   console.log('change triggered')
       * })
       * // Each change on the map type triggers a log message:
       * map.set('a', 0) // => "change triggered"
       * map.set('b', 0) // => "change triggered"
       * // When put in a transaction, it will trigger the log after the transaction:
       * y.transact(() => {
       *   map.set('a', 1)
       *   map.set('b', 1)
       * }) // => "change triggered"
       *
       * @public
       */
      var _Transaction = /*#__PURE__*/_createClass(
      /**
       * @param {Doc} doc
       * @param {any} origin
       * @param {boolean} local
       */
      function _Transaction(doc, origin, local) {
        _classCallCheck(this, _Transaction);
        /**
         * The Yjs instance.
         * @type {Doc}
         */
        this.doc = doc;
        /**
         * Describes the set of deleted items by ids
         * @type {DeleteSet}
         */
        this.deleteSet = new DeleteSet();
        /**
         * Holds the state before the transaction started.
         * @type {Map<Number,Number>}
         */
        this.beforeState = getStateVector(doc.store);
        /**
         * Holds the state after the transaction.
         * @type {Map<Number,Number>}
         */
        this.afterState = new Map();
        /**
         * All types that were directly modified (property added or child
         * inserted/deleted). New types are not included in this Set.
         * Maps from type to parentSubs (`item.parentSub = null` for YArray)
         * @type {Map<AbstractType<YEvent<any>>,Set<String|null>>}
         */
        this.changed = new Map();
        /**
         * Stores the events for the types that observe also child elements.
         * It is mainly used by `observeDeep`.
         * @type {Map<AbstractType<YEvent<any>>,Array<YEvent<any>>>}
         */
        this.changedParentTypes = new Map();
        /**
         * @type {Array<AbstractStruct>}
         */
        this._mergeStructs = [];
        /**
         * @type {any}
         */
        this.origin = origin;
        /**
         * Stores meta information on the transaction
         * @type {Map<any,any>}
         */
        this.meta = new Map();
        /**
         * Whether this change originates from this doc.
         * @type {boolean}
         */
        this.local = local;
        /**
         * @type {Set<Doc>}
         */
        this.subdocsAdded = new Set();
        /**
         * @type {Set<Doc>}
         */
        this.subdocsRemoved = new Set();
        /**
         * @type {Set<Doc>}
         */
        this.subdocsLoaded = new Set();
        /**
         * @type {boolean}
         */
        this._needFormattingCleanup = false;
      });
      /**
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       * @param {Transaction} transaction
       * @return {boolean} Whether data was written.
       */
      var writeUpdateMessageFromTransaction = function writeUpdateMessageFromTransaction(encoder, transaction) {
        if (transaction.deleteSet.clients.size === 0 && !lib0_map__WEBPACK_IMPORTED_MODULE_3__.any(transaction.afterState, function (clock, client) {
          return transaction.beforeState.get(client) !== clock;
        })) {
          return false;
        }
        sortAndMergeDeleteSet(transaction.deleteSet);
        writeStructsFromTransaction(encoder, transaction);
        writeDeleteSet(encoder, transaction.deleteSet);
        return true;
      };

      /**
       * If `type.parent` was added in current transaction, `type` technically
       * did not change, it was just added and we should not fire events for `type`.
       *
       * @param {Transaction} transaction
       * @param {AbstractType<YEvent<any>>} type
       * @param {string|null} parentSub
       */
      var addChangedTypeToTransaction = function addChangedTypeToTransaction(transaction, type, parentSub) {
        var item = type._item;
        if (item === null || item.id.clock < (transaction.beforeState.get(item.id.client) || 0) && !item.deleted) {
          lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(transaction.changed, type, lib0_set__WEBPACK_IMPORTED_MODULE_12__.create).add(parentSub);
        }
      };

      /**
       * @param {Array<AbstractStruct>} structs
       * @param {number} pos
       * @return {number} # of merged structs
       */
      var tryToMergeWithLefts = function tryToMergeWithLefts(structs, pos) {
        var right = structs[pos];
        var left = structs[pos - 1];
        var i = pos;
        for (; i > 0; right = left, left = structs[--i - 1]) {
          if (left.deleted === right.deleted && left.constructor === right.constructor) {
            if (left.mergeWith(right)) {
              if (right instanceof _Item && right.parentSub !== null && /** @type {AbstractType<any>} */right.parent._map.get(right.parentSub) === right) {
                /** @type {AbstractType<any>} */right.parent._map.set(right.parentSub, /** @type {Item} */left);
              }
              continue;
            }
          }
          break;
        }
        var merged = pos - i;
        if (merged) {
          // remove all merged structs from the array
          structs.splice(pos + 1 - merged, merged);
        }
        return merged;
      };

      /**
       * @param {DeleteSet} ds
       * @param {StructStore} store
       * @param {function(Item):boolean} gcFilter
       */
      var tryGcDeleteSet = function tryGcDeleteSet(ds, store, gcFilter) {
        var _iterator14 = _createForOfIteratorHelper(ds.clients.entries()),
          _step14;
        try {
          for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
            var _step14$value = _slicedToArray(_step14.value, 2),
              client = _step14$value[0],
              deleteItems = _step14$value[1];
            var structs = /** @type {Array<GC|Item>} */store.clients.get(client);
            for (var di = deleteItems.length - 1; di >= 0; di--) {
              var deleteItem = deleteItems[di];
              var endDeleteItemClock = deleteItem.clock + deleteItem.len;
              for (var si = _findIndexSS(structs, deleteItem.clock), struct = structs[si]; si < structs.length && struct.id.clock < endDeleteItemClock; struct = structs[++si]) {
                var _struct = structs[si];
                if (deleteItem.clock + deleteItem.len <= _struct.id.clock) {
                  break;
                }
                if (_struct instanceof _Item && _struct.deleted && !_struct.keep && gcFilter(_struct)) {
                  _struct.gc(store, false);
                }
              }
            }
          }
        } catch (err) {
          _iterator14.e(err);
        } finally {
          _iterator14.f();
        }
      };

      /**
       * @param {DeleteSet} ds
       * @param {StructStore} store
       */
      var tryMergeDeleteSet = function tryMergeDeleteSet(ds, store) {
        // try to merge deleted / gc'd items
        // merge from right to left for better efficiecy and so we don't miss any merge targets
        ds.clients.forEach(function (deleteItems, client) {
          var structs = /** @type {Array<GC|Item>} */store.clients.get(client);
          for (var di = deleteItems.length - 1; di >= 0; di--) {
            var deleteItem = deleteItems[di];
            // start with merging the item next to the last deleted item
            var mostRightIndexToCheck = lib0_math__WEBPACK_IMPORTED_MODULE_1__.min(structs.length - 1, 1 + _findIndexSS(structs, deleteItem.clock + deleteItem.len - 1));
            for (var si = mostRightIndexToCheck, struct = structs[si]; si > 0 && struct.id.clock >= deleteItem.clock; struct = structs[si]) {
              si -= 1 + tryToMergeWithLefts(structs, si);
            }
          }
        });
      };

      /**
       * @param {DeleteSet} ds
       * @param {StructStore} store
       * @param {function(Item):boolean} gcFilter
       */
      var _tryGc = function _tryGc(ds, store, gcFilter) {
        tryGcDeleteSet(ds, store, gcFilter);
        tryMergeDeleteSet(ds, store);
      };

      /**
       * @param {Array<Transaction>} transactionCleanups
       * @param {number} i
       */
      var cleanupTransactions = function cleanupTransactions(transactionCleanups, i) {
        if (i < transactionCleanups.length) {
          var transaction = transactionCleanups[i];
          var _doc2 = transaction.doc;
          var store = _doc2.store;
          var ds = transaction.deleteSet;
          var mergeStructs = transaction._mergeStructs;
          try {
            sortAndMergeDeleteSet(ds);
            transaction.afterState = getStateVector(transaction.doc.store);
            _doc2.emit('beforeObserverCalls', [transaction, _doc2]);
            /**
             * An array of event callbacks.
             *
             * Each callback is called even if the other ones throw errors.
             *
             * @type {Array<function():void>}
             */
            var fs = [];
            // observe events on changed types
            transaction.changed.forEach(function (subs, itemtype) {
              return fs.push(function () {
                if (itemtype._item === null || !itemtype._item.deleted) {
                  itemtype._callObserver(transaction, subs);
                }
              });
            });
            fs.push(function () {
              // deep observe events
              transaction.changedParentTypes.forEach(function (events, type) {
                // We need to think about the possibility that the user transforms the
                // Y.Doc in the event.
                if (type._dEH.l.length > 0 && (type._item === null || !type._item.deleted)) {
                  events = events.filter(function (event) {
                    return event.target._item === null || !event.target._item.deleted;
                  });
                  events.forEach(function (event) {
                    event.currentTarget = type;
                    // path is relative to the current target
                    event._path = null;
                  });
                  // sort events by path length so that top-level events are fired first.
                  events.sort(function (event1, event2) {
                    return event1.path.length - event2.path.length;
                  });
                  // We don't need to check for events.length
                  // because we know it has at least one element
                  callEventHandlerListeners(type._dEH, events, transaction);
                }
              });
            });
            fs.push(function () {
              return _doc2.emit('afterTransaction', [transaction, _doc2]);
            });
            (0, lib0_function__WEBPACK_IMPORTED_MODULE_11__.callAll)(fs, []);
            if (transaction._needFormattingCleanup) {
              cleanupYTextAfterTransaction(transaction);
            }
          } finally {
            // Replace deleted items with ItemDeleted / GC.
            // This is where content is actually remove from the Yjs Doc.
            if (_doc2.gc) {
              tryGcDeleteSet(ds, store, _doc2.gcFilter);
            }
            tryMergeDeleteSet(ds, store);

            // on all affected store.clients props, try to merge
            transaction.afterState.forEach(function (clock, client) {
              var beforeClock = transaction.beforeState.get(client) || 0;
              if (beforeClock !== clock) {
                var structs = /** @type {Array<GC|Item>} */store.clients.get(client);
                // we iterate from right to left so we can safely remove entries
                var firstChangePos = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(_findIndexSS(structs, beforeClock), 1);
                for (var _i7 = structs.length - 1; _i7 >= firstChangePos;) {
                  _i7 -= 1 + tryToMergeWithLefts(structs, _i7);
                }
              }
            });
            // try to merge mergeStructs
            // @todo: it makes more sense to transform mergeStructs to a DS, sort it, and merge from right to left
            //        but at the moment DS does not handle duplicates
            for (var _i8 = mergeStructs.length - 1; _i8 >= 0; _i8--) {
              var _mergeStructs$_i8$id = mergeStructs[_i8].id,
                client = _mergeStructs$_i8$id.client,
                clock = _mergeStructs$_i8$id.clock;
              var structs = /** @type {Array<GC|Item>} */store.clients.get(client);
              var replacedStructPos = _findIndexSS(structs, clock);
              if (replacedStructPos + 1 < structs.length) {
                if (tryToMergeWithLefts(structs, replacedStructPos + 1) > 1) {
                  continue; // no need to perform next check, both are already merged
                }
              }

              if (replacedStructPos > 0) {
                tryToMergeWithLefts(structs, replacedStructPos);
              }
            }
            if (!transaction.local && transaction.afterState.get(_doc2.clientID) !== transaction.beforeState.get(_doc2.clientID)) {
              lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print(lib0_logging__WEBPACK_IMPORTED_MODULE_14__.ORANGE, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.BOLD, '[yjs] ', lib0_logging__WEBPACK_IMPORTED_MODULE_14__.UNBOLD, lib0_logging__WEBPACK_IMPORTED_MODULE_14__.RED, 'Changed the client-id because another client seems to be using it.');
              _doc2.clientID = generateNewClientId();
            }
            // @todo Merge all the transactions into one and provide send the data as a single update message
            _doc2.emit('afterTransactionCleanup', [transaction, _doc2]);
            if (_doc2._observers.has('update')) {
              var encoder = new _UpdateEncoderV();
              var hasContent = writeUpdateMessageFromTransaction(encoder, transaction);
              if (hasContent) {
                _doc2.emit('update', [encoder.toUint8Array(), transaction.origin, _doc2, transaction]);
              }
            }
            if (_doc2._observers.has('updateV2')) {
              var _encoder2 = new UpdateEncoderV2();
              var _hasContent3 = writeUpdateMessageFromTransaction(_encoder2, transaction);
              if (_hasContent3) {
                _doc2.emit('updateV2', [_encoder2.toUint8Array(), transaction.origin, _doc2, transaction]);
              }
            }
            var subdocsAdded = transaction.subdocsAdded,
              subdocsLoaded = transaction.subdocsLoaded,
              subdocsRemoved = transaction.subdocsRemoved;
            if (subdocsAdded.size > 0 || subdocsRemoved.size > 0 || subdocsLoaded.size > 0) {
              subdocsAdded.forEach(function (subdoc) {
                subdoc.clientID = _doc2.clientID;
                if (subdoc.collectionid == null) {
                  subdoc.collectionid = _doc2.collectionid;
                }
                _doc2.subdocs.add(subdoc);
              });
              subdocsRemoved.forEach(function (subdoc) {
                return _doc2.subdocs.delete(subdoc);
              });
              _doc2.emit('subdocs', [{
                loaded: subdocsLoaded,
                added: subdocsAdded,
                removed: subdocsRemoved
              }, _doc2, transaction]);
              subdocsRemoved.forEach(function (subdoc) {
                return subdoc.destroy();
              });
            }
            if (transactionCleanups.length <= i + 1) {
              _doc2._transactionCleanups = [];
              _doc2.emit('afterAllTransactions', [_doc2, transactionCleanups]);
            } else {
              cleanupTransactions(transactionCleanups, i + 1);
            }
          }
        }
      };

      /**
       * Implements the functionality of `y.transact(()=>{..})`
       *
       * @template T
       * @param {Doc} doc
       * @param {function(Transaction):T} f
       * @param {any} [origin=true]
       * @return {T}
       *
       * @function
       */
      var _transact = function _transact(doc, f) {
        var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        var local = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;
        var transactionCleanups = doc._transactionCleanups;
        var initialCall = false;
        /**
         * @type {any}
         */
        var result = null;
        if (doc._transaction === null) {
          initialCall = true;
          doc._transaction = new _Transaction(doc, origin, local);
          transactionCleanups.push(doc._transaction);
          if (transactionCleanups.length === 1) {
            doc.emit('beforeAllTransactions', [doc]);
          }
          doc.emit('beforeTransaction', [doc._transaction, doc]);
        }
        try {
          result = f(doc._transaction);
        } finally {
          if (initialCall) {
            var finishCleanup = doc._transaction === transactionCleanups[0];
            doc._transaction = null;
            if (finishCleanup) {
              // The first transaction ended, now process observer calls.
              // Observer call may create new transactions for which we need to call the observers and do cleanup.
              // We don't want to nest these calls, so we execute these calls one after
              // another.
              // Also we need to ensure that all cleanups are called, even if the
              // observes throw errors.
              // This file is full of hacky try {} finally {} blocks to ensure that an
              // event can throw errors and also that the cleanup is called.
              cleanupTransactions(transactionCleanups, 0);
            }
          }
        }
        return result;
      };
      var StackItem = /*#__PURE__*/_createClass(
      /**
       * @param {DeleteSet} deletions
       * @param {DeleteSet} insertions
       */
      function StackItem(deletions, insertions) {
        _classCallCheck(this, StackItem);
        this.insertions = insertions;
        this.deletions = deletions;
        /**
         * Use this to save and restore metadata like selection range
         */
        this.meta = new Map();
      });
      /**
       * @param {Transaction} tr
       * @param {UndoManager} um
       * @param {StackItem} stackItem
       */
      var clearUndoManagerStackItem = function clearUndoManagerStackItem(tr, um, stackItem) {
        _iterateDeletedStructs(tr, stackItem.deletions, function (item) {
          if (item instanceof _Item && um.scope.some(function (type) {
            return _isParentOf2(type, item);
          })) {
            keepItem(item, false);
          }
        });
      };

      /**
       * @param {UndoManager} undoManager
       * @param {Array<StackItem>} stack
       * @param {string} eventType
       * @return {StackItem?}
       */
      var popStackItem = function popStackItem(undoManager, stack, eventType) {
        /**
         * Whether a change happened
         * @type {StackItem?}
         */
        var result = null;
        /**
         * Keep a reference to the transaction so we can fire the event with the changedParentTypes
         * @type {any}
         */
        var _tr = null;
        var doc = undoManager.doc;
        var scope = undoManager.scope;
        _transact(doc, function (transaction) {
          var _loop3 = function _loop3() {
            var store = doc.store;
            var stackItem = /** @type {StackItem} */stack.pop();
            /**
             * @type {Set<Item>}
             */
            var itemsToRedo = new Set();
            /**
             * @type {Array<Item>}
             */
            var itemsToDelete = [];
            var performedChange = false;
            _iterateDeletedStructs(transaction, stackItem.insertions, function (struct) {
              if (struct instanceof _Item) {
                if (struct.redone !== null) {
                  var _followRedone2 = followRedone(store, struct.id),
                    item = _followRedone2.item,
                    diff = _followRedone2.diff;
                  if (diff > 0) {
                    item = getItemCleanStart(transaction, _createID(item.id.client, item.id.clock + diff));
                  }
                  struct = item;
                }
                if (!struct.deleted && scope.some(function (type) {
                  return _isParentOf2(type, /** @type {Item} */struct);
                })) {
                  itemsToDelete.push(struct);
                }
              }
            });
            _iterateDeletedStructs(transaction, stackItem.deletions, function (struct) {
              if (struct instanceof _Item && scope.some(function (type) {
                return _isParentOf2(type, struct);
              }) &&
              // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
              !_isDeleted(stackItem.insertions, struct.id)) {
                itemsToRedo.add(struct);
              }
            });
            itemsToRedo.forEach(function (struct) {
              performedChange = redoItem(transaction, struct, itemsToRedo, stackItem.insertions, undoManager.ignoreRemoteMapChanges, undoManager) !== null || performedChange;
            });
            // We want to delete in reverse order so that children are deleted before
            // parents, so we have more information available when items are filtered.
            for (var i = itemsToDelete.length - 1; i >= 0; i--) {
              var item = itemsToDelete[i];
              if (undoManager.deleteFilter(item)) {
                item.delete(transaction);
                performedChange = true;
              }
            }
            result = performedChange ? stackItem : null;
          };
          while (stack.length > 0 && result === null) {
            _loop3();
          }
          transaction.changed.forEach(function (subProps, type) {
            // destroy search marker if necessary
            if (subProps.has(null) && type._searchMarker) {
              type._searchMarker.length = 0;
            }
          });
          _tr = transaction;
        }, undoManager);
        if (result != null) {
          var changedParentTypes = _tr.changedParentTypes;
          undoManager.emit('stack-item-popped', [{
            stackItem: result,
            type: eventType,
            changedParentTypes: changedParentTypes
          }, undoManager]);
        }
        return result;
      };

      /**
       * @typedef {Object} UndoManagerOptions
       * @property {number} [UndoManagerOptions.captureTimeout=500]
       * @property {function(Transaction):boolean} [UndoManagerOptions.captureTransaction] Do not capture changes of a Transaction if result false.
       * @property {function(Item):boolean} [UndoManagerOptions.deleteFilter=()=>true] Sometimes
       * it is necessary to filter what an Undo/Redo operation can delete. If this
       * filter returns false, the type/item won't be deleted even it is in the
       * undo/redo scope.
       * @property {Set<any>} [UndoManagerOptions.trackedOrigins=new Set([null])]
       * @property {boolean} [ignoreRemoteMapChanges] Experimental. By default, the UndoManager will never overwrite remote changes. Enable this property to enable overwriting remote changes on key-value changes (Y.Map, properties on Y.Xml, etc..).
       * @property {Doc} [doc] The document that this UndoManager operates on. Only needed if typeScope is empty.
       */

      /**
       * Fires 'stack-item-added' event when a stack item was added to either the undo- or
       * the redo-stack. You may store additional stack information via the
       * metadata property on `event.stackItem.meta` (it is a `Map` of metadata properties).
       * Fires 'stack-item-popped' event when a stack item was popped from either the
       * undo- or the redo-stack. You may restore the saved stack information from `event.stackItem.meta`.
       *
       * @extends {Observable<'stack-item-added'|'stack-item-popped'|'stack-cleared'|'stack-item-updated'>}
       */
      var _UndoManager = /*#__PURE__*/function (_lib0_observable__WEB3) {
        _inherits(_UndoManager, _lib0_observable__WEB3);
        var _super16 = _createSuper(_UndoManager);
        /**
         * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
         * @param {UndoManagerOptions} options
         */
        function _UndoManager(typeScope) {
          var _this27;
          var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            _ref11$captureTimeout = _ref11.captureTimeout,
            captureTimeout = _ref11$captureTimeout === void 0 ? 500 : _ref11$captureTimeout,
            _ref11$captureTransac = _ref11.captureTransaction,
            captureTransaction = _ref11$captureTransac === void 0 ? function (_tr) {
              return true;
            } : _ref11$captureTransac,
            _ref11$deleteFilter = _ref11.deleteFilter,
            deleteFilter = _ref11$deleteFilter === void 0 ? function () {
              return true;
            } : _ref11$deleteFilter,
            _ref11$trackedOrigins = _ref11.trackedOrigins,
            trackedOrigins = _ref11$trackedOrigins === void 0 ? new Set([null]) : _ref11$trackedOrigins,
            _ref11$ignoreRemoteMa = _ref11.ignoreRemoteMapChanges,
            ignoreRemoteMapChanges = _ref11$ignoreRemoteMa === void 0 ? false : _ref11$ignoreRemoteMa,
            _ref11$doc = _ref11.doc,
            doc = _ref11$doc === void 0 ? /** @type {Doc} */lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(typeScope) ? typeScope[0].doc : typeScope.doc : _ref11$doc;
          _classCallCheck(this, _UndoManager);
          _this27 = _super16.call(this);
          /**
           * @type {Array<AbstractType<any>>}
           */
          _this27.scope = [];
          _this27.doc = doc;
          _this27.addToScope(typeScope);
          _this27.deleteFilter = deleteFilter;
          trackedOrigins.add(_assertThisInitialized(_this27));
          _this27.trackedOrigins = trackedOrigins;
          _this27.captureTransaction = captureTransaction;
          /**
           * @type {Array<StackItem>}
           */
          _this27.undoStack = [];
          /**
           * @type {Array<StackItem>}
           */
          _this27.redoStack = [];
          /**
           * Whether the client is currently undoing (calling UndoManager.undo)
           *
           * @type {boolean}
           */
          _this27.undoing = false;
          _this27.redoing = false;
          _this27.lastChange = 0;
          _this27.ignoreRemoteMapChanges = ignoreRemoteMapChanges;
          _this27.captureTimeout = captureTimeout;
          /**
           * @param {Transaction} transaction
           */
          _this27.afterTransactionHandler = function (transaction) {
            // Only track certain transactions
            if (!_this27.captureTransaction(transaction) || !_this27.scope.some(function (type) {
              return transaction.changedParentTypes.has(type);
            }) || !_this27.trackedOrigins.has(transaction.origin) && (!transaction.origin || !_this27.trackedOrigins.has(transaction.origin.constructor))) {
              return;
            }
            var undoing = _this27.undoing;
            var redoing = _this27.redoing;
            var stack = undoing ? _this27.redoStack : _this27.undoStack;
            if (undoing) {
              _this27.stopCapturing(); // next undo should not be appended to last stack item
            } else if (!redoing) {
              // neither undoing nor redoing: delete redoStack
              _this27.clear(false, true);
            }
            var insertions = new DeleteSet();
            transaction.afterState.forEach(function (endClock, client) {
              var startClock = transaction.beforeState.get(client) || 0;
              var len = endClock - startClock;
              if (len > 0) {
                addToDeleteSet(insertions, client, startClock, len);
              }
            });
            var now = lib0_time__WEBPACK_IMPORTED_MODULE_15__.getUnixTime();
            var didAdd = false;
            if (_this27.lastChange > 0 && now - _this27.lastChange < _this27.captureTimeout && stack.length > 0 && !undoing && !redoing) {
              // append change to last stack op
              var lastOp = stack[stack.length - 1];
              lastOp.deletions = mergeDeleteSets([lastOp.deletions, transaction.deleteSet]);
              lastOp.insertions = mergeDeleteSets([lastOp.insertions, insertions]);
            } else {
              // create a new stack op
              stack.push(new StackItem(transaction.deleteSet, insertions));
              didAdd = true;
            }
            if (!undoing && !redoing) {
              _this27.lastChange = now;
            }
            // make sure that deleted structs are not gc'd
            _iterateDeletedStructs(transaction, transaction.deleteSet, /** @param {Item|GC} item */function (item) {
              if (item instanceof _Item && _this27.scope.some(function (type) {
                return _isParentOf2(type, item);
              })) {
                keepItem(item, true);
              }
            });
            var changeEvent = [{
              stackItem: stack[stack.length - 1],
              origin: transaction.origin,
              type: undoing ? 'redo' : 'undo',
              changedParentTypes: transaction.changedParentTypes
            }, _assertThisInitialized(_this27)];
            if (didAdd) {
              _this27.emit('stack-item-added', changeEvent);
            } else {
              _this27.emit('stack-item-updated', changeEvent);
            }
          };
          _this27.doc.on('afterTransaction', _this27.afterTransactionHandler);
          _this27.doc.on('destroy', function () {
            _this27.destroy();
          });
          return _this27;
        }

        /**
         * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
         */
        _createClass(_UndoManager, [{
          key: "addToScope",
          value: function addToScope(ytypes) {
            var _this28 = this;
            ytypes = lib0_array__WEBPACK_IMPORTED_MODULE_2__.isArray(ytypes) ? ytypes : [ytypes];
            ytypes.forEach(function (ytype) {
              if (_this28.scope.every(function (yt) {
                return yt !== ytype;
              })) {
                if (ytype.doc !== _this28.doc) lib0_logging__WEBPACK_IMPORTED_MODULE_13__.warn('[yjs#509] Not same Y.Doc'); // use MultiDocUndoManager instead. also see https://github.com/yjs/yjs/issues/509
                _this28.scope.push(ytype);
              }
            });
          }

          /**
           * @param {any} origin
           */
        }, {
          key: "addTrackedOrigin",
          value: function addTrackedOrigin(origin) {
            this.trackedOrigins.add(origin);
          }

          /**
           * @param {any} origin
           */
        }, {
          key: "removeTrackedOrigin",
          value: function removeTrackedOrigin(origin) {
            this.trackedOrigins.delete(origin);
          }
        }, {
          key: "clear",
          value: function clear() {
            var _this29 = this;
            var clearUndoStack = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
            var clearRedoStack = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
            if (clearUndoStack && this.canUndo() || clearRedoStack && this.canRedo()) {
              this.doc.transact(function (tr) {
                if (clearUndoStack) {
                  _this29.undoStack.forEach(function (item) {
                    return clearUndoManagerStackItem(tr, _this29, item);
                  });
                  _this29.undoStack = [];
                }
                if (clearRedoStack) {
                  _this29.redoStack.forEach(function (item) {
                    return clearUndoManagerStackItem(tr, _this29, item);
                  });
                  _this29.redoStack = [];
                }
                _this29.emit('stack-cleared', [{
                  undoStackCleared: clearUndoStack,
                  redoStackCleared: clearRedoStack
                }]);
              });
            }
          }

          /**
           * UndoManager merges Undo-StackItem if they are created within time-gap
           * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
           * StackItem won't be merged.
           *
           *
           * @example
           *     // without stopCapturing
           *     ytext.insert(0, 'a')
           *     ytext.insert(1, 'b')
           *     um.undo()
           *     ytext.toString() // => '' (note that 'ab' was removed)
           *     // with stopCapturing
           *     ytext.insert(0, 'a')
           *     um.stopCapturing()
           *     ytext.insert(0, 'b')
           *     um.undo()
           *     ytext.toString() // => 'a' (note that only 'b' was removed)
           *
           */
        }, {
          key: "stopCapturing",
          value: function stopCapturing() {
            this.lastChange = 0;
          }

          /**
           * Undo last changes on type.
           *
           * @return {StackItem?} Returns StackItem if a change was applied
           */
        }, {
          key: "undo",
          value: function undo() {
            this.undoing = true;
            var res;
            try {
              res = popStackItem(this, this.undoStack, 'undo');
            } finally {
              this.undoing = false;
            }
            return res;
          }

          /**
           * Redo last undo operation.
           *
           * @return {StackItem?} Returns StackItem if a change was applied
           */
        }, {
          key: "redo",
          value: function redo() {
            this.redoing = true;
            var res;
            try {
              res = popStackItem(this, this.redoStack, 'redo');
            } finally {
              this.redoing = false;
            }
            return res;
          }

          /**
           * Are undo steps available?
           *
           * @return {boolean} `true` if undo is possible
           */
        }, {
          key: "canUndo",
          value: function canUndo() {
            return this.undoStack.length > 0;
          }

          /**
           * Are redo steps available?
           *
           * @return {boolean} `true` if redo is possible
           */
        }, {
          key: "canRedo",
          value: function canRedo() {
            return this.redoStack.length > 0;
          }
        }, {
          key: "destroy",
          value: function destroy() {
            this.trackedOrigins.delete(this);
            this.doc.off('afterTransaction', this.afterTransactionHandler);
            _get(_getPrototypeOf(_UndoManager.prototype), "destroy", this).call(this);
          }
        }]);
        return _UndoManager;
      }(lib0_observable__WEBPACK_IMPORTED_MODULE_0__.Observable);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       */
      function lazyStructReaderGenerator(decoder) {
        var numOfStateUpdates, i, numberOfStructs, client, clock, _i9, info, len, cantCopyParentInfo, struct, _len7;
        return _regeneratorRuntime().wrap(function lazyStructReaderGenerator$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              numOfStateUpdates = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
              i = 0;
            case 2:
              if (!(i < numOfStateUpdates)) {
                _context.next = 34;
                break;
              }
              numberOfStructs = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
              client = decoder.readClient();
              clock = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
              _i9 = 0;
            case 7:
              if (!(_i9 < numberOfStructs)) {
                _context.next = 31;
                break;
              }
              info = decoder.readInfo(); // @todo use switch instead of ifs
              if (!(info === 10)) {
                _context.next = 16;
                break;
              }
              len = lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.readVarUint(decoder.restDecoder);
              _context.next = 13;
              return new Skip(_createID(client, clock), len);
            case 13:
              clock += len;
              _context.next = 28;
              break;
            case 16:
              if (!((lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 & info) !== 0)) {
                _context.next = 24;
                break;
              }
              cantCopyParentInfo = (info & (lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 | lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8)) === 0; // If parent = null and neither left nor right are defined, then we know that `parent` is child of `y`
              // and we read the next string as parentYKey.
              // It indicates how we store/retrieve parent from `y.share`
              // @type {string|null}
              struct = new _Item(_createID(client, clock), null,
              // left
              (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8 ? decoder.readLeftID() : null,
              // origin
              null,
              // right
              (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7 ? decoder.readRightID() : null,
              // right origin
              // @ts-ignore Force writing a string here.
              cantCopyParentInfo ? decoder.readParentInfo() ? decoder.readString() : decoder.readLeftID() : null,
              // parent
              cantCopyParentInfo && (info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6) === lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6 ? decoder.readString() : null,
              // parentSub
              readItemContent(decoder, info) // item content
              );
              _context.next = 21;
              return struct;
            case 21:
              clock += struct.length;
              _context.next = 28;
              break;
            case 24:
              _len7 = decoder.readLen();
              _context.next = 27;
              return new _GC(_createID(client, clock), _len7);
            case 27:
              clock += _len7;
            case 28:
              _i9++;
              _context.next = 7;
              break;
            case 31:
              i++;
              _context.next = 2;
              break;
            case 34:
            case "end":
              return _context.stop();
          }
        }, _marked);
      }
      var LazyStructReader = /*#__PURE__*/function () {
        /**
         * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
         * @param {boolean} filterSkips
         */
        function LazyStructReader(decoder, filterSkips) {
          _classCallCheck(this, LazyStructReader);
          this.gen = lazyStructReaderGenerator(decoder);
          /**
           * @type {null | Item | Skip | GC}
           */
          this.curr = null;
          this.done = false;
          this.filterSkips = filterSkips;
          this.next();
        }

        /**
         * @return {Item | GC | Skip |null}
         */
        _createClass(LazyStructReader, [{
          key: "next",
          value: function next() {
            // ignore "Skip" structs
            do {
              this.curr = this.gen.next().value || null;
            } while (this.filterSkips && this.curr !== null && this.curr.constructor === Skip);
            return this.curr;
          }
        }]);
        return LazyStructReader;
      }();
      /**
       * @param {Uint8Array} update
       *
       */
      var _logUpdate = function _logUpdate(update) {
        return _logUpdateV(update, UpdateDecoderV1);
      };

      /**
       * @param {Uint8Array} update
       * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
       *
       */
      var _logUpdateV = function _logUpdateV(update) {
        var YDecoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UpdateDecoderV2;
        var structs = [];
        var updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        var lazyDecoder = new LazyStructReader(updateDecoder, false);
        for (var curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
          structs.push(curr);
        }
        lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('Structs: ', structs);
        var ds = readDeleteSet(updateDecoder);
        lib0_logging__WEBPACK_IMPORTED_MODULE_13__.print('DeleteSet: ', ds);
      };

      /**
       * @param {Uint8Array} update
       *
       */
      var _decodeUpdate = function _decodeUpdate(update) {
        return _decodeUpdateV(update, UpdateDecoderV1);
      };

      /**
       * @param {Uint8Array} update
       * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} [YDecoder]
       *
       */
      var _decodeUpdateV = function _decodeUpdateV(update) {
        var YDecoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UpdateDecoderV2;
        var structs = [];
        var updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        var lazyDecoder = new LazyStructReader(updateDecoder, false);
        for (var curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
          structs.push(curr);
        }
        return {
          structs: structs,
          ds: readDeleteSet(updateDecoder)
        };
      };
      var LazyStructWriter = /*#__PURE__*/_createClass(
      /**
       * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
       */
      function LazyStructWriter(encoder) {
        _classCallCheck(this, LazyStructWriter);
        this.currClient = 0;
        this.startClock = 0;
        this.written = 0;
        this.encoder = encoder;
        /**
         * We want to write operations lazily, but also we need to know beforehand how many operations we want to write for each client.
         *
         * This kind of meta-information (#clients, #structs-per-client-written) is written to the restEncoder.
         *
         * We fragment the restEncoder and store a slice of it per-client until we know how many clients there are.
         * When we flush (toUint8Array) we write the restEncoder using the fragments and the meta-information.
         *
         * @type {Array<{ written: number, restEncoder: Uint8Array }>}
         */
        this.clientStructs = [];
      });
      /**
       * @param {Array<Uint8Array>} updates
       * @return {Uint8Array}
       */
      var _mergeUpdates = function _mergeUpdates(updates) {
        return _mergeUpdatesV(updates, UpdateDecoderV1, _UpdateEncoderV);
      };

      /**
       * @param {Uint8Array} update
       * @param {typeof DSEncoderV1 | typeof DSEncoderV2} YEncoder
       * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
       * @return {Uint8Array}
       */
      var _encodeStateVectorFromUpdateV = function _encodeStateVectorFromUpdateV(update) {
        var YEncoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DSEncoderV2;
        var YDecoder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UpdateDecoderV2;
        var encoder = new YEncoder();
        var updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);
        var curr = updateDecoder.curr;
        if (curr !== null) {
          var size = 0;
          var currClient = curr.id.client;
          var stopCounting = curr.id.clock !== 0; // must start at 0
          var currClock = stopCounting ? 0 : curr.id.clock + curr.length;
          for (; curr !== null; curr = updateDecoder.next()) {
            if (currClient !== curr.id.client) {
              if (currClock !== 0) {
                size++;
                // We found a new client
                // write what we have to the encoder
                lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);
                lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);
              }
              currClient = curr.id.client;
              currClock = 0;
              stopCounting = curr.id.clock !== 0;
            }
            // we ignore skips
            if (curr.constructor === Skip) {
              stopCounting = true;
            }
            if (!stopCounting) {
              currClock = curr.id.clock + curr.length;
            }
          }
          // write what we have
          if (currClock !== 0) {
            size++;
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClient);
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, currClock);
          }
          // prepend the size of the state vector
          var enc = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(enc, size);
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeBinaryEncoder(enc, encoder.restEncoder);
          encoder.restEncoder = enc;
          return encoder.toUint8Array();
        } else {
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, 0);
          return encoder.toUint8Array();
        }
      };

      /**
       * @param {Uint8Array} update
       * @return {Uint8Array}
       */
      var _encodeStateVectorFromUpdate = function _encodeStateVectorFromUpdate(update) {
        return _encodeStateVectorFromUpdateV(update, DSEncoderV1, UpdateDecoderV1);
      };

      /**
       * @param {Uint8Array} update
       * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} YDecoder
       * @return {{ from: Map<number,number>, to: Map<number,number> }}
       */
      var _parseUpdateMetaV = function _parseUpdateMetaV(update) {
        var YDecoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UpdateDecoderV2;
        /**
         * @type {Map<number, number>}
         */
        var from = new Map();
        /**
         * @type {Map<number, number>}
         */
        var to = new Map();
        var updateDecoder = new LazyStructReader(new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update)), false);
        var curr = updateDecoder.curr;
        if (curr !== null) {
          var currClient = curr.id.client;
          var currClock = curr.id.clock;
          // write the beginning to `from`
          from.set(currClient, currClock);
          for (; curr !== null; curr = updateDecoder.next()) {
            if (currClient !== curr.id.client) {
              // We found a new client
              // write the end to `to`
              to.set(currClient, currClock);
              // write the beginning to `from`
              from.set(curr.id.client, curr.id.clock);
              // update currClient
              currClient = curr.id.client;
            }
            currClock = curr.id.clock + curr.length;
          }
          // write the end to `to`
          to.set(currClient, currClock);
        }
        return {
          from: from,
          to: to
        };
      };

      /**
       * @param {Uint8Array} update
       * @return {{ from: Map<number,number>, to: Map<number,number> }}
       */
      var _parseUpdateMeta = function _parseUpdateMeta(update) {
        return _parseUpdateMetaV(update, UpdateDecoderV1);
      };

      /**
       * This method is intended to slice any kind of struct and retrieve the right part.
       * It does not handle side-effects, so it should only be used by the lazy-encoder.
       *
       * @param {Item | GC | Skip} left
       * @param {number} diff
       * @return {Item | GC}
       */
      var sliceStruct = function sliceStruct(left, diff) {
        if (left.constructor === _GC) {
          var _left$id = left.id,
            client = _left$id.client,
            clock = _left$id.clock;
          return new _GC(_createID(client, clock + diff), left.length - diff);
        } else if (left.constructor === Skip) {
          var _left$id2 = left.id,
            _client2 = _left$id2.client,
            _clock3 = _left$id2.clock;
          return new Skip(_createID(_client2, _clock3 + diff), left.length - diff);
        } else {
          var leftItem = /** @type {Item} */left;
          var _leftItem$id = leftItem.id,
            _client3 = _leftItem$id.client,
            _clock4 = _leftItem$id.clock;
          return new _Item(_createID(_client3, _clock4 + diff), null, _createID(_client3, _clock4 + diff - 1), null, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
        }
      };

      /**
       *
       * This function works similarly to `readUpdateV2`.
       *
       * @param {Array<Uint8Array>} updates
       * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
       * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
       * @return {Uint8Array}
       */
      var _mergeUpdatesV = function _mergeUpdatesV(updates) {
        var YDecoder = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : UpdateDecoderV2;
        var YEncoder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UpdateEncoderV2;
        if (updates.length === 1) {
          return updates[0];
        }
        var updateDecoders = updates.map(function (update) {
          return new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        });
        var lazyStructDecoders = updateDecoders.map(function (decoder) {
          return new LazyStructReader(decoder, true);
        });

        /**
         * @todo we don't need offset because we always slice before
         * @type {null | { struct: Item | GC | Skip, offset: number }}
         */
        var currWrite = null;
        var updateEncoder = new YEncoder();
        // write structs lazily
        var lazyStructEncoder = new LazyStructWriter(updateEncoder);

        // Note: We need to ensure that all lazyStructDecoders are fully consumed
        // Note: Should merge document updates whenever possible - even from different updates
        // Note: Should handle that some operations cannot be applied yet ()

        while (true) {
          // Write higher clients first  sort by clientID & clock and remove decoders without content
          lazyStructDecoders = lazyStructDecoders.filter(function (dec) {
            return dec.curr !== null;
          });
          lazyStructDecoders.sort( /** @type {function(any,any):number} */function (dec1, dec2) {
            if (dec1.curr.id.client === dec2.curr.id.client) {
              var clockDiff = dec1.curr.id.clock - dec2.curr.id.clock;
              if (clockDiff === 0) {
                // @todo remove references to skip since the structDecoders must filter Skips.
                return dec1.curr.constructor === dec2.curr.constructor ? 0 : dec1.curr.constructor === Skip ? 1 : -1; // we are filtering skips anyway.
              } else {
                return clockDiff;
              }
            } else {
              return dec2.curr.id.client - dec1.curr.id.client;
            }
          });
          if (lazyStructDecoders.length === 0) {
            break;
          }
          var currDecoder = lazyStructDecoders[0];
          // write from currDecoder until the next operation is from another client or if filler-struct
          // then we need to reorder the decoders and find the next operation to write
          var firstClient = /** @type {Item | GC} */currDecoder.curr.id.client;
          if (currWrite !== null) {
            var curr = /** @type {Item | GC | null} */currDecoder.curr;
            var iterated = false;

            // iterate until we find something that we haven't written already
            // remember: first the high client-ids are written
            while (curr !== null && curr.id.clock + curr.length <= currWrite.struct.id.clock + currWrite.struct.length && curr.id.client >= currWrite.struct.id.client) {
              curr = currDecoder.next();
              iterated = true;
            }
            if (curr === null ||
            // current decoder is empty
            curr.id.client !== firstClient ||
            // check whether there is another decoder that has has updates from `firstClient`
            iterated && curr.id.clock > currWrite.struct.id.clock + currWrite.struct.length // the above while loop was used and we are potentially missing updates
            ) {
              continue;
            }
            if (firstClient !== currWrite.struct.id.client) {
              writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
              currWrite = {
                struct: curr,
                offset: 0
              };
              currDecoder.next();
            } else {
              if (currWrite.struct.id.clock + currWrite.struct.length < curr.id.clock) {
                // @todo write currStruct & set currStruct = Skip(clock = currStruct.id.clock + currStruct.length, length = curr.id.clock - self.clock)
                if (currWrite.struct.constructor === Skip) {
                  // extend existing skip
                  currWrite.struct.length = curr.id.clock + curr.length - currWrite.struct.id.clock;
                } else {
                  writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                  var diff = curr.id.clock - currWrite.struct.id.clock - currWrite.struct.length;
                  /**
                   * @type {Skip}
                   */
                  var struct = new Skip(_createID(firstClient, currWrite.struct.id.clock + currWrite.struct.length), diff);
                  currWrite = {
                    struct: struct,
                    offset: 0
                  };
                }
              } else {
                // if (currWrite.struct.id.clock + currWrite.struct.length >= curr.id.clock) {
                var _diff = currWrite.struct.id.clock + currWrite.struct.length - curr.id.clock;
                if (_diff > 0) {
                  if (currWrite.struct.constructor === Skip) {
                    // prefer to slice Skip because the other struct might contain more information
                    currWrite.struct.length -= _diff;
                  } else {
                    curr = sliceStruct(curr, _diff);
                  }
                }
                if (!currWrite.struct.mergeWith( /** @type {any} */curr)) {
                  writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
                  currWrite = {
                    struct: curr,
                    offset: 0
                  };
                  currDecoder.next();
                }
              }
            }
          } else {
            currWrite = {
              struct: /** @type {Item | GC} */currDecoder.curr,
              offset: 0
            };
            currDecoder.next();
          }
          for (var next = currDecoder.curr; next !== null && next.id.client === firstClient && next.id.clock === currWrite.struct.id.clock + currWrite.struct.length && next.constructor !== Skip; next = currDecoder.next()) {
            writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
            currWrite = {
              struct: next,
              offset: 0
            };
          }
        }
        if (currWrite !== null) {
          writeStructToLazyStructWriter(lazyStructEncoder, currWrite.struct, currWrite.offset);
          currWrite = null;
        }
        finishLazyStructWriting(lazyStructEncoder);
        var dss = updateDecoders.map(function (decoder) {
          return readDeleteSet(decoder);
        });
        var ds = mergeDeleteSets(dss);
        writeDeleteSet(updateEncoder, ds);
        return updateEncoder.toUint8Array();
      };

      /**
       * @param {Uint8Array} update
       * @param {Uint8Array} sv
       * @param {typeof UpdateDecoderV1 | typeof UpdateDecoderV2} [YDecoder]
       * @param {typeof UpdateEncoderV1 | typeof UpdateEncoderV2} [YEncoder]
       */
      var _diffUpdateV = function _diffUpdateV(update, sv) {
        var YDecoder = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : UpdateDecoderV2;
        var YEncoder = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : UpdateEncoderV2;
        var state = _decodeStateVector(sv);
        var encoder = new YEncoder();
        var lazyStructWriter = new LazyStructWriter(encoder);
        var decoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        var reader = new LazyStructReader(decoder, false);
        while (reader.curr) {
          var curr = reader.curr;
          var currClient = curr.id.client;
          var svClock = state.get(currClient) || 0;
          if (reader.curr.constructor === Skip) {
            // the first written struct shouldn't be a skip
            reader.next();
            continue;
          }
          if (curr.id.clock + curr.length > svClock) {
            writeStructToLazyStructWriter(lazyStructWriter, curr, lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(svClock - curr.id.clock, 0));
            reader.next();
            while (reader.curr && reader.curr.id.client === currClient) {
              writeStructToLazyStructWriter(lazyStructWriter, reader.curr, 0);
              reader.next();
            }
          } else {
            // read until something new comes up
            while (reader.curr && reader.curr.id.client === currClient && reader.curr.id.clock + reader.curr.length <= svClock) {
              reader.next();
            }
          }
        }
        finishLazyStructWriting(lazyStructWriter);
        // write ds
        var ds = readDeleteSet(decoder);
        writeDeleteSet(encoder, ds);
        return encoder.toUint8Array();
      };

      /**
       * @param {Uint8Array} update
       * @param {Uint8Array} sv
       */
      var _diffUpdate = function _diffUpdate(update, sv) {
        return _diffUpdateV(update, sv, UpdateDecoderV1, _UpdateEncoderV);
      };

      /**
       * @param {LazyStructWriter} lazyWriter
       */
      var flushLazyStructWriter = function flushLazyStructWriter(lazyWriter) {
        if (lazyWriter.written > 0) {
          lazyWriter.clientStructs.push({
            written: lazyWriter.written,
            restEncoder: lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.toUint8Array(lazyWriter.encoder.restEncoder)
          });
          lazyWriter.encoder.restEncoder = lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.createEncoder();
          lazyWriter.written = 0;
        }
      };

      /**
       * @param {LazyStructWriter} lazyWriter
       * @param {Item | GC} struct
       * @param {number} offset
       */
      var writeStructToLazyStructWriter = function writeStructToLazyStructWriter(lazyWriter, struct, offset) {
        // flush curr if we start another client
        if (lazyWriter.written > 0 && lazyWriter.currClient !== struct.id.client) {
          flushLazyStructWriter(lazyWriter);
        }
        if (lazyWriter.written === 0) {
          lazyWriter.currClient = struct.id.client;
          // write next client
          lazyWriter.encoder.writeClient(struct.id.client);
          // write startClock
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(lazyWriter.encoder.restEncoder, struct.id.clock + offset);
        }
        struct.write(lazyWriter.encoder, offset);
        lazyWriter.written++;
      };
      /**
       * Call this function when we collected all parts and want to
       * put all the parts together. After calling this method,
       * you can continue using the UpdateEncoder.
       *
       * @param {LazyStructWriter} lazyWriter
       */
      var finishLazyStructWriting = function finishLazyStructWriting(lazyWriter) {
        flushLazyStructWriter(lazyWriter);

        // this is a fresh encoder because we called flushCurr
        var restEncoder = lazyWriter.encoder.restEncoder;

        /**
         * Now we put all the fragments together.
         * This works similarly to `writeClientsStructs`
         */

        // write # states that were updated - i.e. the clients
        lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, lazyWriter.clientStructs.length);
        for (var i = 0; i < lazyWriter.clientStructs.length; i++) {
          var partStructs = lazyWriter.clientStructs[i];
          /**
           * Works similarly to `writeStructs`
           */
          // write # encoded structs
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(restEncoder, partStructs.written);
          // write the rest of the fragment
          lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeUint8Array(restEncoder, partStructs.restEncoder);
        }
      };

      /**
       * @param {Uint8Array} update
       * @param {function(Item|GC|Skip):Item|GC|Skip} blockTransformer
       * @param {typeof UpdateDecoderV2 | typeof UpdateDecoderV1} YDecoder
       * @param {typeof UpdateEncoderV2 | typeof UpdateEncoderV1 } YEncoder
       */
      var convertUpdateFormat = function convertUpdateFormat(update, blockTransformer, YDecoder, YEncoder) {
        var updateDecoder = new YDecoder(lib0_decoding__WEBPACK_IMPORTED_MODULE_5__.createDecoder(update));
        var lazyDecoder = new LazyStructReader(updateDecoder, false);
        var updateEncoder = new YEncoder();
        var lazyWriter = new LazyStructWriter(updateEncoder);
        for (var curr = lazyDecoder.curr; curr !== null; curr = lazyDecoder.next()) {
          writeStructToLazyStructWriter(lazyWriter, blockTransformer(curr), 0);
        }
        finishLazyStructWriting(lazyWriter);
        var ds = readDeleteSet(updateDecoder);
        writeDeleteSet(updateEncoder, ds);
        return updateEncoder.toUint8Array();
      };

      /**
       * @typedef {Object} ObfuscatorOptions
       * @property {boolean} [ObfuscatorOptions.formatting=true]
       * @property {boolean} [ObfuscatorOptions.subdocs=true]
       * @property {boolean} [ObfuscatorOptions.yxml=true] Whether to obfuscate nodeName / hookName
       */

      /**
       * @param {ObfuscatorOptions} obfuscator
       */
      var createObfuscator = function createObfuscator() {
        var _ref12 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref12$formatting = _ref12.formatting,
          formatting = _ref12$formatting === void 0 ? true : _ref12$formatting,
          _ref12$subdocs = _ref12.subdocs,
          subdocs = _ref12$subdocs === void 0 ? true : _ref12$subdocs,
          _ref12$yxml = _ref12.yxml,
          yxml = _ref12$yxml === void 0 ? true : _ref12$yxml;
        var i = 0;
        var mapKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        var nodeNameCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        var formattingKeyCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        var formattingValueCache = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        formattingValueCache.set(null, null); // end of a formatting range should always be the end of a formatting range
        /**
         * @param {Item|GC|Skip} block
         * @return {Item|GC|Skip}
         */
        return function (block) {
          switch (block.constructor) {
            case _GC:
            case Skip:
              return block;
            case _Item:
              {
                var item = /** @type {Item} */block;
                var content = item.content;
                switch (content.constructor) {
                  case _ContentDeleted:
                    break;
                  case _ContentType:
                    {
                      if (yxml) {
                        var type = /** @type {ContentType} */content.type;
                        if (type instanceof YXmlElement) {
                          type.nodeName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.nodeName, function () {
                            return 'node-' + i;
                          });
                        }
                        if (type instanceof YXmlHook) {
                          type.hookName = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(nodeNameCache, type.hookName, function () {
                            return 'hook-' + i;
                          });
                        }
                      }
                      break;
                    }
                  case _ContentAny:
                    {
                      var c = /** @type {ContentAny} */content;
                      c.arr = c.arr.map(function () {
                        return i;
                      });
                      break;
                    }
                  case _ContentBinary:
                    {
                      var _c = /** @type {ContentBinary} */content;
                      _c.content = new Uint8Array([i]);
                      break;
                    }
                  case ContentDoc:
                    {
                      var _c2 = /** @type {ContentDoc} */content;
                      if (subdocs) {
                        _c2.opts = {};
                        _c2.doc.guid = i + '';
                      }
                      break;
                    }
                  case _ContentEmbed:
                    {
                      var _c3 = /** @type {ContentEmbed} */content;
                      _c3.embed = {};
                      break;
                    }
                  case _ContentFormat:
                    {
                      var _c4 = /** @type {ContentFormat} */content;
                      if (formatting) {
                        _c4.key = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingKeyCache, _c4.key, function () {
                          return i + '';
                        });
                        _c4.value = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(formattingValueCache, _c4.value, function () {
                          return {
                            i: i
                          };
                        });
                      }
                      break;
                    }
                  case _ContentJSON:
                    {
                      var _c5 = /** @type {ContentJSON} */content;
                      _c5.arr = _c5.arr.map(function () {
                        return i;
                      });
                      break;
                    }
                  case _ContentString:
                    {
                      var _c6 = /** @type {ContentString} */content;
                      _c6.str = lib0_string__WEBPACK_IMPORTED_MODULE_16__.repeat(i % 10 + '', _c6.str.length);
                      break;
                    }
                  default:
                    // unknown content type
                    lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
                }
                if (item.parentSub) {
                  item.parentSub = lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(mapKeyCache, item.parentSub, function () {
                    return i + '';
                  });
                }
                i++;
                return block;
              }
            default:
              // unknown block-type
              lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
          }
        };
      };

      /**
       * This function obfuscates the content of a Yjs update. This is useful to share
       * buggy Yjs documents while significantly limiting the possibility that a
       * developer can on the user. Note that it might still be possible to deduce
       * some information by analyzing the "structure" of the document or by analyzing
       * the typing behavior using the CRDT-related metadata that is still kept fully
       * intact.
       *
       * @param {Uint8Array} update
       * @param {ObfuscatorOptions} [opts]
       */
      var _obfuscateUpdate = function _obfuscateUpdate(update, opts) {
        return convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV1, _UpdateEncoderV);
      };

      /**
       * @param {Uint8Array} update
       * @param {ObfuscatorOptions} [opts]
       */
      var _obfuscateUpdateV = function _obfuscateUpdateV(update, opts) {
        return convertUpdateFormat(update, createObfuscator(opts), UpdateDecoderV2, UpdateEncoderV2);
      };

      /**
       * @param {Uint8Array} update
       */
      var _convertUpdateFormatV1ToV = function _convertUpdateFormatV1ToV(update) {
        return convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV1, UpdateEncoderV2);
      };

      /**
       * @param {Uint8Array} update
       */
      var _convertUpdateFormatV2ToV = function _convertUpdateFormatV2ToV(update) {
        return convertUpdateFormat(update, lib0_function__WEBPACK_IMPORTED_MODULE_11__.id, UpdateDecoderV2, _UpdateEncoderV);
      };
      var errorComputeChanges = 'You must not compute changes after the event-handler fired.';

      /**
       * @template {AbstractType<any>} T
       * YEvent describes the changes on a YType.
       */
      var _YEvent = /*#__PURE__*/function () {
        /**
         * @param {T} target The changed type.
         * @param {Transaction} transaction
         */
        function _YEvent(target, transaction) {
          _classCallCheck(this, _YEvent);
          /**
           * The type on which this event was created on.
           * @type {T}
           */
          this.target = target;
          /**
           * The current target on which the observe callback is called.
           * @type {AbstractType<any>}
           */
          this.currentTarget = target;
          /**
           * The transaction that triggered this event.
           * @type {Transaction}
           */
          this.transaction = transaction;
          /**
           * @type {Object|null}
           */
          this._changes = null;
          /**
           * @type {null | Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
           */
          this._keys = null;
          /**
           * @type {null | Array<{ insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any> }>}
           */
          this._delta = null;
          /**
           * @type {Array<string|number>|null}
           */
          this._path = null;
        }

        /**
         * Computes the path from `y` to the changed type.
         *
         * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
         *
         * The following property holds:
         * @example
         *   let type = y
         *   event.path.forEach(dir => {
         *     type = type.get(dir)
         *   })
         *   type === event.target // => true
         */
        _createClass(_YEvent, [{
          key: "path",
          get: function get() {
            return this._path || (this._path = getPathTo(this.currentTarget, this.target));
          }

          /**
           * Check if a struct is deleted by this event.
           *
           * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
           *
           * @param {AbstractStruct} struct
           * @return {boolean}
           */
        }, {
          key: "deletes",
          value: function deletes(struct) {
            return _isDeleted(this.transaction.deleteSet, struct.id);
          }

          /**
           * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
           */
        }, {
          key: "keys",
          get: function get() {
            var _this30 = this;
            if (this._keys === null) {
              if (this.transaction.doc._transactionCleanups.length === 0) {
                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);
              }
              var keys = new Map();
              var target = this.target;
              var changed = /** @type Set<string|null> */this.transaction.changed.get(target);
              changed.forEach(function (key) {
                if (key !== null) {
                  var item = /** @type {Item} */target._map.get(key);
                  /**
                   * @type {'delete' | 'add' | 'update'}
                   */
                  var action;
                  var oldValue;
                  if (_this30.adds(item)) {
                    var prev = item.left;
                    while (prev !== null && _this30.adds(prev)) {
                      prev = prev.left;
                    }
                    if (_this30.deletes(item)) {
                      if (prev !== null && _this30.deletes(prev)) {
                        action = 'delete';
                        oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());
                      } else {
                        return;
                      }
                    } else {
                      if (prev !== null && _this30.deletes(prev)) {
                        action = 'update';
                        oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last(prev.content.getContent());
                      } else {
                        action = 'add';
                        oldValue = undefined;
                      }
                    }
                  } else {
                    if (_this30.deletes(item)) {
                      action = 'delete';
                      oldValue = lib0_array__WEBPACK_IMPORTED_MODULE_2__.last( /** @type {Item} */item.content.getContent());
                    } else {
                      return; // nop
                    }
                  }

                  keys.set(key, {
                    action: action,
                    oldValue: oldValue
                  });
                }
              });
              this._keys = keys;
            }
            return this._keys;
          }

          /**
           * This is a computed property. Note that this can only be safely computed during the
           * event call. Computing this property after other changes happened might result in
           * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
           * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
           *
           * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
           */
        }, {
          key: "delta",
          get: function get() {
            return this.changes.delta;
          }

          /**
           * Check if a struct is added by this event.
           *
           * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
           *
           * @param {AbstractStruct} struct
           * @return {boolean}
           */
        }, {
          key: "adds",
          value: function adds(struct) {
            return struct.id.clock >= (this.transaction.beforeState.get(struct.id.client) || 0);
          }

          /**
           * This is a computed property. Note that this can only be safely computed during the
           * event call. Computing this property after other changes happened might result in
           * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
           * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
           *
           * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
           */
        }, {
          key: "changes",
          get: function get() {
            var changes = this._changes;
            if (changes === null) {
              if (this.transaction.doc._transactionCleanups.length === 0) {
                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create(errorComputeChanges);
              }
              var target = this.target;
              var added = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();
              var deleted = lib0_set__WEBPACK_IMPORTED_MODULE_12__.create();
              /**
               * @type {Array<{insert:Array<any>}|{delete:number}|{retain:number}>}
               */
              var delta = [];
              changes = {
                added: added,
                deleted: deleted,
                delta: delta,
                keys: this.keys
              };
              var changed = /** @type Set<string|null> */this.transaction.changed.get(target);
              if (changed.has(null)) {
                /**
                 * @type {any}
                 */
                var lastOp = null;
                var packOp = function packOp() {
                  if (lastOp) {
                    delta.push(lastOp);
                  }
                };
                for (var item = target._start; item !== null; item = item.right) {
                  if (item.deleted) {
                    if (this.deletes(item) && !this.adds(item)) {
                      if (lastOp === null || lastOp.delete === undefined) {
                        packOp();
                        lastOp = {
                          delete: 0
                        };
                      }
                      lastOp.delete += item.length;
                      deleted.add(item);
                    } // else nop
                  } else {
                    if (this.adds(item)) {
                      if (lastOp === null || lastOp.insert === undefined) {
                        packOp();
                        lastOp = {
                          insert: []
                        };
                      }
                      lastOp.insert = lastOp.insert.concat(item.content.getContent());
                      added.add(item);
                    } else {
                      if (lastOp === null || lastOp.retain === undefined) {
                        packOp();
                        lastOp = {
                          retain: 0
                        };
                      }
                      lastOp.retain += item.length;
                    }
                  }
                }
                if (lastOp !== null && lastOp.retain === undefined) {
                  packOp();
                }
              }
              this._changes = changes;
            }
            return (/** @type {any} */changes
            );
          }
        }]);
        return _YEvent;
      }();
      /**
       * Compute the path from this type to the specified target.
       *
       * @example
       *   // `child` should be accessible via `type.get(path[0]).get(path[1])..`
       *   const path = type.getPathTo(child)
       *   // assuming `type instanceof YArray`
       *   console.log(path) // might look like => [2, 'key1']
       *   child === type.get(path[0]).get(path[1])
       *
       * @param {AbstractType<any>} parent
       * @param {AbstractType<any>} child target
       * @return {Array<string|number>} Path to the target
       *
       * @private
       * @function
       */
      var getPathTo = function getPathTo(parent, child) {
        var path = [];
        while (child._item !== null && child !== parent) {
          if (child._item.parentSub !== null) {
            // parent is map-ish
            path.unshift(child._item.parentSub);
          } else {
            // parent is array-ish
            var i = 0;
            var c = /** @type {AbstractType<any>} */child._item.parent._start;
            while (c !== child._item && c !== null) {
              if (!c.deleted) {
                i++;
              }
              c = c.right;
            }
            path.unshift(i);
          }
          child = /** @type {AbstractType<any>} */child._item.parent;
        }
        return path;
      };
      var maxSearchMarker = 80;

      /**
       * A unique timestamp that identifies each marker.
       *
       * Time is relative,.. this is more like an ever-increasing clock.
       *
       * @type {number}
       */
      var globalSearchMarkerTimestamp = 0;
      var ArraySearchMarker = /*#__PURE__*/_createClass(
      /**
       * @param {Item} p
       * @param {number} index
       */
      function ArraySearchMarker(p, index) {
        _classCallCheck(this, ArraySearchMarker);
        p.marker = true;
        this.p = p;
        this.index = index;
        this.timestamp = globalSearchMarkerTimestamp++;
      });
      /**
       * @param {ArraySearchMarker} marker
       */
      var refreshMarkerTimestamp = function refreshMarkerTimestamp(marker) {
        marker.timestamp = globalSearchMarkerTimestamp++;
      };

      /**
       * This is rather complex so this function is the only thing that should overwrite a marker
       *
       * @param {ArraySearchMarker} marker
       * @param {Item} p
       * @param {number} index
       */
      var overwriteMarker = function overwriteMarker(marker, p, index) {
        marker.p.marker = false;
        marker.p = p;
        p.marker = true;
        marker.index = index;
        marker.timestamp = globalSearchMarkerTimestamp++;
      };

      /**
       * @param {Array<ArraySearchMarker>} searchMarker
       * @param {Item} p
       * @param {number} index
       */
      var markPosition = function markPosition(searchMarker, p, index) {
        if (searchMarker.length >= maxSearchMarker) {
          // override oldest marker (we don't want to create more objects)
          var marker = searchMarker.reduce(function (a, b) {
            return a.timestamp < b.timestamp ? a : b;
          });
          overwriteMarker(marker, p, index);
          return marker;
        } else {
          // create new marker
          var pm = new ArraySearchMarker(p, index);
          searchMarker.push(pm);
          return pm;
        }
      };

      /**
       * Search marker help us to find positions in the associative array faster.
       *
       * They speed up the process of finding a position without much bookkeeping.
       *
       * A maximum of `maxSearchMarker` objects are created.
       *
       * This function always returns a refreshed marker (updated timestamp)
       *
       * @param {AbstractType<any>} yarray
       * @param {number} index
       */
      var findMarker = function findMarker(yarray, index) {
        if (yarray._start === null || index === 0 || yarray._searchMarker === null) {
          return null;
        }
        var marker = yarray._searchMarker.length === 0 ? null : yarray._searchMarker.reduce(function (a, b) {
          return lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - a.index) < lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(index - b.index) ? a : b;
        });
        var p = yarray._start;
        var pindex = 0;
        if (marker !== null) {
          p = marker.p;
          pindex = marker.index;
          refreshMarkerTimestamp(marker); // we used it, we might need to use it again
        }
        // iterate to right if possible
        while (p.right !== null && pindex < index) {
          if (!p.deleted && p.countable) {
            if (index < pindex + p.length) {
              break;
            }
            pindex += p.length;
          }
          p = p.right;
        }
        // iterate to left if necessary (might be that pindex > index)
        while (p.left !== null && pindex > index) {
          p = p.left;
          if (!p.deleted && p.countable) {
            pindex -= p.length;
          }
        }
        // we want to make sure that p can't be merged with left, because that would screw up everything
        // in that cas just return what we have (it is most likely the best marker anyway)
        // iterate to left until p can't be merged with left
        while (p.left !== null && p.left.id.client === p.id.client && p.left.id.clock + p.left.length === p.id.clock) {
          p = p.left;
          if (!p.deleted && p.countable) {
            pindex -= p.length;
          }
        }

        // @todo remove!
        // assure position
        // {
        //   let start = yarray._start
        //   let pos = 0
        //   while (start !== p) {
        //     if (!start.deleted && start.countable) {
        //       pos += start.length
        //     }
        //     start = /** @type {Item} */ (start.right)
        //   }
        //   if (pos !== pindex) {
        //     debugger
        //     throw new Error('Gotcha position fail!')
        //   }
        // }
        // if (marker) {
        //   if (window.lengthes == null) {
        //     window.lengthes = []
        //     window.getLengthes = () => window.lengthes.sort((a, b) => a - b)
        //   }
        //   window.lengthes.push(marker.index - pindex)
        //   console.log('distance', marker.index - pindex, 'len', p && p.parent.length)
        // }
        if (marker !== null && lib0_math__WEBPACK_IMPORTED_MODULE_1__.abs(marker.index - pindex) < /** @type {YText|YArray<any>} */p.parent.length / maxSearchMarker) {
          // adjust existing marker
          overwriteMarker(marker, p, pindex);
          return marker;
        } else {
          // create new marker
          return markPosition(yarray._searchMarker, p, pindex);
        }
      };

      /**
       * Update markers when a change happened.
       *
       * This should be called before doing a deletion!
       *
       * @param {Array<ArraySearchMarker>} searchMarker
       * @param {number} index
       * @param {number} len If insertion, len is positive. If deletion, len is negative.
       */
      var updateMarkerChanges = function updateMarkerChanges(searchMarker, index, len) {
        for (var i = searchMarker.length - 1; i >= 0; i--) {
          var m = searchMarker[i];
          if (len > 0) {
            /**
             * @type {Item|null}
             */
            var p = m.p;
            p.marker = false;
            // Ideally we just want to do a simple position comparison, but this will only work if
            // search markers don't point to deleted items for formats.
            // Iterate marker to prev undeleted countable position so we know what to do when updating a position
            while (p && (p.deleted || !p.countable)) {
              p = p.left;
              if (p && !p.deleted && p.countable) {
                // adjust position. the loop should break now
                m.index -= p.length;
              }
            }
            if (p === null || p.marker === true) {
              // remove search marker if updated position is null or if position is already marked
              searchMarker.splice(i, 1);
              continue;
            }
            m.p = p;
            p.marker = true;
          }
          if (index < m.index || len > 0 && index === m.index) {
            // a simple index <= m.index check would actually suffice
            m.index = lib0_math__WEBPACK_IMPORTED_MODULE_1__.max(index, m.index + len);
          }
        }
      };

      /**
       * Accumulate all (list) children of a type and return them as an Array.
       *
       * @param {AbstractType<any>} t
       * @return {Array<Item>}
       */
      var _getTypeChildren = function _getTypeChildren(t) {
        var s = t._start;
        var arr = [];
        while (s) {
          arr.push(s);
          s = s.right;
        }
        return arr;
      };

      /**
       * Call event listeners with an event. This will also add an event to all
       * parents (for `.observeDeep` handlers).
       *
       * @template EventType
       * @param {AbstractType<EventType>} type
       * @param {Transaction} transaction
       * @param {EventType} event
       */
      var callTypeObservers = function callTypeObservers(type, transaction, event) {
        var changedType = type;
        var changedParentTypes = transaction.changedParentTypes;
        while (true) {
          // @ts-ignore
          lib0_map__WEBPACK_IMPORTED_MODULE_3__.setIfUndefined(changedParentTypes, type, function () {
            return [];
          }).push(event);
          if (type._item === null) {
            break;
          }
          type = /** @type {AbstractType<any>} */type._item.parent;
        }
        callEventHandlerListeners(changedType._eH, event, transaction);
      };

      /**
       * @template EventType
       * Abstract Yjs Type class
       */
      var _AbstractType = /*#__PURE__*/function () {
        function _AbstractType() {
          _classCallCheck(this, _AbstractType);
          /**
           * @type {Item|null}
           */
          this._item = null;
          /**
           * @type {Map<string,Item>}
           */
          this._map = new Map();
          /**
           * @type {Item|null}
           */
          this._start = null;
          /**
           * @type {Doc|null}
           */
          this.doc = null;
          this._length = 0;
          /**
           * Event handlers
           * @type {EventHandler<EventType,Transaction>}
           */
          this._eH = createEventHandler();
          /**
           * Deep event handlers
           * @type {EventHandler<Array<YEvent<any>>,Transaction>}
           */
          this._dEH = createEventHandler();
          /**
           * @type {null | Array<ArraySearchMarker>}
           */
          this._searchMarker = null;
        }

        /**
         * @return {AbstractType<any>|null}
         */
        _createClass(_AbstractType, [{
          key: "parent",
          get: function get() {
            return this._item ? /** @type {AbstractType<any>} */this._item.parent : null;
          }

          /**
           * Integrate this type into the Yjs instance.
           *
           * * Save this struct in the os
           * * This type is sent to other client
           * * Observer functions are fired
           *
           * @param {Doc} y The Yjs instance
           * @param {Item|null} item
           */
        }, {
          key: "_integrate",
          value: function _integrate(y, item) {
            this.doc = y;
            this._item = item;
          }

          /**
           * @return {AbstractType<EventType>}
           */
        }, {
          key: "_copy",
          value: function _copy() {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @return {AbstractType<EventType>}
           */
        }, {
          key: "clone",
          value: function clone() {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
           */
        }, {
          key: "_write",
          value: function _write(_encoder) {}

          /**
           * The first non-deleted item
           */
        }, {
          key: "_first",
          get: function get() {
            var n = this._start;
            while (n !== null && n.deleted) {
              n = n.right;
            }
            return n;
          }

          /**
           * Creates YEvent and calls all type observers.
           * Must be implemented by each type.
           *
           * @param {Transaction} transaction
           * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
           */
        }, {
          key: "_callObserver",
          value: function _callObserver(transaction, _parentSubs) {
            if (!transaction.local && this._searchMarker) {
              this._searchMarker.length = 0;
            }
          }

          /**
           * Observe all events that are created on this type.
           *
           * @param {function(EventType, Transaction):void} f Observer function
           */
        }, {
          key: "observe",
          value: function observe(f) {
            addEventHandlerListener(this._eH, f);
          }

          /**
           * Observe all events that are created by this type and its children.
           *
           * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
           */
        }, {
          key: "observeDeep",
          value: function observeDeep(f) {
            addEventHandlerListener(this._dEH, f);
          }

          /**
           * Unregister an observer function.
           *
           * @param {function(EventType,Transaction):void} f Observer function
           */
        }, {
          key: "unobserve",
          value: function unobserve(f) {
            removeEventHandlerListener(this._eH, f);
          }

          /**
           * Unregister an observer function.
           *
           * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
           */
        }, {
          key: "unobserveDeep",
          value: function unobserveDeep(f) {
            removeEventHandlerListener(this._dEH, f);
          }

          /**
           * @abstract
           * @return {any}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {}
        }]);
        return _AbstractType;
      }();
      /**
       * @param {AbstractType<any>} type
       * @param {number} start
       * @param {number} end
       * @return {Array<any>}
       *
       * @private
       * @function
       */
      var typeListSlice = function typeListSlice(type, start, end) {
        if (start < 0) {
          start = type._length + start;
        }
        if (end < 0) {
          end = type._length + end;
        }
        var len = end - start;
        var cs = [];
        var n = type._start;
        while (n !== null && len > 0) {
          if (n.countable && !n.deleted) {
            var c = n.content.getContent();
            if (c.length <= start) {
              start -= c.length;
            } else {
              for (var i = start; i < c.length && len > 0; i++) {
                cs.push(c[i]);
                len--;
              }
              start = 0;
            }
          }
          n = n.right;
        }
        return cs;
      };

      /**
       * @param {AbstractType<any>} type
       * @return {Array<any>}
       *
       * @private
       * @function
       */
      var typeListToArray = function typeListToArray(type) {
        var cs = [];
        var n = type._start;
        while (n !== null) {
          if (n.countable && !n.deleted) {
            var c = n.content.getContent();
            for (var i = 0; i < c.length; i++) {
              cs.push(c[i]);
            }
          }
          n = n.right;
        }
        return cs;
      };

      /**
       * @param {AbstractType<any>} type
       * @param {Snapshot} snapshot
       * @return {Array<any>}
       *
       * @private
       * @function
       */
      var _typeListToArraySnapshot = function _typeListToArraySnapshot(type, snapshot) {
        var cs = [];
        var n = type._start;
        while (n !== null) {
          if (n.countable && isVisible(n, snapshot)) {
            var c = n.content.getContent();
            for (var i = 0; i < c.length; i++) {
              cs.push(c[i]);
            }
          }
          n = n.right;
        }
        return cs;
      };

      /**
       * Executes a provided function on once on overy element of this YArray.
       *
       * @param {AbstractType<any>} type
       * @param {function(any,number,any):void} f A function to execute on every element of this YArray.
       *
       * @private
       * @function
       */
      var typeListForEach = function typeListForEach(type, f) {
        var index = 0;
        var n = type._start;
        while (n !== null) {
          if (n.countable && !n.deleted) {
            var c = n.content.getContent();
            for (var i = 0; i < c.length; i++) {
              f(c[i], index++, type);
            }
          }
          n = n.right;
        }
      };

      /**
       * @template C,R
       * @param {AbstractType<any>} type
       * @param {function(C,number,AbstractType<any>):R} f
       * @return {Array<R>}
       *
       * @private
       * @function
       */
      var typeListMap = function typeListMap(type, f) {
        /**
         * @type {Array<any>}
         */
        var result = [];
        typeListForEach(type, function (c, i) {
          result.push(f(c, i, type));
        });
        return result;
      };

      /**
       * @param {AbstractType<any>} type
       * @return {IterableIterator<any>}
       *
       * @private
       * @function
       */
      var typeListCreateIterator = function typeListCreateIterator(type) {
        var _ref13;
        var n = type._start;
        /**
         * @type {Array<any>|null}
         */
        var currentContent = null;
        var currentContentIndex = 0;
        return _ref13 = {}, _defineProperty(_ref13, Symbol.iterator, function () {
          return this;
        }), _defineProperty(_ref13, "next", function next() {
          // find some content
          if (currentContent === null) {
            while (n !== null && n.deleted) {
              n = n.right;
            }
            // check if we reached the end, no need to check currentContent, because it does not exist
            if (n === null) {
              return {
                done: true,
                value: undefined
              };
            }
            // we found n, so we can set currentContent
            currentContent = n.content.getContent();
            currentContentIndex = 0;
            n = n.right; // we used the content of n, now iterate to next
          }

          var value = currentContent[currentContentIndex++];
          // check if we need to empty currentContent
          if (currentContent.length <= currentContentIndex) {
            currentContent = null;
          }
          return {
            done: false,
            value: value
          };
        }), _ref13;
      };

      /**
       * @param {AbstractType<any>} type
       * @param {number} index
       * @return {any}
       *
       * @private
       * @function
       */
      var typeListGet = function typeListGet(type, index) {
        var marker = findMarker(type, index);
        var n = type._start;
        if (marker !== null) {
          n = marker.p;
          index -= marker.index;
        }
        for (; n !== null; n = n.right) {
          if (!n.deleted && n.countable) {
            if (index < n.length) {
              return n.content.getContent()[index];
            }
            index -= n.length;
          }
        }
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {Item?} referenceItem
       * @param {Array<Object<string,any>|Array<any>|boolean|number|null|string|Uint8Array>} content
       *
       * @private
       * @function
       */
      var typeListInsertGenericsAfter = function typeListInsertGenericsAfter(transaction, parent, referenceItem, content) {
        var left = referenceItem;
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        var store = doc.store;
        var right = referenceItem === null ? parent._start : referenceItem.right;
        /**
         * @type {Array<Object|Array<any>|number|null>}
         */
        var jsonContent = [];
        var packJsonContent = function packJsonContent() {
          if (jsonContent.length > 0) {
            left = new _Item(_createID(ownClientId, _getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new _ContentAny(jsonContent));
            left.integrate(transaction, 0);
            jsonContent = [];
          }
        };
        content.forEach(function (c) {
          if (c === null) {
            jsonContent.push(c);
          } else {
            switch (c.constructor) {
              case Number:
              case Object:
              case Boolean:
              case Array:
              case String:
                jsonContent.push(c);
                break;
              default:
                packJsonContent();
                switch (c.constructor) {
                  case Uint8Array:
                  case ArrayBuffer:
                    left = new _Item(_createID(ownClientId, _getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new _ContentBinary(new Uint8Array( /** @type {Uint8Array} */c)));
                    left.integrate(transaction, 0);
                    break;
                  case _Doc:
                    left = new _Item(_createID(ownClientId, _getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new ContentDoc( /** @type {Doc} */c));
                    left.integrate(transaction, 0);
                    break;
                  default:
                    if (c instanceof _AbstractType) {
                      left = new _Item(_createID(ownClientId, _getState(store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new _ContentType(c));
                      left.integrate(transaction, 0);
                    } else {
                      throw new Error('Unexpected content type in insert operation');
                    }
                }
            }
          }
        });
        packJsonContent();
      };
      var lengthExceeded = function lengthExceeded() {
        return lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Length exceeded!');
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {number} index
       * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
       *
       * @private
       * @function
       */
      var typeListInsertGenerics = function typeListInsertGenerics(transaction, parent, index, content) {
        if (index > parent._length) {
          throw lengthExceeded();
        }
        if (index === 0) {
          if (parent._searchMarker) {
            updateMarkerChanges(parent._searchMarker, index, content.length);
          }
          return typeListInsertGenericsAfter(transaction, parent, null, content);
        }
        var startIndex = index;
        var marker = findMarker(parent, index);
        var n = parent._start;
        if (marker !== null) {
          n = marker.p;
          index -= marker.index;
          // we need to iterate one to the left so that the algorithm works
          if (index === 0) {
            // @todo refactor this as it actually doesn't consider formats
            n = n.prev; // important! get the left undeleted item so that we can actually decrease index
            index += n && n.countable && !n.deleted ? n.length : 0;
          }
        }
        for (; n !== null; n = n.right) {
          if (!n.deleted && n.countable) {
            if (index <= n.length) {
              if (index < n.length) {
                // insert in-between
                getItemCleanStart(transaction, _createID(n.id.client, n.id.clock + index));
              }
              break;
            }
            index -= n.length;
          }
        }
        if (parent._searchMarker) {
          updateMarkerChanges(parent._searchMarker, startIndex, content.length);
        }
        return typeListInsertGenericsAfter(transaction, parent, n, content);
      };

      /**
       * Pushing content is special as we generally want to push after the last item. So we don't have to update
       * the serach marker.
       *
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {Array<Object<string,any>|Array<any>|number|null|string|Uint8Array>} content
       *
       * @private
       * @function
       */
      var typeListPushGenerics = function typeListPushGenerics(transaction, parent, content) {
        // Use the marker with the highest index and iterate to the right.
        var marker = (parent._searchMarker || []).reduce(function (maxMarker, currMarker) {
          return currMarker.index > maxMarker.index ? currMarker : maxMarker;
        }, {
          index: 0,
          p: parent._start
        });
        var n = marker.p;
        if (n) {
          while (n.right) {
            n = n.right;
          }
        }
        return typeListInsertGenericsAfter(transaction, parent, n, content);
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {number} index
       * @param {number} length
       *
       * @private
       * @function
       */
      var typeListDelete = function typeListDelete(transaction, parent, index, length) {
        if (length === 0) {
          return;
        }
        var startIndex = index;
        var startLength = length;
        var marker = findMarker(parent, index);
        var n = parent._start;
        if (marker !== null) {
          n = marker.p;
          index -= marker.index;
        }
        // compute the first item to be deleted
        for (; n !== null && index > 0; n = n.right) {
          if (!n.deleted && n.countable) {
            if (index < n.length) {
              getItemCleanStart(transaction, _createID(n.id.client, n.id.clock + index));
            }
            index -= n.length;
          }
        }
        // delete all items until done
        while (length > 0 && n !== null) {
          if (!n.deleted) {
            if (length < n.length) {
              getItemCleanStart(transaction, _createID(n.id.client, n.id.clock + length));
            }
            n.delete(transaction);
            length -= n.length;
          }
          n = n.right;
        }
        if (length > 0) {
          throw lengthExceeded();
        }
        if (parent._searchMarker) {
          updateMarkerChanges(parent._searchMarker, startIndex, -startLength + length /* in case we remove the above exception */);
        }
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {string} key
       *
       * @private
       * @function
       */
      var typeMapDelete = function typeMapDelete(transaction, parent, key) {
        var c = parent._map.get(key);
        if (c !== undefined) {
          c.delete(transaction);
        }
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {string} key
       * @param {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} value
       *
       * @private
       * @function
       */
      var typeMapSet = function typeMapSet(transaction, parent, key, value) {
        var left = parent._map.get(key) || null;
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        var content;
        if (value == null) {
          content = new _ContentAny([value]);
        } else {
          switch (value.constructor) {
            case Number:
            case Object:
            case Boolean:
            case Array:
            case String:
              content = new _ContentAny([value]);
              break;
            case Uint8Array:
              content = new _ContentBinary( /** @type {Uint8Array} */value);
              break;
            case _Doc:
              content = new ContentDoc( /** @type {Doc} */value);
              break;
            default:
              if (value instanceof _AbstractType) {
                content = new _ContentType(value);
              } else {
                throw new Error('Unexpected content type');
              }
          }
        }
        new _Item(_createID(ownClientId, _getState(doc.store, ownClientId)), left, left && left.lastId, null, null, parent, key, content).integrate(transaction, 0);
      };

      /**
       * @param {AbstractType<any>} parent
       * @param {string} key
       * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
       *
       * @private
       * @function
       */
      var typeMapGet = function typeMapGet(parent, key) {
        var val = parent._map.get(key);
        return val !== undefined && !val.deleted ? val.content.getContent()[val.length - 1] : undefined;
      };

      /**
       * @param {AbstractType<any>} parent
       * @return {Object<string,Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined>}
       *
       * @private
       * @function
       */
      var typeMapGetAll = function typeMapGetAll(parent) {
        /**
         * @type {Object<string,any>}
         */
        var res = {};
        parent._map.forEach(function (value, key) {
          if (!value.deleted) {
            res[key] = value.content.getContent()[value.length - 1];
          }
        });
        return res;
      };

      /**
       * @param {AbstractType<any>} parent
       * @param {string} key
       * @return {boolean}
       *
       * @private
       * @function
       */
      var typeMapHas = function typeMapHas(parent, key) {
        var val = parent._map.get(key);
        return val !== undefined && !val.deleted;
      };

      /**
       * @param {AbstractType<any>} parent
       * @param {string} key
       * @param {Snapshot} snapshot
       * @return {Object<string,any>|number|null|Array<any>|string|Uint8Array|AbstractType<any>|undefined}
       *
       * @private
       * @function
       */
      var _typeMapGetSnapshot = function _typeMapGetSnapshot(parent, key, snapshot) {
        var v = parent._map.get(key) || null;
        while (v !== null && (!snapshot.sv.has(v.id.client) || v.id.clock >= (snapshot.sv.get(v.id.client) || 0))) {
          v = v.left;
        }
        return v !== null && isVisible(v, snapshot) ? v.content.getContent()[v.length - 1] : undefined;
      };

      /**
       * @param {Map<string,Item>} map
       * @return {IterableIterator<Array<any>>}
       *
       * @private
       * @function
       */
      var createMapIterator = function createMapIterator(map) {
        return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorFilter(map.entries(), /** @param {any} entry */function (entry) {
          return !entry[1].deleted;
        });
      };

      /**
       * @module YArray
       */

      /**
       * Event that describes the changes on a YArray
       * @template T
       * @extends YEvent<YArray<T>>
       */
      var _YArrayEvent = /*#__PURE__*/function (_YEvent2) {
        _inherits(_YArrayEvent, _YEvent2);
        var _super17 = _createSuper(_YArrayEvent);
        /**
         * @param {YArray<T>} yarray The changed type
         * @param {Transaction} transaction The transaction object
         */
        function _YArrayEvent(yarray, transaction) {
          var _this31;
          _classCallCheck(this, _YArrayEvent);
          _this31 = _super17.call(this, yarray, transaction);
          _this31._transaction = transaction;
          return _this31;
        }
        return _createClass(_YArrayEvent);
      }(_YEvent);
      /**
       * A shared Array implementation.
       * @template T
       * @extends AbstractType<YArrayEvent<T>>
       * @implements {Iterable<T>}
       */
      var YArray = /*#__PURE__*/function (_AbstractType2, _Symbol$iterator) {
        _inherits(YArray, _AbstractType2);
        var _super18 = _createSuper(YArray);
        function YArray() {
          var _this32;
          _classCallCheck(this, YArray);
          _this32 = _super18.call(this);
          /**
           * @type {Array<any>?}
           * @private
           */
          _this32._prelimContent = [];
          /**
           * @type {Array<ArraySearchMarker>}
           */
          _this32._searchMarker = [];
          return _this32;
        }

        /**
         * Construct a new YArray containing the specified items.
         * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
         * @param {Array<T>} items
         * @return {YArray<T>}
         */
        _createClass(YArray, [{
          key: "_integrate",
          value:
          /**
           * Integrate this type into the Yjs instance.
           *
           * * Save this struct in the os
           * * This type is sent to other client
           * * Observer functions are fired
           *
           * @param {Doc} y The Yjs instance
           * @param {Item} item
           */
          function _integrate(y, item) {
            _get(_getPrototypeOf(YArray.prototype), "_integrate", this).call(this, y, item);
            this.insert(0, /** @type {Array<any>} */this._prelimContent);
            this._prelimContent = null;
          }

          /**
           * @return {YArray<T>}
           */
        }, {
          key: "_copy",
          value: function _copy() {
            return new YArray();
          }

          /**
           * @return {YArray<T>}
           */
        }, {
          key: "clone",
          value: function clone() {
            /**
             * @type {YArray<T>}
             */
            var arr = new YArray();
            arr.insert(0, this.toArray().map(function (el) {
              return el instanceof _AbstractType ? /** @type {typeof el} */el.clone() : el;
            }));
            return arr;
          }
        }, {
          key: "length",
          get: function get() {
            return this._prelimContent === null ? this._length : this._prelimContent.length;
          }

          /**
           * Creates YArrayEvent and calls observers.
           *
           * @param {Transaction} transaction
           * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
           */
        }, {
          key: "_callObserver",
          value: function _callObserver(transaction, parentSubs) {
            _get(_getPrototypeOf(YArray.prototype), "_callObserver", this).call(this, transaction, parentSubs);
            callTypeObservers(this, transaction, new _YArrayEvent(this, transaction));
          }

          /**
           * Inserts new content at an index.
           *
           * Important: This function expects an array of content. Not just a content
           * object. The reason for this "weirdness" is that inserting several elements
           * is very efficient when it is done as a single operation.
           *
           * @example
           *  // Insert character 'a' at position 0
           *  yarray.insert(0, ['a'])
           *  // Insert numbers 1, 2 at position 1
           *  yarray.insert(1, [1, 2])
           *
           * @param {number} index The index to insert content at.
           * @param {Array<T>} content The array of content
           */
        }, {
          key: "insert",
          value: function insert(index, content) {
            var _this33 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeListInsertGenerics(transaction, _this33, index, /** @type {any} */content);
              });
            } else {
              var _this$_prelimContent;
              /** @type {Array<any>} */(_this$_prelimContent = this._prelimContent).splice.apply(_this$_prelimContent, [index, 0].concat(_toConsumableArray(content)));
            }
          }

          /**
           * Appends content to this YArray.
           *
           * @param {Array<T>} content Array of content to append.
           *
           * @todo Use the following implementation in all types.
           */
        }, {
          key: "push",
          value: function push(content) {
            var _this34 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeListPushGenerics(transaction, _this34, /** @type {any} */content);
              });
            } else {
              var _this$_prelimContent2;
              /** @type {Array<any>} */(_this$_prelimContent2 = this._prelimContent).push.apply(_this$_prelimContent2, _toConsumableArray(content));
            }
          }

          /**
           * Preppends content to this YArray.
           *
           * @param {Array<T>} content Array of content to preppend.
           */
        }, {
          key: "unshift",
          value: function unshift(content) {
            this.insert(0, content);
          }

          /**
           * Deletes elements starting from an index.
           *
           * @param {number} index Index at which to start deleting elements
           * @param {number} length The number of elements to remove. Defaults to 1.
           */
        }, {
          key: "delete",
          value: function _delete(index) {
            var _this35 = this;
            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeListDelete(transaction, _this35, index, length);
              });
            } else {
              /** @type {Array<any>} */this._prelimContent.splice(index, length);
            }
          }

          /**
           * Returns the i-th element from a YArray.
           *
           * @param {number} index The index of the element to return from the YArray
           * @return {T}
           */
        }, {
          key: "get",
          value: function get(index) {
            return typeListGet(this, index);
          }

          /**
           * Transforms this YArray to a JavaScript Array.
           *
           * @return {Array<T>}
           */
        }, {
          key: "toArray",
          value: function toArray() {
            return typeListToArray(this);
          }

          /**
           * Transforms this YArray to a JavaScript Array.
           *
           * @param {number} [start]
           * @param {number} [end]
           * @return {Array<T>}
           */
        }, {
          key: "slice",
          value: function slice() {
            var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
            return typeListSlice(this, start, end);
          }

          /**
           * Transforms this Shared Type to a JSON object.
           *
           * @return {Array<any>}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            return this.map(function (c) {
              return c instanceof _AbstractType ? c.toJSON() : c;
            });
          }

          /**
           * Returns an Array with the result of calling a provided function on every
           * element of this YArray.
           *
           * @template M
           * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
           * @return {Array<M>} A new array with each element being the result of the
           *                 callback function
           */
        }, {
          key: "map",
          value: function map(f) {
            return typeListMap(this, /** @type {any} */f);
          }

          /**
           * Executes a provided function once on overy element of this YArray.
           *
           * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
           */
        }, {
          key: "forEach",
          value: function forEach(f) {
            typeListForEach(this, f);
          }

          /**
           * @return {IterableIterator<T>}
           */
        }, {
          key: _Symbol$iterator,
          value: function value() {
            return typeListCreateIterator(this);
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YArrayRefID);
          }
        }], [{
          key: "from",
          value: function from(items) {
            /**
             * @type {YArray<T>}
             */
            var a = new YArray();
            a.push(items);
            return a;
          }
        }]);
        return YArray;
      }(_AbstractType, Symbol.iterator);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
       *
       * @private
       * @function
       */
      var readYArray = function readYArray(_decoder) {
        return new YArray();
      };

      /**
       * @template T
       * @extends YEvent<YMap<T>>
       * Event that describes the changes on a YMap.
       */
      var _YMapEvent = /*#__PURE__*/function (_YEvent3) {
        _inherits(_YMapEvent, _YEvent3);
        var _super19 = _createSuper(_YMapEvent);
        /**
         * @param {YMap<T>} ymap The YArray that changed.
         * @param {Transaction} transaction
         * @param {Set<any>} subs The keys that changed.
         */
        function _YMapEvent(ymap, transaction, subs) {
          var _this36;
          _classCallCheck(this, _YMapEvent);
          _this36 = _super19.call(this, ymap, transaction);
          _this36.keysChanged = subs;
          return _this36;
        }
        return _createClass(_YMapEvent);
      }(_YEvent);
      /**
       * @template MapType
       * A shared Map implementation.
       *
       * @extends AbstractType<YMapEvent<MapType>>
       * @implements {Iterable<MapType>}
       */
      var YMap = /*#__PURE__*/function (_AbstractType3, _Symbol$iterator2) {
        _inherits(YMap, _AbstractType3);
        var _super20 = _createSuper(YMap);
        /**
         *
         * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
         */
        function YMap(entries) {
          var _this37;
          _classCallCheck(this, YMap);
          _this37 = _super20.call(this);
          /**
           * @type {Map<string,any>?}
           * @private
           */
          _this37._prelimContent = null;
          if (entries === undefined) {
            _this37._prelimContent = new Map();
          } else {
            _this37._prelimContent = new Map(entries);
          }
          return _this37;
        }

        /**
         * Integrate this type into the Yjs instance.
         *
         * * Save this struct in the os
         * * This type is sent to other client
         * * Observer functions are fired
         *
         * @param {Doc} y The Yjs instance
         * @param {Item} item
         */
        _createClass(YMap, [{
          key: "_integrate",
          value: function _integrate(y, item) {
            var _this38 = this;
            _get(_getPrototypeOf(YMap.prototype), "_integrate", this).call(this, y, item); /** @type {Map<string, any>} */
            this._prelimContent.forEach(function (value, key) {
              _this38.set(key, value);
            });
            this._prelimContent = null;
          }

          /**
           * @return {YMap<MapType>}
           */
        }, {
          key: "_copy",
          value: function _copy() {
            return new YMap();
          }

          /**
           * @return {YMap<MapType>}
           */
        }, {
          key: "clone",
          value: function clone() {
            /**
             * @type {YMap<MapType>}
             */
            var map = new YMap();
            this.forEach(function (value, key) {
              map.set(key, value instanceof _AbstractType ? /** @type {typeof value} */value.clone() : value);
            });
            return map;
          }

          /**
           * Creates YMapEvent and calls observers.
           *
           * @param {Transaction} transaction
           * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
           */
        }, {
          key: "_callObserver",
          value: function _callObserver(transaction, parentSubs) {
            callTypeObservers(this, transaction, new _YMapEvent(this, transaction, parentSubs));
          }

          /**
           * Transforms this Shared Type to a JSON object.
           *
           * @return {Object<string,any>}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            /**
             * @type {Object<string,MapType>}
             */
            var map = {};
            this._map.forEach(function (item, key) {
              if (!item.deleted) {
                var v = item.content.getContent()[item.length - 1];
                map[key] = v instanceof _AbstractType ? v.toJSON() : v;
              }
            });
            return map;
          }

          /**
           * Returns the size of the YMap (count of key/value pairs)
           *
           * @return {number}
           */
        }, {
          key: "size",
          get: function get() {
            return _toConsumableArray(createMapIterator(this._map)).length;
          }

          /**
           * Returns the keys for each element in the YMap Type.
           *
           * @return {IterableIterator<string>}
           */
        }, {
          key: "keys",
          value: function keys() {
            return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */function (v) {
              return v[0];
            });
          }

          /**
           * Returns the values for each element in the YMap Type.
           *
           * @return {IterableIterator<any>}
           */
        }, {
          key: "values",
          value: function values() {
            return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */function (v) {
              return v[1].content.getContent()[v[1].length - 1];
            });
          }

          /**
           * Returns an Iterator of [key, value] pairs
           *
           * @return {IterableIterator<any>}
           */
        }, {
          key: "entries",
          value: function entries() {
            return lib0_iterator__WEBPACK_IMPORTED_MODULE_17__.iteratorMap(createMapIterator(this._map), /** @param {any} v */function (v) {
              return [v[0], v[1].content.getContent()[v[1].length - 1]];
            });
          }

          /**
           * Executes a provided function on once on every key-value pair.
           *
           * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
           */
        }, {
          key: "forEach",
          value: function forEach(f) {
            var _this39 = this;
            this._map.forEach(function (item, key) {
              if (!item.deleted) {
                f(item.content.getContent()[item.length - 1], key, _this39);
              }
            });
          }

          /**
           * Returns an Iterator of [key, value] pairs
           *
           * @return {IterableIterator<any>}
           */
        }, {
          key: _Symbol$iterator2,
          value: function value() {
            return this.entries();
          }

          /**
           * Remove a specified element from this YMap.
           *
           * @param {string} key The key of the element to remove.
           */
        }, {
          key: "delete",
          value: function _delete(key) {
            var _this40 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapDelete(transaction, _this40, key);
              });
            } else {
              /** @type {Map<string, any>} */this._prelimContent.delete(key);
            }
          }

          /**
           * Adds or updates an element with a specified key and value.
           * @template {MapType} VAL
           *
           * @param {string} key The key of the element to add to this YMap
           * @param {VAL} value The value of the element to add
           * @return {VAL}
           */
        }, {
          key: "set",
          value: function set(key, value) {
            var _this41 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapSet(transaction, _this41, key, /** @type {any} */value);
              });
            } else {
              /** @type {Map<string, any>} */this._prelimContent.set(key, value);
            }
            return value;
          }

          /**
           * Returns a specified element from this YMap.
           *
           * @param {string} key
           * @return {MapType|undefined}
           */
        }, {
          key: "get",
          value: function get(key) {
            return (/** @type {any} */typeMapGet(this, key)
            );
          }

          /**
           * Returns a boolean indicating whether the specified key exists or not.
           *
           * @param {string} key The key to test.
           * @return {boolean}
           */
        }, {
          key: "has",
          value: function has(key) {
            return typeMapHas(this, key);
          }

          /**
           * Removes all elements from this YMap.
           */
        }, {
          key: "clear",
          value: function clear() {
            var _this42 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                _this42.forEach(function (_value, key, map) {
                  typeMapDelete(transaction, map, key);
                });
              });
            } else {
              /** @type {Map<string, any>} */this._prelimContent.clear();
            }
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YMapRefID);
          }
        }]);
        return YMap;
      }(_AbstractType, Symbol.iterator);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
       *
       * @private
       * @function
       */
      var readYMap = function readYMap(_decoder) {
        return new YMap();
      };

      /**
       * @param {any} a
       * @param {any} b
       * @return {boolean}
       */
      var equalAttrs = function equalAttrs(a, b) {
        return a === b || typeof a === 'object' && typeof b === 'object' && a && b && lib0_object__WEBPACK_IMPORTED_MODULE_18__.equalFlat(a, b);
      };
      var ItemTextListPosition = /*#__PURE__*/function () {
        /**
         * @param {Item|null} left
         * @param {Item|null} right
         * @param {number} index
         * @param {Map<string,any>} currentAttributes
         */
        function ItemTextListPosition(left, right, index, currentAttributes) {
          _classCallCheck(this, ItemTextListPosition);
          this.left = left;
          this.right = right;
          this.index = index;
          this.currentAttributes = currentAttributes;
        }

        /**
         * Only call this if you know that this.right is defined
         */
        _createClass(ItemTextListPosition, [{
          key: "forward",
          value: function forward() {
            if (this.right === null) {
              lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
            }
            switch (this.right.content.constructor) {
              case _ContentFormat:
                if (!this.right.deleted) {
                  updateCurrentAttributes(this.currentAttributes, /** @type {ContentFormat} */this.right.content);
                }
                break;
              default:
                if (!this.right.deleted) {
                  this.index += this.right.length;
                }
                break;
            }
            this.left = this.right;
            this.right = this.right.right;
          }
        }]);
        return ItemTextListPosition;
      }();
      /**
       * @param {Transaction} transaction
       * @param {ItemTextListPosition} pos
       * @param {number} count steps to move forward
       * @return {ItemTextListPosition}
       *
       * @private
       * @function
       */
      var findNextPosition = function findNextPosition(transaction, pos, count) {
        while (pos.right !== null && count > 0) {
          switch (pos.right.content.constructor) {
            case _ContentFormat:
              if (!pos.right.deleted) {
                updateCurrentAttributes(pos.currentAttributes, /** @type {ContentFormat} */pos.right.content);
              }
              break;
            default:
              if (!pos.right.deleted) {
                if (count < pos.right.length) {
                  // split right
                  getItemCleanStart(transaction, _createID(pos.right.id.client, pos.right.id.clock + count));
                }
                pos.index += pos.right.length;
                count -= pos.right.length;
              }
              break;
          }
          pos.left = pos.right;
          pos.right = pos.right.right;
          // pos.forward() - we don't forward because that would halve the performance because we already do the checks above
        }

        return pos;
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {number} index
       * @return {ItemTextListPosition}
       *
       * @private
       * @function
       */
      var findPosition = function findPosition(transaction, parent, index) {
        var currentAttributes = new Map();
        var marker = findMarker(parent, index);
        if (marker) {
          var pos = new ItemTextListPosition(marker.p.left, marker.p, marker.index, currentAttributes);
          return findNextPosition(transaction, pos, index - marker.index);
        } else {
          var _pos = new ItemTextListPosition(null, parent._start, 0, currentAttributes);
          return findNextPosition(transaction, _pos, index);
        }
      };

      /**
       * Negate applied formats
       *
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {ItemTextListPosition} currPos
       * @param {Map<string,any>} negatedAttributes
       *
       * @private
       * @function
       */
      var insertNegatedAttributes = function insertNegatedAttributes(transaction, parent, currPos, negatedAttributes) {
        // check if we really need to remove attributes
        while (currPos.right !== null && (currPos.right.deleted === true || currPos.right.content.constructor === _ContentFormat && equalAttrs(negatedAttributes.get( /** @type {ContentFormat} */currPos.right.content.key), /** @type {ContentFormat} */currPos.right.content.value))) {
          if (!currPos.right.deleted) {
            negatedAttributes.delete( /** @type {ContentFormat} */currPos.right.content.key);
          }
          currPos.forward();
        }
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        negatedAttributes.forEach(function (val, key) {
          var left = currPos.left;
          var right = currPos.right;
          var nextFormat = new _Item(_createID(ownClientId, _getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new _ContentFormat(key, val));
          nextFormat.integrate(transaction, 0);
          currPos.right = nextFormat;
          currPos.forward();
        });
      };

      /**
       * @param {Map<string,any>} currentAttributes
       * @param {ContentFormat} format
       *
       * @private
       * @function
       */
      var updateCurrentAttributes = function updateCurrentAttributes(currentAttributes, format) {
        var key = format.key,
          value = format.value;
        if (value === null) {
          currentAttributes.delete(key);
        } else {
          currentAttributes.set(key, value);
        }
      };

      /**
       * @param {ItemTextListPosition} currPos
       * @param {Object<string,any>} attributes
       *
       * @private
       * @function
       */
      var minimizeAttributeChanges = function minimizeAttributeChanges(currPos, attributes) {
        // go right while attributes[right.key] === right.value (or right is deleted)
        while (true) {
          if (currPos.right === null) {
            break;
          } else if (currPos.right.deleted || currPos.right.content.constructor === _ContentFormat && equalAttrs(attributes[/** @type {ContentFormat} */currPos.right.content.key] || null, /** @type {ContentFormat} */currPos.right.content.value)) ;else {
            break;
          }
          currPos.forward();
        }
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {ItemTextListPosition} currPos
       * @param {Object<string,any>} attributes
       * @return {Map<string,any>}
       *
       * @private
       * @function
       **/
      var insertAttributes = function insertAttributes(transaction, parent, currPos, attributes) {
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        var negatedAttributes = new Map();
        // insert format-start items
        for (var key in attributes) {
          var val = attributes[key];
          var currentVal = currPos.currentAttributes.get(key) || null;
          if (!equalAttrs(currentVal, val)) {
            // save negated attribute (set null if currentVal undefined)
            negatedAttributes.set(key, currentVal);
            var left = currPos.left,
              right = currPos.right;
            currPos.right = new _Item(_createID(ownClientId, _getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, new _ContentFormat(key, val));
            currPos.right.integrate(transaction, 0);
            currPos.forward();
          }
        }
        return negatedAttributes;
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {ItemTextListPosition} currPos
       * @param {string|object|AbstractType<any>} text
       * @param {Object<string,any>} attributes
       *
       * @private
       * @function
       **/
      var insertText = function insertText(transaction, parent, currPos, text, attributes) {
        currPos.currentAttributes.forEach(function (_val, key) {
          if (attributes[key] === undefined) {
            attributes[key] = null;
          }
        });
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        minimizeAttributeChanges(currPos, attributes);
        var negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
        // insert content
        var content = text.constructor === String ? new _ContentString( /** @type {string} */text) : text instanceof _AbstractType ? new _ContentType(text) : new _ContentEmbed(text);
        var left = currPos.left,
          right = currPos.right,
          index = currPos.index;
        if (parent._searchMarker) {
          updateMarkerChanges(parent._searchMarker, currPos.index, content.getLength());
        }
        right = new _Item(_createID(ownClientId, _getState(doc.store, ownClientId)), left, left && left.lastId, right, right && right.id, parent, null, content);
        right.integrate(transaction, 0);
        currPos.right = right;
        currPos.index = index;
        currPos.forward();
        insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
      };

      /**
       * @param {Transaction} transaction
       * @param {AbstractType<any>} parent
       * @param {ItemTextListPosition} currPos
       * @param {number} length
       * @param {Object<string,any>} attributes
       *
       * @private
       * @function
       */
      var formatText = function formatText(transaction, parent, currPos, length, attributes) {
        var doc = transaction.doc;
        var ownClientId = doc.clientID;
        minimizeAttributeChanges(currPos, attributes);
        var negatedAttributes = insertAttributes(transaction, parent, currPos, attributes);
        // iterate until first non-format or null is found
        // delete all formats with attributes[format.key] != null
        // also check the attributes after the first non-format as we do not want to insert redundant negated attributes there
        // eslint-disable-next-line no-labels
        iterationLoop: while (currPos.right !== null && (length > 0 || negatedAttributes.size > 0 && (currPos.right.deleted || currPos.right.content.constructor === _ContentFormat))) {
          if (!currPos.right.deleted) {
            switch (currPos.right.content.constructor) {
              case _ContentFormat:
                {
                  var _currPos$right$conten = /** @type {ContentFormat} */currPos.right.content,
                    key = _currPos$right$conten.key,
                    value = _currPos$right$conten.value;
                  var attr = attributes[key];
                  if (attr !== undefined) {
                    if (equalAttrs(attr, value)) {
                      negatedAttributes.delete(key);
                    } else {
                      if (length === 0) {
                        // no need to further extend negatedAttributes
                        // eslint-disable-next-line no-labels
                        break iterationLoop;
                      }
                      negatedAttributes.set(key, value);
                    }
                    currPos.right.delete(transaction);
                  } else {
                    currPos.currentAttributes.set(key, value);
                  }
                  break;
                }
              default:
                if (length < currPos.right.length) {
                  getItemCleanStart(transaction, _createID(currPos.right.id.client, currPos.right.id.clock + length));
                }
                length -= currPos.right.length;
                break;
            }
          }
          currPos.forward();
        }
        // Quill just assumes that the editor starts with a newline and that it always
        // ends with a newline. We only insert that newline when a new newline is
        // inserted - i.e when length is bigger than type.length
        if (length > 0) {
          var newlines = '';
          for (; length > 0; length--) {
            newlines += '\n';
          }
          currPos.right = new _Item(_createID(ownClientId, _getState(doc.store, ownClientId)), currPos.left, currPos.left && currPos.left.lastId, currPos.right, currPos.right && currPos.right.id, parent, null, new _ContentString(newlines));
          currPos.right.integrate(transaction, 0);
          currPos.forward();
        }
        insertNegatedAttributes(transaction, parent, currPos, negatedAttributes);
      };

      /**
       * Call this function after string content has been deleted in order to
       * clean up formatting Items.
       *
       * @param {Transaction} transaction
       * @param {Item} start
       * @param {Item|null} curr exclusive end, automatically iterates to the next Content Item
       * @param {Map<string,any>} startAttributes
       * @param {Map<string,any>} currAttributes
       * @return {number} The amount of formatting Items deleted.
       *
       * @function
       */
      var cleanupFormattingGap = function cleanupFormattingGap(transaction, start, curr, startAttributes, currAttributes) {
        /**
         * @type {Item|null}
         */
        var end = start;
        /**
         * @type {Map<string,ContentFormat>}
         */
        var endFormats = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
        while (end && (!end.countable || end.deleted)) {
          if (!end.deleted && end.content.constructor === _ContentFormat) {
            var cf = /** @type {ContentFormat} */end.content;
            endFormats.set(cf.key, cf);
          }
          end = end.right;
        }
        var cleanups = 0;
        var reachedCurr = false;
        while (start !== end) {
          if (curr === start) {
            reachedCurr = true;
          }
          if (!start.deleted) {
            var content = start.content;
            switch (content.constructor) {
              case _ContentFormat:
                {
                  var key = /** @type {ContentFormat} */content.key,
                    value = /** @type {ContentFormat} */content.value;
                  var startAttrValue = startAttributes.get(key) || null;
                  if (endFormats.get(key) !== content || startAttrValue === value) {
                    // Either this format is overwritten or it is not necessary because the attribute already existed.
                    start.delete(transaction);
                    cleanups++;
                    if (!reachedCurr && (currAttributes.get(key) || null) === value && startAttrValue !== value) {
                      if (startAttrValue === null) {
                        currAttributes.delete(key);
                      } else {
                        currAttributes.set(key, startAttrValue);
                      }
                    }
                  }
                  if (!reachedCurr && !start.deleted) {
                    updateCurrentAttributes(currAttributes, /** @type {ContentFormat} */content);
                  }
                  break;
                }
            }
          }
          start = /** @type {Item} */start.right;
        }
        return cleanups;
      };

      /**
       * @param {Transaction} transaction
       * @param {Item | null} item
       */
      var cleanupContextlessFormattingGap = function cleanupContextlessFormattingGap(transaction, item) {
        // iterate until item.right is null or content
        while (item && item.right && (item.right.deleted || !item.right.countable)) {
          item = item.right;
        }
        var attrs = new Set();
        // iterate back until a content item is found
        while (item && (item.deleted || !item.countable)) {
          if (!item.deleted && item.content.constructor === _ContentFormat) {
            var key = /** @type {ContentFormat} */item.content.key;
            if (attrs.has(key)) {
              item.delete(transaction);
            } else {
              attrs.add(key);
            }
          }
          item = item.left;
        }
      };

      /**
       * This function is experimental and subject to change / be removed.
       *
       * Ideally, we don't need this function at all. Formatting attributes should be cleaned up
       * automatically after each change. This function iterates twice over the complete YText type
       * and removes unnecessary formatting attributes. This is also helpful for testing.
       *
       * This function won't be exported anymore as soon as there is confidence that the YText type works as intended.
       *
       * @param {YText} type
       * @return {number} How many formatting attributes have been cleaned up.
       */
      var _cleanupYTextFormatting = function _cleanupYTextFormatting(type) {
        var res = 0;
        _transact( /** @type {Doc} */type.doc, function (transaction) {
          var start = /** @type {Item} */type._start;
          var end = type._start;
          var startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.create();
          var currentAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(startAttributes);
          while (end) {
            if (end.deleted === false) {
              switch (end.content.constructor) {
                case _ContentFormat:
                  updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */end.content);
                  break;
                default:
                  res += cleanupFormattingGap(transaction, start, end, startAttributes, currentAttributes);
                  startAttributes = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currentAttributes);
                  start = end;
                  break;
              }
            }
            end = end.right;
          }
        });
        return res;
      };

      /**
       * This will be called by the transction once the event handlers are called to potentially cleanup
       * formatting attributes.
       *
       * @param {Transaction} transaction
       */
      var cleanupYTextAfterTransaction = function cleanupYTextAfterTransaction(transaction) {
        /**
         * @type {Set<YText>}
         */
        var needFullCleanup = new Set();
        // check if another formatting item was inserted
        var doc = transaction.doc;
        var _iterator15 = _createForOfIteratorHelper(transaction.afterState.entries()),
          _step15;
        try {
          for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
            var _step15$value = _slicedToArray(_step15.value, 2),
              client = _step15$value[0],
              afterClock = _step15$value[1];
            var clock = transaction.beforeState.get(client) || 0;
            if (afterClock === clock) {
              continue;
            }
            iterateStructs(transaction, /** @type {Array<Item|GC>} */doc.store.clients.get(client), clock, afterClock, function (item) {
              if (!item.deleted && /** @type {Item} */item.content.constructor === _ContentFormat && item.constructor !== _GC) {
                needFullCleanup.add( /** @type {any} */item.parent);
              }
            });
          }
          // cleanup in a new transaction
        } catch (err) {
          _iterator15.e(err);
        } finally {
          _iterator15.f();
        }
        _transact(doc, function (t) {
          _iterateDeletedStructs(transaction, transaction.deleteSet, function (item) {
            if (item instanceof _GC || ! /** @type {YText} */item.parent._hasFormatting || needFullCleanup.has( /** @type {YText} */item.parent)) {
              return;
            }
            var parent = /** @type {YText} */item.parent;
            if (item.content.constructor === _ContentFormat) {
              needFullCleanup.add(parent);
            } else {
              // If no formatting attribute was inserted or deleted, we can make due with contextless
              // formatting cleanups.
              // Contextless: it is not necessary to compute currentAttributes for the affected position.
              cleanupContextlessFormattingGap(t, item);
            }
          });
          // If a formatting item was inserted, we simply clean the whole type.
          // We need to compute currentAttributes for the current position anyway.
          var _iterator16 = _createForOfIteratorHelper(needFullCleanup),
            _step16;
          try {
            for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
              var yText = _step16.value;
              _cleanupYTextFormatting(yText);
            }
          } catch (err) {
            _iterator16.e(err);
          } finally {
            _iterator16.f();
          }
        });
      };

      /**
       * @param {Transaction} transaction
       * @param {ItemTextListPosition} currPos
       * @param {number} length
       * @return {ItemTextListPosition}
       *
       * @private
       * @function
       */
      var deleteText = function deleteText(transaction, currPos, length) {
        var startLength = length;
        var startAttrs = lib0_map__WEBPACK_IMPORTED_MODULE_3__.copy(currPos.currentAttributes);
        var start = currPos.right;
        while (length > 0 && currPos.right !== null) {
          if (currPos.right.deleted === false) {
            switch (currPos.right.content.constructor) {
              case _ContentType:
              case _ContentEmbed:
              case _ContentString:
                if (length < currPos.right.length) {
                  getItemCleanStart(transaction, _createID(currPos.right.id.client, currPos.right.id.clock + length));
                }
                length -= currPos.right.length;
                currPos.right.delete(transaction);
                break;
            }
          }
          currPos.forward();
        }
        if (start) {
          cleanupFormattingGap(transaction, start, currPos.right, startAttrs, currPos.currentAttributes);
        }
        var parent = /** @type {AbstractType<any>} */ /** @type {Item} */(currPos.left || currPos.right).parent;
        if (parent._searchMarker) {
          updateMarkerChanges(parent._searchMarker, currPos.index, -startLength + length);
        }
        return currPos;
      };

      /**
       * The Quill Delta format represents changes on a text document with
       * formatting information. For mor information visit {@link https://quilljs.com/docs/delta/|Quill Delta}
       *
       * @example
       *   {
       *     ops: [
       *       { insert: 'Gandalf', attributes: { bold: true } },
       *       { insert: ' the ' },
       *       { insert: 'Grey', attributes: { color: '#cccccc' } }
       *     ]
       *   }
       *
       */

      /**
        * Attributes that can be assigned to a selection of text.
        *
        * @example
        *   {
        *     bold: true,
        *     font-size: '40px'
        *   }
        *
        * @typedef {Object} TextAttributes
        */

      /**
       * @extends YEvent<YText>
       * Event that describes the changes on a YText type.
       */
      var _YTextEvent = /*#__PURE__*/function (_YEvent4) {
        _inherits(_YTextEvent, _YEvent4);
        var _super21 = _createSuper(_YTextEvent);
        /**
         * @param {YText} ytext
         * @param {Transaction} transaction
         * @param {Set<any>} subs The keys that changed
         */
        function _YTextEvent(ytext, transaction, subs) {
          var _this43;
          _classCallCheck(this, _YTextEvent);
          _this43 = _super21.call(this, ytext, transaction);
          /**
           * Whether the children changed.
           * @type {Boolean}
           * @private
           */
          _this43.childListChanged = false;
          /**
           * Set of all changed attributes.
           * @type {Set<string>}
           */
          _this43.keysChanged = new Set();
          subs.forEach(function (sub) {
            if (sub === null) {
              _this43.childListChanged = true;
            } else {
              _this43.keysChanged.add(sub);
            }
          });
          return _this43;
        }

        /**
         * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
         */
        _createClass(_YTextEvent, [{
          key: "changes",
          get: function get() {
            if (this._changes === null) {
              /**
               * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string|AbstractType<any>|object, delete?:number, retain?:number}>}}
               */
              var changes = {
                keys: this.keys,
                delta: this.delta,
                added: new Set(),
                deleted: new Set()
              };
              this._changes = changes;
            }
            return (/** @type {any} */this._changes
            );
          }

          /**
           * Compute the changes in the delta format.
           * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
           *
           * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
           *
           * @public
           */
        }, {
          key: "delta",
          get: function get() {
            var _this44 = this;
            if (this._delta === null) {
              var y = /** @type {Doc} */this.target.doc;
              /**
               * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
               */
              var delta = [];
              _transact(y, function (transaction) {
                var currentAttributes = new Map(); // saves all current attributes for insert
                var oldAttributes = new Map();
                var item = _this44.target._start;
                /**
                 * @type {string?}
                 */
                var action = null;
                /**
                 * @type {Object<string,any>}
                 */
                var attributes = {}; // counts added or removed new attributes for retain
                /**
                 * @type {string|object}
                 */
                var insert = '';
                var retain = 0;
                var deleteLen = 0;
                var addOp = function addOp() {
                  if (action !== null) {
                    /**
                     * @type {any}
                     */
                    var op = null;
                    switch (action) {
                      case 'delete':
                        if (deleteLen > 0) {
                          op = {
                            delete: deleteLen
                          };
                        }
                        deleteLen = 0;
                        break;
                      case 'insert':
                        if (typeof insert === 'object' || insert.length > 0) {
                          op = {
                            insert: insert
                          };
                          if (currentAttributes.size > 0) {
                            op.attributes = {};
                            currentAttributes.forEach(function (value, key) {
                              if (value !== null) {
                                op.attributes[key] = value;
                              }
                            });
                          }
                        }
                        insert = '';
                        break;
                      case 'retain':
                        if (retain > 0) {
                          op = {
                            retain: retain
                          };
                          if (!lib0_object__WEBPACK_IMPORTED_MODULE_18__.isEmpty(attributes)) {
                            op.attributes = lib0_object__WEBPACK_IMPORTED_MODULE_18__.assign({}, attributes);
                          }
                        }
                        retain = 0;
                        break;
                    }
                    if (op) delta.push(op);
                    action = null;
                  }
                };
                while (item !== null) {
                  switch (item.content.constructor) {
                    case _ContentType:
                    case _ContentEmbed:
                      if (_this44.adds(item)) {
                        if (!_this44.deletes(item)) {
                          addOp();
                          action = 'insert';
                          insert = item.content.getContent()[0];
                          addOp();
                        }
                      } else if (_this44.deletes(item)) {
                        if (action !== 'delete') {
                          addOp();
                          action = 'delete';
                        }
                        deleteLen += 1;
                      } else if (!item.deleted) {
                        if (action !== 'retain') {
                          addOp();
                          action = 'retain';
                        }
                        retain += 1;
                      }
                      break;
                    case _ContentString:
                      if (_this44.adds(item)) {
                        if (!_this44.deletes(item)) {
                          if (action !== 'insert') {
                            addOp();
                            action = 'insert';
                          }
                          insert += /** @type {ContentString} */item.content.str;
                        }
                      } else if (_this44.deletes(item)) {
                        if (action !== 'delete') {
                          addOp();
                          action = 'delete';
                        }
                        deleteLen += item.length;
                      } else if (!item.deleted) {
                        if (action !== 'retain') {
                          addOp();
                          action = 'retain';
                        }
                        retain += item.length;
                      }
                      break;
                    case _ContentFormat:
                      {
                        var _item$content = /** @type {ContentFormat} */item.content,
                          key = _item$content.key,
                          value = _item$content.value;
                        if (_this44.adds(item)) {
                          if (!_this44.deletes(item)) {
                            var curVal = currentAttributes.get(key) || null;
                            if (!equalAttrs(curVal, value)) {
                              if (action === 'retain') {
                                addOp();
                              }
                              if (equalAttrs(value, oldAttributes.get(key) || null)) {
                                delete attributes[key];
                              } else {
                                attributes[key] = value;
                              }
                            } else if (value !== null) {
                              item.delete(transaction);
                            }
                          }
                        } else if (_this44.deletes(item)) {
                          oldAttributes.set(key, value);
                          var _curVal = currentAttributes.get(key) || null;
                          if (!equalAttrs(_curVal, value)) {
                            if (action === 'retain') {
                              addOp();
                            }
                            attributes[key] = _curVal;
                          }
                        } else if (!item.deleted) {
                          oldAttributes.set(key, value);
                          var attr = attributes[key];
                          if (attr !== undefined) {
                            if (!equalAttrs(attr, value)) {
                              if (action === 'retain') {
                                addOp();
                              }
                              if (value === null) {
                                delete attributes[key];
                              } else {
                                attributes[key] = value;
                              }
                            } else if (attr !== null) {
                              // this will be cleaned up automatically by the contextless cleanup function
                              item.delete(transaction);
                            }
                          }
                        }
                        if (!item.deleted) {
                          if (action === 'insert') {
                            addOp();
                          }
                          updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */item.content);
                        }
                        break;
                      }
                  }
                  item = item.right;
                }
                addOp();
                while (delta.length > 0) {
                  var lastOp = delta[delta.length - 1];
                  if (lastOp.retain !== undefined && lastOp.attributes === undefined) {
                    // retain delta's if they don't assign attributes
                    delta.pop();
                  } else {
                    break;
                  }
                }
              });
              this._delta = delta;
            }
            return (/** @type {any} */this._delta
            );
          }
        }]);
        return _YTextEvent;
      }(_YEvent);
      /**
       * Type that represents text with formatting information.
       *
       * This type replaces y-richtext as this implementation is able to handle
       * block formats (format information on a paragraph), embeds (complex elements
       * like pictures and videos), and text formats (**bold**, *italic*).
       *
       * @extends AbstractType<YTextEvent>
       */
      var YText = /*#__PURE__*/function (_AbstractType4) {
        _inherits(YText, _AbstractType4);
        var _super22 = _createSuper(YText);
        /**
         * @param {String} [string] The initial value of the YText.
         */
        function YText(string) {
          var _this45;
          _classCallCheck(this, YText);
          _this45 = _super22.call(this);
          /**
           * Array of pending operations on this type
           * @type {Array<function():void>?}
           */
          _this45._pending = string !== undefined ? [function () {
            return _this45.insert(0, string);
          }] : [];
          /**
           * @type {Array<ArraySearchMarker>|null}
           */
          _this45._searchMarker = [];
          /**
           * Whether this YText contains formatting attributes.
           * This flag is updated when a formatting item is integrated (see ContentFormat.integrate)
           */
          _this45._hasFormatting = false;
          return _this45;
        }

        /**
         * Number of characters of this text type.
         *
         * @type {number}
         */
        _createClass(YText, [{
          key: "length",
          get: function get() {
            return this._length;
          }

          /**
           * @param {Doc} y
           * @param {Item} item
           */
        }, {
          key: "_integrate",
          value: function _integrate(y, item) {
            _get(_getPrototypeOf(YText.prototype), "_integrate", this).call(this, y, item);
            try {
              /** @type {Array<function>} */this._pending.forEach(function (f) {
                return f();
              });
            } catch (e) {
              console.error(e);
            }
            this._pending = null;
          }
        }, {
          key: "_copy",
          value: function _copy() {
            return new YText();
          }

          /**
           * @return {YText}
           */
        }, {
          key: "clone",
          value: function clone() {
            var text = new YText();
            text.applyDelta(this.toDelta());
            return text;
          }

          /**
           * Creates YTextEvent and calls observers.
           *
           * @param {Transaction} transaction
           * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
           */
        }, {
          key: "_callObserver",
          value: function _callObserver(transaction, parentSubs) {
            _get(_getPrototypeOf(YText.prototype), "_callObserver", this).call(this, transaction, parentSubs);
            var event = new _YTextEvent(this, transaction, parentSubs);
            callTypeObservers(this, transaction, event);
            // If a remote change happened, we try to cleanup potential formatting duplicates.
            if (!transaction.local && this._hasFormatting) {
              transaction._needFormattingCleanup = true;
            }
          }

          /**
           * Returns the unformatted string representation of this YText type.
           *
           * @public
           */
        }, {
          key: "toString",
          value: function toString() {
            var str = '';
            /**
             * @type {Item|null}
             */
            var n = this._start;
            while (n !== null) {
              if (!n.deleted && n.countable && n.content.constructor === _ContentString) {
                str += /** @type {ContentString} */n.content.str;
              }
              n = n.right;
            }
            return str;
          }

          /**
           * Returns the unformatted string representation of this YText type.
           *
           * @return {string}
           * @public
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            return this.toString();
          }

          /**
           * Apply a {@link Delta} on this shared YText type.
           *
           * @param {any} delta The changes to apply on this element.
           * @param {object}  opts
           * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
           *
           *
           * @public
           */
        }, {
          key: "applyDelta",
          value: function applyDelta(delta) {
            var _this46 = this;
            var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
              _ref14$sanitize = _ref14.sanitize,
              sanitize = _ref14$sanitize === void 0 ? true : _ref14$sanitize;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                var currPos = new ItemTextListPosition(null, _this46._start, 0, new Map());
                for (var i = 0; i < delta.length; i++) {
                  var op = delta[i];
                  if (op.insert !== undefined) {
                    // Quill assumes that the content starts with an empty paragraph.
                    // Yjs/Y.Text assumes that it starts empty. We always hide that
                    // there is a newline at the end of the content.
                    // If we omit this step, clients will see a different number of
                    // paragraphs, but nothing bad will happen.
                    var ins = !sanitize && typeof op.insert === 'string' && i === delta.length - 1 && currPos.right === null && op.insert.slice(-1) === '\n' ? op.insert.slice(0, -1) : op.insert;
                    if (typeof ins !== 'string' || ins.length > 0) {
                      insertText(transaction, _this46, currPos, ins, op.attributes || {});
                    }
                  } else if (op.retain !== undefined) {
                    formatText(transaction, _this46, currPos, op.retain, op.attributes || {});
                  } else if (op.delete !== undefined) {
                    deleteText(transaction, currPos, op.delete);
                  }
                }
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this46.applyDelta(delta);
              });
            }
          }

          /**
           * Returns the Delta representation of this YText type.
           *
           * @param {Snapshot} [snapshot]
           * @param {Snapshot} [prevSnapshot]
           * @param {function('removed' | 'added', ID):any} [computeYChange]
           * @return {any} The Delta representation of this type.
           *
           * @public
           */
        }, {
          key: "toDelta",
          value: function toDelta(snapshot, prevSnapshot, computeYChange) {
            /**
             * @type{Array<any>}
             */
            var ops = [];
            var currentAttributes = new Map();
            var doc = /** @type {Doc} */this.doc;
            var str = '';
            var n = this._start;
            function packStr() {
              if (str.length > 0) {
                // pack str with attributes to ops
                /**
                 * @type {Object<string,any>}
                 */
                var attributes = {};
                var addAttributes = false;
                currentAttributes.forEach(function (value, key) {
                  addAttributes = true;
                  attributes[key] = value;
                });
                /**
                 * @type {Object<string,any>}
                 */
                var op = {
                  insert: str
                };
                if (addAttributes) {
                  op.attributes = attributes;
                }
                ops.push(op);
                str = '';
              }
            }
            var computeDelta = function computeDelta() {
              var _loop4 = function _loop4() {
                if (isVisible(n, snapshot) || prevSnapshot !== undefined && isVisible(n, prevSnapshot)) {
                  switch (n.content.constructor) {
                    case _ContentString:
                      {
                        var cur = currentAttributes.get('ychange');
                        if (snapshot !== undefined && !isVisible(n, snapshot)) {
                          if (cur === undefined || cur.user !== n.id.client || cur.type !== 'removed') {
                            packStr();
                            currentAttributes.set('ychange', computeYChange ? computeYChange('removed', n.id) : {
                              type: 'removed'
                            });
                          }
                        } else if (prevSnapshot !== undefined && !isVisible(n, prevSnapshot)) {
                          if (cur === undefined || cur.user !== n.id.client || cur.type !== 'added') {
                            packStr();
                            currentAttributes.set('ychange', computeYChange ? computeYChange('added', n.id) : {
                              type: 'added'
                            });
                          }
                        } else if (cur !== undefined) {
                          packStr();
                          currentAttributes.delete('ychange');
                        }
                        str += /** @type {ContentString} */n.content.str;
                        break;
                      }
                    case _ContentType:
                    case _ContentEmbed:
                      {
                        packStr();
                        /**
                         * @type {Object<string,any>}
                         */
                        var op = {
                          insert: n.content.getContent()[0]
                        };
                        if (currentAttributes.size > 0) {
                          var attrs = /** @type {Object<string,any>} */{};
                          op.attributes = attrs;
                          currentAttributes.forEach(function (value, key) {
                            attrs[key] = value;
                          });
                        }
                        ops.push(op);
                        break;
                      }
                    case _ContentFormat:
                      if (isVisible(n, snapshot)) {
                        packStr();
                        updateCurrentAttributes(currentAttributes, /** @type {ContentFormat} */n.content);
                      }
                      break;
                  }
                }
                n = n.right;
              };
              while (n !== null) {
                _loop4();
              }
              packStr();
            };
            if (snapshot || prevSnapshot) {
              // snapshots are merged again after the transaction, so we need to keep the
              // transaction alive until we are done
              _transact(doc, function (transaction) {
                if (snapshot) {
                  splitSnapshotAffectedStructs(transaction, snapshot);
                }
                if (prevSnapshot) {
                  splitSnapshotAffectedStructs(transaction, prevSnapshot);
                }
                computeDelta();
              }, 'cleanup');
            } else {
              computeDelta();
            }
            return ops;
          }

          /**
           * Insert text at a given index.
           *
           * @param {number} index The index at which to start inserting.
           * @param {String} text The text to insert at the specified position.
           * @param {TextAttributes} [attributes] Optionally define some formatting
           *                                    information to apply on the inserted
           *                                    Text.
           * @public
           */
        }, {
          key: "insert",
          value: function insert(index, text, attributes) {
            var _this47 = this;
            if (text.length <= 0) {
              return;
            }
            var y = this.doc;
            if (y !== null) {
              _transact(y, function (transaction) {
                var pos = findPosition(transaction, _this47, index);
                if (!attributes) {
                  attributes = {};
                  // @ts-ignore
                  pos.currentAttributes.forEach(function (v, k) {
                    attributes[k] = v;
                  });
                }
                insertText(transaction, _this47, pos, text, attributes);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this47.insert(index, text, attributes);
              });
            }
          }

          /**
           * Inserts an embed at a index.
           *
           * @param {number} index The index to insert the embed at.
           * @param {Object | AbstractType<any>} embed The Object that represents the embed.
           * @param {TextAttributes} attributes Attribute information to apply on the
           *                                    embed
           *
           * @public
           */
        }, {
          key: "insertEmbed",
          value: function insertEmbed(index, embed) {
            var _this48 = this;
            var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
            var y = this.doc;
            if (y !== null) {
              _transact(y, function (transaction) {
                var pos = findPosition(transaction, _this48, index);
                insertText(transaction, _this48, pos, embed, attributes);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this48.insertEmbed(index, embed, attributes);
              });
            }
          }

          /**
           * Deletes text starting from an index.
           *
           * @param {number} index Index at which to start deleting.
           * @param {number} length The number of characters to remove. Defaults to 1.
           *
           * @public
           */
        }, {
          key: "delete",
          value: function _delete(index, length) {
            var _this49 = this;
            if (length === 0) {
              return;
            }
            var y = this.doc;
            if (y !== null) {
              _transact(y, function (transaction) {
                deleteText(transaction, findPosition(transaction, _this49, index), length);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this49.delete(index, length);
              });
            }
          }

          /**
           * Assigns properties to a range of text.
           *
           * @param {number} index The position where to start formatting.
           * @param {number} length The amount of characters to assign properties to.
           * @param {TextAttributes} attributes Attribute information to apply on the
           *                                    text.
           *
           * @public
           */
        }, {
          key: "format",
          value: function format(index, length, attributes) {
            var _this50 = this;
            if (length === 0) {
              return;
            }
            var y = this.doc;
            if (y !== null) {
              _transact(y, function (transaction) {
                var pos = findPosition(transaction, _this50, index);
                if (pos.right === null) {
                  return;
                }
                formatText(transaction, _this50, pos, length, attributes);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this50.format(index, length, attributes);
              });
            }
          }

          /**
           * Removes an attribute.
           *
           * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
           *
           * @param {String} attributeName The attribute name that is to be removed.
           *
           * @public
           */
        }, {
          key: "removeAttribute",
          value: function removeAttribute(attributeName) {
            var _this51 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapDelete(transaction, _this51, attributeName);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this51.removeAttribute(attributeName);
              });
            }
          }

          /**
           * Sets or updates an attribute.
           *
           * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
           *
           * @param {String} attributeName The attribute name that is to be set.
           * @param {any} attributeValue The attribute value that is to be set.
           *
           * @public
           */
        }, {
          key: "setAttribute",
          value: function setAttribute(attributeName, attributeValue) {
            var _this52 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapSet(transaction, _this52, attributeName, attributeValue);
              });
            } else {
              /** @type {Array<function>} */this._pending.push(function () {
                return _this52.setAttribute(attributeName, attributeValue);
              });
            }
          }

          /**
           * Returns an attribute value that belongs to the attribute name.
           *
           * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
           *
           * @param {String} attributeName The attribute name that identifies the
           *                               queried value.
           * @return {any} The queried attribute value.
           *
           * @public
           */
        }, {
          key: "getAttribute",
          value: function getAttribute(attributeName) {
            return (/** @type {any} */typeMapGet(this, attributeName)
            );
          }

          /**
           * Returns all attribute name/value pairs in a JSON Object.
           *
           * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
           *
           * @return {Object<string, any>} A JSON Object that describes the attributes.
           *
           * @public
           */
        }, {
          key: "getAttributes",
          value: function getAttributes() {
            return typeMapGetAll(this);
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YTextRefID);
          }
        }]);
        return YText;
      }(_AbstractType);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
       * @return {YText}
       *
       * @private
       * @function
       */
      var readYText = function readYText(_decoder) {
        return new YText();
      };

      /**
       * @module YXml
       */

      /**
       * Define the elements to which a set of CSS queries apply.
       * {@link https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors|CSS_Selectors}
       *
       * @example
       *   query = '.classSelector'
       *   query = 'nodeSelector'
       *   query = '#idSelector'
       *
       * @typedef {string} CSS_Selector
       */

      /**
       * Dom filter function.
       *
       * @callback domFilter
       * @param {string} nodeName The nodeName of the element
       * @param {Map} attributes The map of attributes.
       * @return {boolean} Whether to include the Dom node in the YXmlElement.
       */

      /**
       * Represents a subset of the nodes of a YXmlElement / YXmlFragment and a
       * position within them.
       *
       * Can be created with {@link YXmlFragment#createTreeWalker}
       *
       * @public
       * @implements {Iterable<YXmlElement|YXmlText|YXmlElement|YXmlHook>}
       */
      var YXmlTreeWalker = /*#__PURE__*/function (_Symbol$iterator3) {
        /**
         * @param {YXmlFragment | YXmlElement} root
         * @param {function(AbstractType<any>):boolean} [f]
         */
        function YXmlTreeWalker(root) {
          var f = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
            return true;
          };
          _classCallCheck(this, YXmlTreeWalker);
          this._filter = f;
          this._root = root;
          /**
           * @type {Item}
           */
          this._currentNode = /** @type {Item} */root._start;
          this._firstCall = true;
        }
        _createClass(YXmlTreeWalker, [{
          key: _Symbol$iterator3,
          value: function value() {
            return this;
          }

          /**
           * Get the next node.
           *
           * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
           *
           * @public
           */
        }, {
          key: "next",
          value: function next() {
            /**
             * @type {Item|null}
             */
            var n = this._currentNode;
            var type = n && n.content && /** @type {any} */n.content.type;
            if (n !== null && (!this._firstCall || n.deleted || !this._filter(type))) {
              // if first call, we check if we can use the first item
              do {
                type = /** @type {any} */n.content.type;
                if (!n.deleted && (type.constructor === YXmlElement || type.constructor === YXmlFragment) && type._start !== null) {
                  // walk down in the tree
                  n = type._start;
                } else {
                  // walk right or up in the tree
                  while (n !== null) {
                    if (n.right !== null) {
                      n = n.right;
                      break;
                    } else if (n.parent === this._root) {
                      n = null;
                    } else {
                      n = /** @type {AbstractType<any>} */n.parent._item;
                    }
                  }
                }
              } while (n !== null && (n.deleted || !this._filter( /** @type {ContentType} */n.content.type)));
            }
            this._firstCall = false;
            if (n === null) {
              // @ts-ignore
              return {
                value: undefined,
                done: true
              };
            }
            this._currentNode = n;
            return {
              value: /** @type {any} */n.content.type,
              done: false
            };
          }
        }]);
        return YXmlTreeWalker;
      }(Symbol.iterator);
      /**
       * Represents a list of {@link YXmlElement}.and {@link YXmlText} types.
       * A YxmlFragment is similar to a {@link YXmlElement}, but it does not have a
       * nodeName and it does not have attributes. Though it can be bound to a DOM
       * element - in this case the attributes and the nodeName are not shared.
       *
       * @public
       * @extends AbstractType<YXmlEvent>
       */
      var YXmlFragment = /*#__PURE__*/function (_AbstractType5) {
        _inherits(YXmlFragment, _AbstractType5);
        var _super23 = _createSuper(YXmlFragment);
        function YXmlFragment() {
          var _this53;
          _classCallCheck(this, YXmlFragment);
          _this53 = _super23.call(this);
          /**
           * @type {Array<any>|null}
           */
          _this53._prelimContent = [];
          return _this53;
        }

        /**
         * @type {YXmlElement|YXmlText|null}
         */
        _createClass(YXmlFragment, [{
          key: "firstChild",
          get: function get() {
            var first = this._first;
            return first ? first.content.getContent()[0] : null;
          }

          /**
           * Integrate this type into the Yjs instance.
           *
           * * Save this struct in the os
           * * This type is sent to other client
           * * Observer functions are fired
           *
           * @param {Doc} y The Yjs instance
           * @param {Item} item
           */
        }, {
          key: "_integrate",
          value: function _integrate(y, item) {
            _get(_getPrototypeOf(YXmlFragment.prototype), "_integrate", this).call(this, y, item);
            this.insert(0, /** @type {Array<any>} */this._prelimContent);
            this._prelimContent = null;
          }
        }, {
          key: "_copy",
          value: function _copy() {
            return new YXmlFragment();
          }

          /**
           * @return {YXmlFragment}
           */
        }, {
          key: "clone",
          value: function clone() {
            var el = new YXmlFragment();
            // @ts-ignore
            el.insert(0, this.toArray().map(function (item) {
              return item instanceof _AbstractType ? item.clone() : item;
            }));
            return el;
          }
        }, {
          key: "length",
          get: function get() {
            return this._prelimContent === null ? this._length : this._prelimContent.length;
          }

          /**
           * Create a subtree of childNodes.
           *
           * @example
           * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
           * for (let node in walker) {
           *   // `node` is a div node
           *   nop(node)
           * }
           *
           * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
           *                          returns a Boolean indicating whether the child
           *                          is to be included in the subtree.
           * @return {YXmlTreeWalker} A subtree and a position within it.
           *
           * @public
           */
        }, {
          key: "createTreeWalker",
          value: function createTreeWalker(filter) {
            return new YXmlTreeWalker(this, filter);
          }

          /**
           * Returns the first YXmlElement that matches the query.
           * Similar to DOM's {@link querySelector}.
           *
           * Query support:
           *   - tagname
           * TODO:
           *   - id
           *   - attribute
           *
           * @param {CSS_Selector} query The query on the children.
           * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
           *
           * @public
           */
        }, {
          key: "querySelector",
          value: function querySelector(query) {
            query = query.toUpperCase();
            // @ts-ignore
            var iterator = new YXmlTreeWalker(this, function (element) {
              return element.nodeName && element.nodeName.toUpperCase() === query;
            });
            var next = iterator.next();
            if (next.done) {
              return null;
            } else {
              return next.value;
            }
          }

          /**
           * Returns all YXmlElements that match the query.
           * Similar to Dom's {@link querySelectorAll}.
           *
           * @todo Does not yet support all queries. Currently only query by tagName.
           *
           * @param {CSS_Selector} query The query on the children
           * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
           *
           * @public
           */
        }, {
          key: "querySelectorAll",
          value: function querySelectorAll(query) {
            query = query.toUpperCase();
            // @ts-ignore
            return lib0_array__WEBPACK_IMPORTED_MODULE_2__.from(new YXmlTreeWalker(this, function (element) {
              return element.nodeName && element.nodeName.toUpperCase() === query;
            }));
          }

          /**
           * Creates YXmlEvent and calls observers.
           *
           * @param {Transaction} transaction
           * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
           */
        }, {
          key: "_callObserver",
          value: function _callObserver(transaction, parentSubs) {
            callTypeObservers(this, transaction, new _YXmlEvent(this, parentSubs, transaction));
          }

          /**
           * Get the string representation of all the children of this YXmlFragment.
           *
           * @return {string} The string representation of all children.
           */
        }, {
          key: "toString",
          value: function toString() {
            return typeListMap(this, function (xml) {
              return xml.toString();
            }).join('');
          }

          /**
           * @return {string}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            return this.toString();
          }

          /**
           * Creates a Dom Element that mirrors this YXmlElement.
           *
           * @param {Document} [_document=document] The document object (you must define
           *                                        this when calling this method in
           *                                        nodejs)
           * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
           *                                             are presented in the DOM
           * @param {any} [binding] You should not set this property. This is
           *                               used if DomBinding wants to create a
           *                               association to the created DOM type.
           * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
           *
           * @public
           */
        }, {
          key: "toDOM",
          value: function toDOM() {
            var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var binding = arguments.length > 2 ? arguments[2] : undefined;
            var fragment = _document.createDocumentFragment();
            if (binding !== undefined) {
              binding._createAssociation(fragment, this);
            }
            typeListForEach(this, function (xmlType) {
              fragment.insertBefore(xmlType.toDOM(_document, hooks, binding), null);
            });
            return fragment;
          }

          /**
           * Inserts new content at an index.
           *
           * @example
           *  // Insert character 'a' at position 0
           *  xml.insert(0, [new Y.XmlText('text')])
           *
           * @param {number} index The index to insert content at
           * @param {Array<YXmlElement|YXmlText>} content The array of content
           */
        }, {
          key: "insert",
          value: function insert(index, content) {
            var _this54 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeListInsertGenerics(transaction, _this54, index, content);
              });
            } else {
              var _this$_prelimContent3;
              // @ts-ignore _prelimContent is defined because this is not yet integrated
              (_this$_prelimContent3 = this._prelimContent).splice.apply(_this$_prelimContent3, [index, 0].concat(_toConsumableArray(content)));
            }
          }

          /**
           * Inserts new content at an index.
           *
           * @example
           *  // Insert character 'a' at position 0
           *  xml.insert(0, [new Y.XmlText('text')])
           *
           * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
           * @param {Array<YXmlElement|YXmlText>} content The array of content
           */
        }, {
          key: "insertAfter",
          value: function insertAfter(ref, content) {
            var _this55 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                var refItem = ref && ref instanceof _AbstractType ? ref._item : ref;
                typeListInsertGenericsAfter(transaction, _this55, refItem, content);
              });
            } else {
              var pc = /** @type {Array<any>} */this._prelimContent;
              var index = ref === null ? 0 : pc.findIndex(function (el) {
                return el === ref;
              }) + 1;
              if (index === 0 && ref !== null) {
                throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.create('Reference item not found');
              }
              pc.splice.apply(pc, [index, 0].concat(_toConsumableArray(content)));
            }
          }

          /**
           * Deletes elements starting from an index.
           *
           * @param {number} index Index at which to start deleting elements
           * @param {number} [length=1] The number of elements to remove. Defaults to 1.
           */
        }, {
          key: "delete",
          value: function _delete(index) {
            var _this56 = this;
            var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeListDelete(transaction, _this56, index, length);
              });
            } else {
              // @ts-ignore _prelimContent is defined because this is not yet integrated
              this._prelimContent.splice(index, length);
            }
          }

          /**
           * Transforms this YArray to a JavaScript Array.
           *
           * @return {Array<YXmlElement|YXmlText|YXmlHook>}
           */
        }, {
          key: "toArray",
          value: function toArray() {
            return typeListToArray(this);
          }

          /**
           * Appends content to this YArray.
           *
           * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
           */
        }, {
          key: "push",
          value: function push(content) {
            this.insert(this.length, content);
          }

          /**
           * Preppends content to this YArray.
           *
           * @param {Array<YXmlElement|YXmlText>} content Array of content to preppend.
           */
        }, {
          key: "unshift",
          value: function unshift(content) {
            this.insert(0, content);
          }

          /**
           * Returns the i-th element from a YArray.
           *
           * @param {number} index The index of the element to return from the YArray
           * @return {YXmlElement|YXmlText}
           */
        }, {
          key: "get",
          value: function get(index) {
            return typeListGet(this, index);
          }

          /**
           * Transforms this YArray to a JavaScript Array.
           *
           * @param {number} [start]
           * @param {number} [end]
           * @return {Array<YXmlElement|YXmlText>}
           */
        }, {
          key: "slice",
          value: function slice() {
            var start = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
            var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.length;
            return typeListSlice(this, start, end);
          }

          /**
           * Executes a provided function on once on overy child element.
           *
           * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
           */
        }, {
          key: "forEach",
          value: function forEach(f) {
            typeListForEach(this, f);
          }

          /**
           * Transform the properties of this type to binary and write it to an
           * BinaryEncoder.
           *
           * This is called when this Item is sent to a remote peer.
           *
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YXmlFragmentRefID);
          }
        }]);
        return YXmlFragment;
      }(_AbstractType);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} _decoder
       * @return {YXmlFragment}
       *
       * @private
       * @function
       */
      var readYXmlFragment = function readYXmlFragment(_decoder) {
        return new YXmlFragment();
      };

      /**
       * @typedef {Object|number|null|Array<any>|string|Uint8Array|AbstractType<any>} ValueTypes
       */

      /**
       * An YXmlElement imitates the behavior of a
       * {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}.
       *
       * * An YXmlElement has attributes (key value pairs)
       * * An YXmlElement has childElements that must inherit from YXmlElement
       *
       * @template {{ [key: string]: ValueTypes }} [KV={ [key: string]: string }]
       */
      var YXmlElement = /*#__PURE__*/function (_YXmlFragment) {
        _inherits(YXmlElement, _YXmlFragment);
        var _super24 = _createSuper(YXmlElement);
        function YXmlElement() {
          var _this57;
          var nodeName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'UNDEFINED';
          _classCallCheck(this, YXmlElement);
          _this57 = _super24.call(this);
          _this57.nodeName = nodeName;
          /**
           * @type {Map<string, any>|null}
           */
          _this57._prelimAttrs = new Map();
          return _this57;
        }

        /**
         * @type {YXmlElement|YXmlText|null}
         */
        _createClass(YXmlElement, [{
          key: "nextSibling",
          get: function get() {
            var n = this._item ? this._item.next : null;
            return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */n.content.type : null;
          }

          /**
           * @type {YXmlElement|YXmlText|null}
           */
        }, {
          key: "prevSibling",
          get: function get() {
            var n = this._item ? this._item.prev : null;
            return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */n.content.type : null;
          }

          /**
           * Integrate this type into the Yjs instance.
           *
           * * Save this struct in the os
           * * This type is sent to other client
           * * Observer functions are fired
           *
           * @param {Doc} y The Yjs instance
           * @param {Item} item
           */
        }, {
          key: "_integrate",
          value: function _integrate(y, item) {
            var _this58 = this;
            _get(_getPrototypeOf(YXmlElement.prototype), "_integrate", this).call(this, y, item);
            /** @type {Map<string, any>} */this._prelimAttrs.forEach(function (value, key) {
              _this58.setAttribute(key, value);
            });
            this._prelimAttrs = null;
          }

          /**
           * Creates an Item with the same effect as this Item (without position effect)
           *
           * @return {YXmlElement}
           */
        }, {
          key: "_copy",
          value: function _copy() {
            return new YXmlElement(this.nodeName);
          }

          /**
           * @return {YXmlElement<KV>}
           */
        }, {
          key: "clone",
          value: function clone() {
            /**
             * @type {YXmlElement<KV>}
             */
            var el = new YXmlElement(this.nodeName);
            var attrs = this.getAttributes();
            lib0_object__WEBPACK_IMPORTED_MODULE_18__.forEach(attrs, function (value, key) {
              if (typeof value === 'string') {
                el.setAttribute(key, value);
              }
            });
            // @ts-ignore
            el.insert(0, this.toArray().map(function (item) {
              return item instanceof _AbstractType ? item.clone() : item;
            }));
            return el;
          }

          /**
           * Returns the XML serialization of this YXmlElement.
           * The attributes are ordered by attribute-name, so you can easily use this
           * method to compare YXmlElements
           *
           * @return {string} The string representation of this type.
           *
           * @public
           */
        }, {
          key: "toString",
          value: function toString() {
            var attrs = this.getAttributes();
            var stringBuilder = [];
            var keys = [];
            for (var key in attrs) {
              keys.push(key);
            }
            keys.sort();
            var keysLen = keys.length;
            for (var i = 0; i < keysLen; i++) {
              var _key7 = keys[i];
              stringBuilder.push(_key7 + '="' + attrs[_key7] + '"');
            }
            var nodeName = this.nodeName.toLocaleLowerCase();
            var attrsString = stringBuilder.length > 0 ? ' ' + stringBuilder.join(' ') : '';
            return "<".concat(nodeName).concat(attrsString, ">").concat(_get(_getPrototypeOf(YXmlElement.prototype), "toString", this).call(this), "</").concat(nodeName, ">");
          }

          /**
           * Removes an attribute from this YXmlElement.
           *
           * @param {string} attributeName The attribute name that is to be removed.
           *
           * @public
           */
        }, {
          key: "removeAttribute",
          value: function removeAttribute(attributeName) {
            var _this59 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapDelete(transaction, _this59, attributeName);
              });
            } else {
              /** @type {Map<string,any>} */this._prelimAttrs.delete(attributeName);
            }
          }

          /**
           * Sets or updates an attribute.
           *
           * @template {keyof KV & string} KEY
           *
           * @param {KEY} attributeName The attribute name that is to be set.
           * @param {KV[KEY]} attributeValue The attribute value that is to be set.
           *
           * @public
           */
        }, {
          key: "setAttribute",
          value: function setAttribute(attributeName, attributeValue) {
            var _this60 = this;
            if (this.doc !== null) {
              _transact(this.doc, function (transaction) {
                typeMapSet(transaction, _this60, attributeName, attributeValue);
              });
            } else {
              /** @type {Map<string, any>} */this._prelimAttrs.set(attributeName, attributeValue);
            }
          }

          /**
           * Returns an attribute value that belongs to the attribute name.
           *
           * @template {keyof KV & string} KEY
           *
           * @param {KEY} attributeName The attribute name that identifies the
           *                               queried value.
           * @return {KV[KEY]|undefined} The queried attribute value.
           *
           * @public
           */
        }, {
          key: "getAttribute",
          value: function getAttribute(attributeName) {
            return (/** @type {any} */typeMapGet(this, attributeName)
            );
          }

          /**
           * Returns whether an attribute exists
           *
           * @param {string} attributeName The attribute name to check for existence.
           * @return {boolean} whether the attribute exists.
           *
           * @public
           */
        }, {
          key: "hasAttribute",
          value: function hasAttribute(attributeName) {
            return (/** @type {any} */typeMapHas(this, attributeName)
            );
          }

          /**
           * Returns all attribute name/value pairs in a JSON Object.
           *
           * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
           *
           * @public
           */
        }, {
          key: "getAttributes",
          value: function getAttributes() {
            return (/** @type {any} */typeMapGetAll(this)
            );
          }

          /**
           * Creates a Dom Element that mirrors this YXmlElement.
           *
           * @param {Document} [_document=document] The document object (you must define
           *                                        this when calling this method in
           *                                        nodejs)
           * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
           *                                             are presented in the DOM
           * @param {any} [binding] You should not set this property. This is
           *                               used if DomBinding wants to create a
           *                               association to the created DOM type.
           * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
           *
           * @public
           */
        }, {
          key: "toDOM",
          value: function toDOM() {
            var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var binding = arguments.length > 2 ? arguments[2] : undefined;
            var dom = _document.createElement(this.nodeName);
            var attrs = this.getAttributes();
            for (var key in attrs) {
              var value = attrs[key];
              if (typeof value === 'string') {
                dom.setAttribute(key, value);
              }
            }
            typeListForEach(this, function (yxml) {
              dom.appendChild(yxml.toDOM(_document, hooks, binding));
            });
            if (binding !== undefined) {
              binding._createAssociation(dom, this);
            }
            return dom;
          }

          /**
           * Transform the properties of this type to binary and write it to an
           * BinaryEncoder.
           *
           * This is called when this Item is sent to a remote peer.
           *
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YXmlElementRefID);
            encoder.writeKey(this.nodeName);
          }
        }]);
        return YXmlElement;
      }(YXmlFragment);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {YXmlElement}
       *
       * @function
       */
      var readYXmlElement = function readYXmlElement(decoder) {
        return new YXmlElement(decoder.readKey());
      };

      /**
       * @extends YEvent<YXmlElement|YXmlText|YXmlFragment>
       * An Event that describes changes on a YXml Element or Yxml Fragment
       */
      var _YXmlEvent = /*#__PURE__*/function (_YEvent5) {
        _inherits(_YXmlEvent, _YEvent5);
        var _super25 = _createSuper(_YXmlEvent);
        /**
         * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
         * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
         *                   child list changed.
         * @param {Transaction} transaction The transaction instance with wich the
         *                                  change was created.
         */
        function _YXmlEvent(target, subs, transaction) {
          var _this61;
          _classCallCheck(this, _YXmlEvent);
          _this61 = _super25.call(this, target, transaction);
          /**
           * Whether the children changed.
           * @type {Boolean}
           * @private
           */
          _this61.childListChanged = false;
          /**
           * Set of all changed attributes.
           * @type {Set<string>}
           */
          _this61.attributesChanged = new Set();
          subs.forEach(function (sub) {
            if (sub === null) {
              _this61.childListChanged = true;
            } else {
              _this61.attributesChanged.add(sub);
            }
          });
          return _this61;
        }
        return _createClass(_YXmlEvent);
      }(_YEvent);
      /**
       * You can manage binding to a custom type with YXmlHook.
       *
       * @extends {YMap<any>}
       */
      var YXmlHook = /*#__PURE__*/function (_YMap) {
        _inherits(YXmlHook, _YMap);
        var _super26 = _createSuper(YXmlHook);
        /**
         * @param {string} hookName nodeName of the Dom Node.
         */
        function YXmlHook(hookName) {
          var _this62;
          _classCallCheck(this, YXmlHook);
          _this62 = _super26.call(this);
          /**
           * @type {string}
           */
          _this62.hookName = hookName;
          return _this62;
        }

        /**
         * Creates an Item with the same effect as this Item (without position effect)
         */
        _createClass(YXmlHook, [{
          key: "_copy",
          value: function _copy() {
            return new YXmlHook(this.hookName);
          }

          /**
           * @return {YXmlHook}
           */
        }, {
          key: "clone",
          value: function clone() {
            var el = new YXmlHook(this.hookName);
            this.forEach(function (value, key) {
              el.set(key, value);
            });
            return el;
          }

          /**
           * Creates a Dom Element that mirrors this YXmlElement.
           *
           * @param {Document} [_document=document] The document object (you must define
           *                                        this when calling this method in
           *                                        nodejs)
           * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
           *                                             are presented in the DOM
           * @param {any} [binding] You should not set this property. This is
           *                               used if DomBinding wants to create a
           *                               association to the created DOM type
           * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
           *
           * @public
           */
        }, {
          key: "toDOM",
          value: function toDOM() {
            var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var hooks = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
            var binding = arguments.length > 2 ? arguments[2] : undefined;
            var hook = hooks[this.hookName];
            var dom;
            if (hook !== undefined) {
              dom = hook.createDom(this);
            } else {
              dom = document.createElement(this.hookName);
            }
            dom.setAttribute('data-yjs-hook', this.hookName);
            if (binding !== undefined) {
              binding._createAssociation(dom, this);
            }
            return dom;
          }

          /**
           * Transform the properties of this type to binary and write it to an
           * BinaryEncoder.
           *
           * This is called when this Item is sent to a remote peer.
           *
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YXmlHookRefID);
            encoder.writeKey(this.hookName);
          }
        }]);
        return YXmlHook;
      }(YMap);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {YXmlHook}
       *
       * @private
       * @function
       */
      var readYXmlHook = function readYXmlHook(decoder) {
        return new YXmlHook(decoder.readKey());
      };

      /**
       * Represents text in a Dom Element. In the future this type will also handle
       * simple formatting information like bold and italic.
       */
      var YXmlText = /*#__PURE__*/function (_YText) {
        _inherits(YXmlText, _YText);
        var _super27 = _createSuper(YXmlText);
        function YXmlText() {
          _classCallCheck(this, YXmlText);
          return _super27.apply(this, arguments);
        }
        _createClass(YXmlText, [{
          key: "nextSibling",
          get:
          /**
           * @type {YXmlElement|YXmlText|null}
           */
          function get() {
            var n = this._item ? this._item.next : null;
            return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */n.content.type : null;
          }

          /**
           * @type {YXmlElement|YXmlText|null}
           */
        }, {
          key: "prevSibling",
          get: function get() {
            var n = this._item ? this._item.prev : null;
            return n ? /** @type {YXmlElement|YXmlText} */ /** @type {ContentType} */n.content.type : null;
          }
        }, {
          key: "_copy",
          value: function _copy() {
            return new YXmlText();
          }

          /**
           * @return {YXmlText}
           */
        }, {
          key: "clone",
          value: function clone() {
            var text = new YXmlText();
            text.applyDelta(this.toDelta());
            return text;
          }

          /**
           * Creates a Dom Element that mirrors this YXmlText.
           *
           * @param {Document} [_document=document] The document object (you must define
           *                                        this when calling this method in
           *                                        nodejs)
           * @param {Object<string, any>} [hooks] Optional property to customize how hooks
           *                                             are presented in the DOM
           * @param {any} [binding] You should not set this property. This is
           *                               used if DomBinding wants to create a
           *                               association to the created DOM type.
           * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
           *
           * @public
           */
        }, {
          key: "toDOM",
          value: function toDOM() {
            var _document = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : document;
            var hooks = arguments.length > 1 ? arguments[1] : undefined;
            var binding = arguments.length > 2 ? arguments[2] : undefined;
            var dom = _document.createTextNode(this.toString());
            if (binding !== undefined) {
              binding._createAssociation(dom, this);
            }
            return dom;
          }
        }, {
          key: "toString",
          value: function toString() {
            // @ts-ignore
            return this.toDelta().map(function (delta) {
              var nestedNodes = [];
              for (var nodeName in delta.attributes) {
                var attrs = [];
                for (var key in delta.attributes[nodeName]) {
                  attrs.push({
                    key: key,
                    value: delta.attributes[nodeName][key]
                  });
                }
                // sort attributes to get a unique order
                attrs.sort(function (a, b) {
                  return a.key < b.key ? -1 : 1;
                });
                nestedNodes.push({
                  nodeName: nodeName,
                  attrs: attrs
                });
              }
              // sort node order to get a unique order
              nestedNodes.sort(function (a, b) {
                return a.nodeName < b.nodeName ? -1 : 1;
              });
              // now convert to dom string
              var str = '';
              for (var i = 0; i < nestedNodes.length; i++) {
                var node = nestedNodes[i];
                str += "<".concat(node.nodeName);
                for (var j = 0; j < node.attrs.length; j++) {
                  var attr = node.attrs[j];
                  str += " ".concat(attr.key, "=\"").concat(attr.value, "\"");
                }
                str += '>';
              }
              str += delta.insert;
              for (var _i10 = nestedNodes.length - 1; _i10 >= 0; _i10--) {
                str += "</".concat(nestedNodes[_i10].nodeName, ">");
              }
              return str;
            }).join('');
          }

          /**
           * @return {string}
           */
        }, {
          key: "toJSON",
          value: function toJSON() {
            return this.toString();
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           */
        }, {
          key: "_write",
          value: function _write(encoder) {
            encoder.writeTypeRef(YXmlTextRefID);
          }
        }]);
        return YXmlText;
      }(YText);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {YXmlText}
       *
       * @private
       * @function
       */
      var readYXmlText = function readYXmlText(decoder) {
        return new YXmlText();
      };
      var _AbstractStruct = /*#__PURE__*/function () {
        /**
         * @param {ID} id
         * @param {number} length
         */
        function _AbstractStruct(id, length) {
          _classCallCheck(this, _AbstractStruct);
          this.id = id;
          this.length = length;
        }

        /**
         * @type {boolean}
         */
        _createClass(_AbstractStruct, [{
          key: "deleted",
          get: function get() {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * Merge this struct with the item to the right.
           * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
           * Also this method does *not* remove right from StructStore!
           * @param {AbstractStruct} right
           * @return {boolean} wether this merged with right
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            return false;
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
           * @param {number} offset
           * @param {number} encodingRef
           */
        }, {
          key: "write",
          value: function write(encoder, offset, encodingRef) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {Transaction} transaction
           * @param {number} offset
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }
        }]);
        return _AbstractStruct;
      }();
      var structGCRefNumber = 0;

      /**
       * @private
       */
      var _GC = /*#__PURE__*/function (_AbstractStruct2) {
        _inherits(_GC, _AbstractStruct2);
        var _super28 = _createSuper(_GC);
        function _GC() {
          _classCallCheck(this, _GC);
          return _super28.apply(this, arguments);
        }
        _createClass(_GC, [{
          key: "deleted",
          get: function get() {
            return true;
          }
        }, {
          key: "delete",
          value: function _delete() {}

          /**
           * @param {GC} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            if (this.constructor !== right.constructor) {
              return false;
            }
            this.length += right.length;
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {number} offset
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, offset) {
            if (offset > 0) {
              this.id.clock += offset;
              this.length -= offset;
            }
            addStruct(transaction.doc.store, this);
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeInfo(structGCRefNumber);
            encoder.writeLen(this.length - offset);
          }

          /**
           * @param {Transaction} transaction
           * @param {StructStore} store
           * @return {null | number}
           */
        }, {
          key: "getMissing",
          value: function getMissing(transaction, store) {
            return null;
          }
        }]);
        return _GC;
      }(_AbstractStruct);
      var _ContentBinary = /*#__PURE__*/function () {
        /**
         * @param {Uint8Array} content
         */
        function _ContentBinary(content) {
          _classCallCheck(this, _ContentBinary);
          this.content = content;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentBinary, [{
          key: "getLength",
          value: function getLength() {
            return 1;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [this.content];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentBinary}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentBinary(this.content);
          }

          /**
           * @param {number} offset
           * @return {ContentBinary}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {ContentBinary} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            return false;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {}
          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeBuf(this.content);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 3;
          }
        }]);
        return _ContentBinary;
      }();
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
       * @return {ContentBinary}
       */
      var readContentBinary = function readContentBinary(decoder) {
        return new _ContentBinary(decoder.readBuf());
      };
      var _ContentDeleted = /*#__PURE__*/function () {
        /**
         * @param {number} len
         */
        function _ContentDeleted(len) {
          _classCallCheck(this, _ContentDeleted);
          this.len = len;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentDeleted, [{
          key: "getLength",
          value: function getLength() {
            return this.len;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return false;
          }

          /**
           * @return {ContentDeleted}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentDeleted(this.len);
          }

          /**
           * @param {number} offset
           * @return {ContentDeleted}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            var right = new _ContentDeleted(this.len - offset);
            this.len = offset;
            return right;
          }

          /**
           * @param {ContentDeleted} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            this.len += right.len;
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {
            addToDeleteSet(transaction.deleteSet, item.id.client, item.id.clock, this.len);
            item.markDeleted();
          }

          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeLen(this.len - offset);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 1;
          }
        }]);
        return _ContentDeleted;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2 } decoder
       * @return {ContentDeleted}
       */
      var readContentDeleted = function readContentDeleted(decoder) {
        return new _ContentDeleted(decoder.readLen());
      };

      /**
       * @param {string} guid
       * @param {Object<string, any>} opts
       */
      var createDocFromOpts = function createDocFromOpts(guid, opts) {
        return new _Doc(_objectSpread(_objectSpread({
          guid: guid
        }, opts), {}, {
          shouldLoad: opts.shouldLoad || opts.autoLoad || false
        }));
      };

      /**
       * @private
       */
      var ContentDoc = /*#__PURE__*/function () {
        /**
         * @param {Doc} doc
         */
        function ContentDoc(doc) {
          _classCallCheck(this, ContentDoc);
          if (doc._item) {
            console.error('This document was already integrated as a sub-document. You should create a second instance instead with the same guid.');
          }
          /**
           * @type {Doc}
           */
          this.doc = doc;
          /**
           * @type {any}
           */
          var opts = {};
          this.opts = opts;
          if (!doc.gc) {
            opts.gc = false;
          }
          if (doc.autoLoad) {
            opts.autoLoad = true;
          }
          if (doc.meta !== null) {
            opts.meta = doc.meta;
          }
        }

        /**
         * @return {number}
         */
        _createClass(ContentDoc, [{
          key: "getLength",
          value: function getLength() {
            return 1;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [this.doc];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentDoc}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new ContentDoc(createDocFromOpts(this.doc.guid, this.opts));
          }

          /**
           * @param {number} offset
           * @return {ContentDoc}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {ContentDoc} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            return false;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {
            // this needs to be reflected in doc.destroy as well
            this.doc._item = item;
            transaction.subdocsAdded.add(this.doc);
            if (this.doc.shouldLoad) {
              transaction.subdocsLoaded.add(this.doc);
            }
          }

          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {
            if (transaction.subdocsAdded.has(this.doc)) {
              transaction.subdocsAdded.delete(this.doc);
            } else {
              transaction.subdocsRemoved.add(this.doc);
            }
          }

          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeString(this.doc.guid);
            encoder.writeAny(this.opts);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 9;
          }
        }]);
        return ContentDoc;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentDoc}
       */
      var readContentDoc = function readContentDoc(decoder) {
        return new ContentDoc(createDocFromOpts(decoder.readString(), decoder.readAny()));
      };

      /**
       * @private
       */
      var _ContentEmbed = /*#__PURE__*/function () {
        /**
         * @param {Object} embed
         */
        function _ContentEmbed(embed) {
          _classCallCheck(this, _ContentEmbed);
          this.embed = embed;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentEmbed, [{
          key: "getLength",
          value: function getLength() {
            return 1;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [this.embed];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentEmbed}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentEmbed(this.embed);
          }

          /**
           * @param {number} offset
           * @return {ContentEmbed}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {ContentEmbed} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            return false;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {}
          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeJSON(this.embed);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 5;
          }
        }]);
        return _ContentEmbed;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentEmbed}
       */
      var readContentEmbed = function readContentEmbed(decoder) {
        return new _ContentEmbed(decoder.readJSON());
      };

      /**
       * @private
       */
      var _ContentFormat = /*#__PURE__*/function () {
        /**
         * @param {string} key
         * @param {Object} value
         */
        function _ContentFormat(key, value) {
          _classCallCheck(this, _ContentFormat);
          this.key = key;
          this.value = value;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentFormat, [{
          key: "getLength",
          value: function getLength() {
            return 1;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return false;
          }

          /**
           * @return {ContentFormat}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentFormat(this.key, this.value);
          }

          /**
           * @param {number} _offset
           * @return {ContentFormat}
           */
        }, {
          key: "splice",
          value: function splice(_offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {ContentFormat} _right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(_right) {
            return false;
          }

          /**
           * @param {Transaction} _transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(_transaction, item) {
            // @todo searchmarker are currently unsupported for rich text documents
            var p = /** @type {YText} */item.parent;
            p._searchMarker = null;
            p._hasFormatting = true;
          }

          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeKey(this.key);
            encoder.writeJSON(this.value);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 6;
          }
        }]);
        return _ContentFormat;
      }();
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentFormat}
       */
      var readContentFormat = function readContentFormat(decoder) {
        return new _ContentFormat(decoder.readKey(), decoder.readJSON());
      };

      /**
       * @private
       */
      var _ContentJSON = /*#__PURE__*/function () {
        /**
         * @param {Array<any>} arr
         */
        function _ContentJSON(arr) {
          _classCallCheck(this, _ContentJSON);
          /**
           * @type {Array<any>}
           */
          this.arr = arr;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentJSON, [{
          key: "getLength",
          value: function getLength() {
            return this.arr.length;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return this.arr;
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentJSON}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentJSON(this.arr);
          }

          /**
           * @param {number} offset
           * @return {ContentJSON}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            var right = new _ContentJSON(this.arr.slice(offset));
            this.arr = this.arr.slice(0, offset);
            return right;
          }

          /**
           * @param {ContentJSON} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            this.arr = this.arr.concat(right.arr);
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {}
          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            var len = this.arr.length;
            encoder.writeLen(len - offset);
            for (var i = offset; i < len; i++) {
              var c = this.arr[i];
              encoder.writeString(c === undefined ? 'undefined' : JSON.stringify(c));
            }
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 2;
          }
        }]);
        return _ContentJSON;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentJSON}
       */
      var readContentJSON = function readContentJSON(decoder) {
        var len = decoder.readLen();
        var cs = [];
        for (var i = 0; i < len; i++) {
          var c = decoder.readString();
          if (c === 'undefined') {
            cs.push(undefined);
          } else {
            cs.push(JSON.parse(c));
          }
        }
        return new _ContentJSON(cs);
      };
      var _ContentAny = /*#__PURE__*/function () {
        /**
         * @param {Array<any>} arr
         */
        function _ContentAny(arr) {
          _classCallCheck(this, _ContentAny);
          /**
           * @type {Array<any>}
           */
          this.arr = arr;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentAny, [{
          key: "getLength",
          value: function getLength() {
            return this.arr.length;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return this.arr;
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentAny}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentAny(this.arr);
          }

          /**
           * @param {number} offset
           * @return {ContentAny}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            var right = new _ContentAny(this.arr.slice(offset));
            this.arr = this.arr.slice(0, offset);
            return right;
          }

          /**
           * @param {ContentAny} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            this.arr = this.arr.concat(right.arr);
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {}
          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            var len = this.arr.length;
            encoder.writeLen(len - offset);
            for (var i = offset; i < len; i++) {
              var c = this.arr[i];
              encoder.writeAny(c);
            }
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 8;
          }
        }]);
        return _ContentAny;
      }();
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentAny}
       */
      var readContentAny = function readContentAny(decoder) {
        var len = decoder.readLen();
        var cs = [];
        for (var i = 0; i < len; i++) {
          cs.push(decoder.readAny());
        }
        return new _ContentAny(cs);
      };

      /**
       * @private
       */
      var _ContentString = /*#__PURE__*/function () {
        /**
         * @param {string} str
         */
        function _ContentString(str) {
          _classCallCheck(this, _ContentString);
          /**
           * @type {string}
           */
          this.str = str;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentString, [{
          key: "getLength",
          value: function getLength() {
            return this.str.length;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return this.str.split('');
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentString}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentString(this.str);
          }

          /**
           * @param {number} offset
           * @return {ContentString}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            var right = new _ContentString(this.str.slice(offset));
            this.str = this.str.slice(0, offset);

            // Prevent encoding invalid documents because of splitting of surrogate pairs: https://github.com/yjs/yjs/issues/248
            var firstCharCode = this.str.charCodeAt(offset - 1);
            if (firstCharCode >= 0xD800 && firstCharCode <= 0xDBFF) {
              // Last character of the left split is the start of a surrogate utf16/ucs2 pair.
              // We don't support splitting of surrogate pairs because this may lead to invalid documents.
              // Replace the invalid character with a unicode replacement character ( / U+FFFD)
              this.str = this.str.slice(0, offset - 1) + '';
              // replace right as well
              right.str = '' + right.str.slice(1);
            }
            return right;
          }

          /**
           * @param {ContentString} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            this.str += right.str;
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {}
          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {}
          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {}
          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeString(offset === 0 ? this.str : this.str.slice(offset));
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 4;
          }
        }]);
        return _ContentString;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentString}
       */
      var readContentString = function readContentString(decoder) {
        return new _ContentString(decoder.readString());
      };

      /**
       * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractType<any>>}
       * @private
       */
      var typeRefs = [readYArray, readYMap, readYText, readYXmlElement, readYXmlFragment, readYXmlHook, readYXmlText];
      var YArrayRefID = 0;
      var YMapRefID = 1;
      var YTextRefID = 2;
      var YXmlElementRefID = 3;
      var YXmlFragmentRefID = 4;
      var YXmlHookRefID = 5;
      var YXmlTextRefID = 6;

      /**
       * @private
       */
      var _ContentType = /*#__PURE__*/function () {
        /**
         * @param {AbstractType<any>} type
         */
        function _ContentType(type) {
          _classCallCheck(this, _ContentType);
          /**
           * @type {AbstractType<any>}
           */
          this.type = type;
        }

        /**
         * @return {number}
         */
        _createClass(_ContentType, [{
          key: "getLength",
          value: function getLength() {
            return 1;
          }

          /**
           * @return {Array<any>}
           */
        }, {
          key: "getContent",
          value: function getContent() {
            return [this.type];
          }

          /**
           * @return {boolean}
           */
        }, {
          key: "isCountable",
          value: function isCountable() {
            return true;
          }

          /**
           * @return {ContentType}
           */
        }, {
          key: "copy",
          value: function copy() {
            return new _ContentType(this.type._copy());
          }

          /**
           * @param {number} offset
           * @return {ContentType}
           */
        }, {
          key: "splice",
          value: function splice(offset) {
            throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.methodUnimplemented();
          }

          /**
           * @param {ContentType} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            return false;
          }

          /**
           * @param {Transaction} transaction
           * @param {Item} item
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, item) {
            this.type._integrate(transaction.doc, item);
          }

          /**
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {
            var item = this.type._start;
            while (item !== null) {
              if (!item.deleted) {
                item.delete(transaction);
              } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
                // This will be gc'd later and we want to merge it if possible
                // We try to merge all deleted items after each transaction,
                // but we have no knowledge about that this needs to be merged
                // since it is not in transaction.ds. Hence we add it to transaction._mergeStructs
                transaction._mergeStructs.push(item);
              }
              item = item.right;
            }
            this.type._map.forEach(function (item) {
              if (!item.deleted) {
                item.delete(transaction);
              } else if (item.id.clock < (transaction.beforeState.get(item.id.client) || 0)) {
                // same as above
                transaction._mergeStructs.push(item);
              }
            });
            transaction.changed.delete(this.type);
          }

          /**
           * @param {StructStore} store
           */
        }, {
          key: "gc",
          value: function gc(store) {
            var item = this.type._start;
            while (item !== null) {
              item.gc(store, true);
              item = item.right;
            }
            this.type._start = null;
            this.type._map.forEach( /** @param {Item | null} item */function (item) {
              while (item !== null) {
                item.gc(store, true);
                item = item.left;
              }
            });
            this.type._map = new Map();
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            this.type._write(encoder);
          }

          /**
           * @return {number}
           */
        }, {
          key: "getRef",
          value: function getRef() {
            return 7;
          }
        }]);
        return _ContentType;
      }();
      /**
       * @private
       *
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @return {ContentType}
       */
      var readContentType = function readContentType(decoder) {
        return new _ContentType(typeRefs[decoder.readTypeRef()](decoder));
      };

      /**
       * @todo This should return several items
       *
       * @param {StructStore} store
       * @param {ID} id
       * @return {{item:Item, diff:number}}
       */
      var followRedone = function followRedone(store, id) {
        /**
         * @type {ID|null}
         */
        var nextID = id;
        var diff = 0;
        var item;
        do {
          if (diff > 0) {
            nextID = _createID(nextID.client, nextID.clock + diff);
          }
          item = _getItem(store, nextID);
          diff = nextID.clock - item.id.clock;
          nextID = item.redone;
        } while (nextID !== null && item instanceof _Item);
        return {
          item: item,
          diff: diff
        };
      };

      /**
       * Make sure that neither item nor any of its parents is ever deleted.
       *
       * This property does not persist when storing it into a database or when
       * sending it to other peers
       *
       * @param {Item|null} item
       * @param {boolean} keep
       */
      var keepItem = function keepItem(item, keep) {
        while (item !== null && item.keep !== keep) {
          item.keep = keep;
          item = /** @type {AbstractType<any>} */item.parent._item;
        }
      };

      /**
       * Split leftItem into two items
       * @param {Transaction} transaction
       * @param {Item} leftItem
       * @param {number} diff
       * @return {Item}
       *
       * @function
       * @private
       */
      var splitItem = function splitItem(transaction, leftItem, diff) {
        // create rightItem
        var _leftItem$id2 = leftItem.id,
          client = _leftItem$id2.client,
          clock = _leftItem$id2.clock;
        var rightItem = new _Item(_createID(client, clock + diff), leftItem, _createID(client, clock + diff - 1), leftItem.right, leftItem.rightOrigin, leftItem.parent, leftItem.parentSub, leftItem.content.splice(diff));
        if (leftItem.deleted) {
          rightItem.markDeleted();
        }
        if (leftItem.keep) {
          rightItem.keep = true;
        }
        if (leftItem.redone !== null) {
          rightItem.redone = _createID(leftItem.redone.client, leftItem.redone.clock + diff);
        }
        // update left (do not set leftItem.rightOrigin as it will lead to problems when syncing)
        leftItem.right = rightItem;
        // update right
        if (rightItem.right !== null) {
          rightItem.right.left = rightItem;
        }
        // right is more specific.
        transaction._mergeStructs.push(rightItem);
        // update parent._map
        if (rightItem.parentSub !== null && rightItem.right === null) {
          /** @type {AbstractType<any>} */rightItem.parent._map.set(rightItem.parentSub, rightItem);
        }
        leftItem.length = diff;
        return rightItem;
      };

      /**
       * @param {Array<StackItem>} stack
       * @param {ID} id
       */
      var isDeletedByUndoStack = function isDeletedByUndoStack(stack, id) {
        return lib0_array__WEBPACK_IMPORTED_MODULE_2__.some(stack, /** @param {StackItem} s */function (s) {
          return _isDeleted(s.deletions, id);
        });
      };

      /**
       * Redoes the effect of this operation.
       *
       * @param {Transaction} transaction The Yjs instance.
       * @param {Item} item
       * @param {Set<Item>} redoitems
       * @param {DeleteSet} itemsToDelete
       * @param {boolean} ignoreRemoteMapChanges
       * @param {import('../utils/UndoManager.js').UndoManager} um
       *
       * @return {Item|null}
       *
       * @private
       */
      var redoItem = function redoItem(transaction, item, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) {
        var doc = transaction.doc;
        var store = doc.store;
        var ownClientID = doc.clientID;
        var redone = item.redone;
        if (redone !== null) {
          return getItemCleanStart(transaction, redone);
        }
        var parentItem = /** @type {AbstractType<any>} */item.parent._item;
        /**
         * @type {Item|null}
         */
        var left = null;
        /**
         * @type {Item|null}
         */
        var right;
        // make sure that parent is redone
        if (parentItem !== null && parentItem.deleted === true) {
          // try to undo parent if it will be undone anyway
          if (parentItem.redone === null && (!redoitems.has(parentItem) || redoItem(transaction, parentItem, redoitems, itemsToDelete, ignoreRemoteMapChanges, um) === null)) {
            return null;
          }
          while (parentItem.redone !== null) {
            parentItem = getItemCleanStart(transaction, parentItem.redone);
          }
        }
        var parentType = parentItem === null ? /** @type {AbstractType<any>} */item.parent : /** @type {ContentType} */parentItem.content.type;
        if (item.parentSub === null) {
          // Is an array item. Insert at the old position
          left = item.left;
          right = item;
          // find next cloned_redo items
          while (left !== null) {
            /**
             * @type {Item|null}
             */
            var leftTrace = left;
            // trace redone until parent matches
            while (leftTrace !== null && /** @type {AbstractType<any>} */leftTrace.parent._item !== parentItem) {
              leftTrace = leftTrace.redone === null ? null : getItemCleanStart(transaction, leftTrace.redone);
            }
            if (leftTrace !== null && /** @type {AbstractType<any>} */leftTrace.parent._item === parentItem) {
              left = leftTrace;
              break;
            }
            left = left.left;
          }
          while (right !== null) {
            /**
             * @type {Item|null}
             */
            var rightTrace = right;
            // trace redone until parent matches
            while (rightTrace !== null && /** @type {AbstractType<any>} */rightTrace.parent._item !== parentItem) {
              rightTrace = rightTrace.redone === null ? null : getItemCleanStart(transaction, rightTrace.redone);
            }
            if (rightTrace !== null && /** @type {AbstractType<any>} */rightTrace.parent._item === parentItem) {
              right = rightTrace;
              break;
            }
            right = right.right;
          }
        } else {
          right = null;
          if (item.right && !ignoreRemoteMapChanges) {
            left = item;
            // Iterate right while right is in itemsToDelete
            // If it is intended to delete right while item is redone, we can expect that item should replace right.
            while (left !== null && left.right !== null && (left.right.redone || _isDeleted(itemsToDelete, left.right.id) || isDeletedByUndoStack(um.undoStack, left.right.id) || isDeletedByUndoStack(um.redoStack, left.right.id))) {
              left = left.right;
              // follow redone
              while (left.redone) left = getItemCleanStart(transaction, left.redone);
            }
            if (left && left.right !== null) {
              // It is not possible to redo this item because it conflicts with a
              // change from another client
              return null;
            }
          } else {
            left = parentType._map.get(item.parentSub) || null;
          }
        }
        var nextClock = _getState(store, ownClientID);
        var nextId = _createID(ownClientID, nextClock);
        var redoneItem = new _Item(nextId, left, left && left.lastId, right, right && right.id, parentType, item.parentSub, item.content.copy());
        item.redone = nextId;
        keepItem(redoneItem, true);
        redoneItem.integrate(transaction, 0);
        return redoneItem;
      };

      /**
       * Abstract class that represents any content.
       */
      var _Item = /*#__PURE__*/function (_AbstractStruct3) {
        _inherits(_Item, _AbstractStruct3);
        var _super29 = _createSuper(_Item);
        /**
         * @param {ID} id
         * @param {Item | null} left
         * @param {ID | null} origin
         * @param {Item | null} right
         * @param {ID | null} rightOrigin
         * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
         * @param {string | null} parentSub
         * @param {AbstractContent} content
         */
        function _Item(id, left, origin, right, rightOrigin, parent, parentSub, content) {
          var _this63;
          _classCallCheck(this, _Item);
          _this63 = _super29.call(this, id, content.getLength());
          /**
           * The item that was originally to the left of this item.
           * @type {ID | null}
           */
          _this63.origin = origin;
          /**
           * The item that is currently to the left of this item.
           * @type {Item | null}
           */
          _this63.left = left;
          /**
           * The item that is currently to the right of this item.
           * @type {Item | null}
           */
          _this63.right = right;
          /**
           * The item that was originally to the right of this item.
           * @type {ID | null}
           */
          _this63.rightOrigin = rightOrigin;
          /**
           * @type {AbstractType<any>|ID|null}
           */
          _this63.parent = parent;
          /**
           * If the parent refers to this item with some kind of key (e.g. YMap, the
           * key is specified here. The key is then used to refer to the list in which
           * to insert this item. If `parentSub = null` type._start is the list in
           * which to insert to. Otherwise it is `parent._map`.
           * @type {String | null}
           */
          _this63.parentSub = parentSub;
          /**
           * If this type's effect is redone this type refers to the type that undid
           * this operation.
           * @type {ID | null}
           */
          _this63.redone = null;
          /**
           * @type {AbstractContent}
           */
          _this63.content = content;
          /**
           * bit1: keep
           * bit2: countable
           * bit3: deleted
           * bit4: mark - mark node as fast-search-marker
           * @type {number} byte
           */
          _this63.info = _this63.content.isCountable() ? lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2 : 0;
          return _this63;
        }

        /**
         * This is used to mark the item as an indexed fast-search marker
         *
         * @type {boolean}
         */
        _createClass(_Item, [{
          key: "marker",
          get: function get() {
            return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0;
          }

          /**
           * If true, do not garbage collect this Item.
           */,
          set: function set(isMarked) {
            if ((this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4) > 0 !== isMarked) {
              this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT4;
            }
          }
        }, {
          key: "keep",
          get: function get() {
            return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1) > 0;
          },
          set: function set(doKeep) {
            if (this.keep !== doKeep) {
              this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT1;
            }
          }
        }, {
          key: "countable",
          get: function get() {
            return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT2) > 0;
          }

          /**
           * Whether this item was deleted or not.
           * @type {Boolean}
           */
        }, {
          key: "deleted",
          get: function get() {
            return (this.info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3) > 0;
          },
          set: function set(doDelete) {
            if (this.deleted !== doDelete) {
              this.info ^= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;
            }
          }
        }, {
          key: "markDeleted",
          value: function markDeleted() {
            this.info |= lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT3;
          }

          /**
           * Return the creator clientID of the missing op or define missing items and return null.
           *
           * @param {Transaction} transaction
           * @param {StructStore} store
           * @return {null | number}
           */
        }, {
          key: "getMissing",
          value: function getMissing(transaction, store) {
            if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= _getState(store, this.origin.client)) {
              return this.origin.client;
            }
            if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= _getState(store, this.rightOrigin.client)) {
              return this.rightOrigin.client;
            }
            if (this.parent && this.parent.constructor === _ID && this.id.client !== this.parent.client && this.parent.clock >= _getState(store, this.parent.client)) {
              return this.parent.client;
            }

            // We have all missing ids, now find the items

            if (this.origin) {
              this.left = getItemCleanEnd(transaction, store, this.origin);
              this.origin = this.left.lastId;
            }
            if (this.rightOrigin) {
              this.right = getItemCleanStart(transaction, this.rightOrigin);
              this.rightOrigin = this.right.id;
            }
            if (this.left && this.left.constructor === _GC || this.right && this.right.constructor === _GC) {
              this.parent = null;
            } else if (!this.parent) {
              // only set parent if this shouldn't be garbage collected
              if (this.left && this.left.constructor === _Item) {
                this.parent = this.left.parent;
                this.parentSub = this.left.parentSub;
              }
              if (this.right && this.right.constructor === _Item) {
                this.parent = this.right.parent;
                this.parentSub = this.right.parentSub;
              }
            } else if (this.parent.constructor === _ID) {
              var parentItem = _getItem(store, this.parent);
              if (parentItem.constructor === _GC) {
                this.parent = null;
              } else {
                this.parent = /** @type {ContentType} */parentItem.content.type;
              }
            }
            return null;
          }

          /**
           * @param {Transaction} transaction
           * @param {number} offset
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, offset) {
            if (offset > 0) {
              this.id.clock += offset;
              this.left = getItemCleanEnd(transaction, transaction.doc.store, _createID(this.id.client, this.id.clock - 1));
              this.origin = this.left.lastId;
              this.content = this.content.splice(offset);
              this.length -= offset;
            }
            if (this.parent) {
              if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
                /**
                 * @type {Item|null}
                 */
                var left = this.left;

                /**
                 * @type {Item|null}
                 */
                var o;
                // set o to the first conflicting item
                if (left !== null) {
                  o = left.right;
                } else if (this.parentSub !== null) {
                  o = /** @type {AbstractType<any>} */this.parent._map.get(this.parentSub) || null;
                  while (o !== null && o.left !== null) {
                    o = o.left;
                  }
                } else {
                  o = /** @type {AbstractType<any>} */this.parent._start;
                }
                // TODO: use something like DeleteSet here (a tree implementation would be best)
                // @todo use global set definitions
                /**
                 * @type {Set<Item>}
                 */
                var conflictingItems = new Set();
                /**
                 * @type {Set<Item>}
                 */
                var itemsBeforeOrigin = new Set();
                // Let c in conflictingItems, b in itemsBeforeOrigin
                // ***{origin}bbbb{this}{c,b}{c,b}{o}***
                // Note that conflictingItems is a subset of itemsBeforeOrigin
                while (o !== null && o !== this.right) {
                  itemsBeforeOrigin.add(o);
                  conflictingItems.add(o);
                  if (_compareIDs(this.origin, o.origin)) {
                    // case 1
                    if (o.id.client < this.id.client) {
                      left = o;
                      conflictingItems.clear();
                    } else if (_compareIDs(this.rightOrigin, o.rightOrigin)) {
                      // this and o are conflicting and point to the same integration points. The id decides which item comes first.
                      // Since this is to the left of o, we can break here
                      break;
                    } // else, o might be integrated before an item that this conflicts with. If so, we will find it in the next iterations
                  } else if (o.origin !== null && itemsBeforeOrigin.has(_getItem(transaction.doc.store, o.origin))) {
                    // use getItem instead of getItemCleanEnd because we don't want / need to split items.
                    // case 2
                    if (!conflictingItems.has(_getItem(transaction.doc.store, o.origin))) {
                      left = o;
                      conflictingItems.clear();
                    }
                  } else {
                    break;
                  }
                  o = o.right;
                }
                this.left = left;
              }
              // reconnect left/right + update parent map/start if necessary
              if (this.left !== null) {
                var right = this.left.right;
                this.right = right;
                this.left.right = this;
              } else {
                var r;
                if (this.parentSub !== null) {
                  r = /** @type {AbstractType<any>} */this.parent._map.get(this.parentSub) || null;
                  while (r !== null && r.left !== null) {
                    r = r.left;
                  }
                } else {
                  r = /** @type {AbstractType<any>} */this.parent._start; /** @type {AbstractType<any>} */
                  this.parent._start = this;
                }
                this.right = r;
              }
              if (this.right !== null) {
                this.right.left = this;
              } else if (this.parentSub !== null) {
                // set as current parent value if right === null and this is parentSub
                /** @type {AbstractType<any>} */
                this.parent._map.set(this.parentSub, this);
                if (this.left !== null) {
                  // this is the current attribute value of parent. delete right
                  this.left.delete(transaction);
                }
              }
              // adjust length of parent
              if (this.parentSub === null && this.countable && !this.deleted) {
                /** @type {AbstractType<any>} */this.parent._length += this.length;
              }
              addStruct(transaction.doc.store, this);
              this.content.integrate(transaction, this);
              // add parent to transaction.changed
              addChangedTypeToTransaction(transaction, /** @type {AbstractType<any>} */this.parent, this.parentSub);
              if ( /** @type {AbstractType<any>} */this.parent._item !== null && /** @type {AbstractType<any>} */this.parent._item.deleted || this.parentSub !== null && this.right !== null) {
                // delete if parent is deleted or if this is not the current attribute value of parent
                this.delete(transaction);
              }
            } else {
              // parent is not defined. Integrate GC struct instead
              new _GC(this.id, this.length).integrate(transaction, 0);
            }
          }

          /**
           * Returns the next non-deleted item
           */
        }, {
          key: "next",
          get: function get() {
            var n = this.right;
            while (n !== null && n.deleted) {
              n = n.right;
            }
            return n;
          }

          /**
           * Returns the previous non-deleted item
           */
        }, {
          key: "prev",
          get: function get() {
            var n = this.left;
            while (n !== null && n.deleted) {
              n = n.left;
            }
            return n;
          }

          /**
           * Computes the last content address of this Item.
           */
        }, {
          key: "lastId",
          get: function get() {
            // allocating ids is pretty costly because of the amount of ids created, so we try to reuse whenever possible
            return this.length === 1 ? this.id : _createID(this.id.client, this.id.clock + this.length - 1);
          }

          /**
           * Try to merge two items
           *
           * @param {Item} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            var _this64 = this;
            if (this.constructor === right.constructor && _compareIDs(right.origin, this.lastId) && this.right === right && _compareIDs(this.rightOrigin, right.rightOrigin) && this.id.client === right.id.client && this.id.clock + this.length === right.id.clock && this.deleted === right.deleted && this.redone === null && right.redone === null && this.content.constructor === right.content.constructor && this.content.mergeWith(right.content)) {
              var searchMarker = /** @type {AbstractType<any>} */this.parent._searchMarker;
              if (searchMarker) {
                searchMarker.forEach(function (marker) {
                  if (marker.p === right) {
                    // right is going to be "forgotten" so we need to update the marker
                    marker.p = _this64;
                    // adjust marker index
                    if (!_this64.deleted && _this64.countable) {
                      marker.index -= _this64.length;
                    }
                  }
                });
              }
              if (right.keep) {
                this.keep = true;
              }
              this.right = right.right;
              if (this.right !== null) {
                this.right.left = this;
              }
              this.length += right.length;
              return true;
            }
            return false;
          }

          /**
           * Mark this Item as deleted.
           *
           * @param {Transaction} transaction
           */
        }, {
          key: "delete",
          value: function _delete(transaction) {
            if (!this.deleted) {
              var parent = /** @type {AbstractType<any>} */this.parent;
              // adjust the length of parent
              if (this.countable && this.parentSub === null) {
                parent._length -= this.length;
              }
              this.markDeleted();
              addToDeleteSet(transaction.deleteSet, this.id.client, this.id.clock, this.length);
              addChangedTypeToTransaction(transaction, parent, this.parentSub);
              this.content.delete(transaction);
            }
          }

          /**
           * @param {StructStore} store
           * @param {boolean} parentGCd
           */
        }, {
          key: "gc",
          value: function gc(store, parentGCd) {
            if (!this.deleted) {
              throw lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
            }
            this.content.gc(store);
            if (parentGCd) {
              replaceStruct(store, this, new _GC(this.id, this.length));
            } else {
              this.content = new _ContentDeleted(this.length);
            }
          }

          /**
           * Transform the properties of this type to binary and write it to an
           * BinaryEncoder.
           *
           * This is called when this Item is sent to a remote peer.
           *
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            var origin = offset > 0 ? _createID(this.id.client, this.id.clock + offset - 1) : this.origin;
            var rightOrigin = this.rightOrigin;
            var parentSub = this.parentSub;
            var info = this.content.getRef() & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5 | (origin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT8) | (
            // origin is defined
            rightOrigin === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT7) | (
            // right origin is defined
            parentSub === null ? 0 : lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BIT6); // parentSub is non-null
            encoder.writeInfo(info);
            if (origin !== null) {
              encoder.writeLeftID(origin);
            }
            if (rightOrigin !== null) {
              encoder.writeRightID(rightOrigin);
            }
            if (origin === null && rightOrigin === null) {
              var parent = /** @type {AbstractType<any>} */this.parent;
              if (parent._item !== undefined) {
                var parentItem = parent._item;
                if (parentItem === null) {
                  // parent type on y._map
                  // find the correct key
                  var ykey = _findRootTypeKey(parent);
                  encoder.writeParentInfo(true); // write parentYKey
                  encoder.writeString(ykey);
                } else {
                  encoder.writeParentInfo(false); // write parent id
                  encoder.writeLeftID(parentItem.id);
                }
              } else if (parent.constructor === String) {
                // this edge case was added by differential updates
                encoder.writeParentInfo(true); // write parentYKey
                encoder.writeString(parent);
              } else if (parent.constructor === _ID) {
                encoder.writeParentInfo(false); // write parent id
                encoder.writeLeftID(parent);
              } else {
                lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
              }
              if (parentSub !== null) {
                encoder.writeString(parentSub);
              }
            }
            this.content.write(encoder, offset);
          }
        }]);
        return _Item;
      }(_AbstractStruct);
      /**
       * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
       * @param {number} info
       */
      var readItemContent = function readItemContent(decoder, info) {
        return contentRefs[info & lib0_binary__WEBPACK_IMPORTED_MODULE_10__.BITS5](decoder);
      };

      /**
       * A lookup map for reading Item content.
       *
       * @type {Array<function(UpdateDecoderV1 | UpdateDecoderV2):AbstractContent>}
       */
      var contentRefs = [function () {
        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
      },
      // GC is not ItemContent
      readContentDeleted,
      // 1
      readContentJSON,
      // 2
      readContentBinary,
      // 3
      readContentString,
      // 4
      readContentEmbed,
      // 5
      readContentFormat,
      // 6
      readContentType,
      // 7
      readContentAny,
      // 8
      readContentDoc,
      // 9
      function () {
        lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
      } // 10 - Skip is not ItemContent
      ];

      var structSkipRefNumber = 10;

      /**
       * @private
       */
      var Skip = /*#__PURE__*/function (_AbstractStruct4) {
        _inherits(Skip, _AbstractStruct4);
        var _super30 = _createSuper(Skip);
        function Skip() {
          _classCallCheck(this, Skip);
          return _super30.apply(this, arguments);
        }
        _createClass(Skip, [{
          key: "deleted",
          get: function get() {
            return true;
          }
        }, {
          key: "delete",
          value: function _delete() {}

          /**
           * @param {Skip} right
           * @return {boolean}
           */
        }, {
          key: "mergeWith",
          value: function mergeWith(right) {
            if (this.constructor !== right.constructor) {
              return false;
            }
            this.length += right.length;
            return true;
          }

          /**
           * @param {Transaction} transaction
           * @param {number} offset
           */
        }, {
          key: "integrate",
          value: function integrate(transaction, offset) {
            // skip structs cannot be integrated
            lib0_error__WEBPACK_IMPORTED_MODULE_9__.unexpectedCase();
          }

          /**
           * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
           * @param {number} offset
           */
        }, {
          key: "write",
          value: function write(encoder, offset) {
            encoder.writeInfo(structSkipRefNumber);
            // write as VarUint because Skips can't make use of predictable length-encoding
            lib0_encoding__WEBPACK_IMPORTED_MODULE_4__.writeVarUint(encoder.restEncoder, this.length - offset);
          }

          /**
           * @param {Transaction} transaction
           * @param {StructStore} store
           * @return {null | number}
           */
        }, {
          key: "getMissing",
          value: function getMissing(transaction, store) {
            return null;
          }
        }]);
        return Skip;
      }(_AbstractStruct);
      /** eslint-env browser */
      var glo = /** @type {any} */typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window
      // @ts-ignore
      : typeof global !== 'undefined' ? global : {};
      var importIdentifier = '__ $YJS$ __';
      if (glo[importIdentifier] === true) {
        /**
         * Dear reader of this message. Please take this seriously.
         *
         * If you see this message, make sure that you only import one version of Yjs. In many cases,
         * your package manager installs two versions of Yjs that are used by different packages within your project.
         * Another reason for this message is that some parts of your project use the commonjs version of Yjs
         * and others use the EcmaScript version of Yjs.
         *
         * This often leads to issues that are hard to debug. We often need to perform constructor checks,
         * e.g. `struct instanceof GC`. If you imported different versions of Yjs, it is impossible for us to
         * do the constructor checks anymore - which might break the CRDT algorithm.
         *
         * https://github.com/yjs/yjs/issues/438
         */
        console.error('Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438');
      }
      glo[importIdentifier] = true;

      /***/
    }

    /******/
  };
  /************************************************************************/
  /******/ // The module cache
  /******/
  var __webpack_module_cache__ = {};
  /******/
  /******/ // The require function
  /******/
  function __webpack_require__(moduleId) {
    /******/ // Check if module is in cache
    /******/var cachedModule = __webpack_module_cache__[moduleId];
    /******/
    if (cachedModule !== undefined) {
      /******/return cachedModule.exports;
      /******/
    }
    /******/ // Create a new module (and put it into the cache)
    /******/
    var module = __webpack_module_cache__[moduleId] = {
      /******/id: moduleId,
      /******/loaded: false,
      /******/exports: {}
      /******/
    };
    /******/
    /******/ // Execute the module function
    /******/
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    /******/
    /******/ // Flag the module as loaded
    /******/
    module.loaded = true;
    /******/
    /******/ // Return the exports of the module
    /******/
    return module.exports;
    /******/
  }
  /******/
  /************************************************************************/
  /******/ /* webpack/runtime/compat get default export */
  /******/
  (function () {
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/__webpack_require__.n = function (module) {
      /******/var getter = module && module.__esModule ? /******/function () {
        return module['default'];
      } : /******/function () {
        return module;
      };
      /******/
      __webpack_require__.d(getter, {
        a: getter
      });
      /******/
      return getter;
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/define property getters */
  /******/
  (function () {
    /******/ // define getter functions for harmony exports
    /******/__webpack_require__.d = function (exports, definition) {
      /******/for (var key in definition) {
        /******/if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
          /******/Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
          });
          /******/
        }
        /******/
      }
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/global */
  /******/
  (function () {
    /******/__webpack_require__.g = function () {
      /******/if (typeof globalThis === 'object') return globalThis;
      /******/
      try {
        /******/return this || new Function('return this')();
        /******/
      } catch (e) {
        /******/if (typeof window === 'object') return window;
        /******/
      }
      /******/
    }();
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/hasOwnProperty shorthand */
  /******/
  (function () {
    /******/__webpack_require__.o = function (obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/make namespace object */
  /******/
  (function () {
    /******/ // define __esModule on exports
    /******/__webpack_require__.r = function (exports) {
      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/
  })();
  /******/
  /******/ /* webpack/runtime/node module decorator */
  /******/
  (function () {
    /******/__webpack_require__.nmd = function (module) {
      /******/module.paths = [];
      /******/
      if (!module.children) module.children = [];
      /******/
      return module;
      /******/
    };
    /******/
  })();
  /******/
  /************************************************************************/
  var __webpack_exports__ = {};
  // This entry need to be wrapped in an IIFE because it need to be in strict mode.
  (function () {
    "use strict";

    /*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
    __webpack_require__.r(__webpack_exports__);
    /* harmony import */
    var lodash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__( /*! lodash */"./node_modules/lodash/lodash.js");
    /* harmony import */
    var lodash__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_0__);
    /* harmony import */
    var _yjs_test_ts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__( /*! ./yjs-test.ts */"./src/yjs-test.ts");
    function component() {
      var element = document.createElement('div');

      // Lodash, currently included via a script, is required for this line to work
      element.innerHTML = lodash__WEBPACK_IMPORTED_MODULE_0___default().join(['Hello', 'webpack.', 'Check console log to see if YJS is working'], ' ');
      return element;
    }
    document.body.appendChild(component());
    (0, _yjs_test_ts__WEBPACK_IMPORTED_MODULE_1__.testYJS)();
  })();

  /******/
})();